<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>我的技术与生活——小站首页 | Mr.Long</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <link rel="shortcut icon" href="/imgs/shortcut-icon.ico" type="image/x-icon">
  <link rel="stylesheet" href="/css/public.css" />
  <link rel="stylesheet" href="/css/layout.css" />
  <link rel="stylesheet" href="/css/iconfont.css" />
  <link rel="stylesheet" href="/css/APlayer.min.css" />
  <script src="/js/APlayer.min.js"></script>
  <script src="/js/jquery.min.js"></script>
  <script src="/js/jquery.pjax.min.js"></script>

  <script src='//unpkg.com/valine/dist/Valine.min.js'></script>
  <script>
    document.title = `我的技术与生活——小站首页`
  </script>
<meta name="generator" content="Hexo 7.3.0"></head>

<style>
  .load {
    width: 100%;
    height: 100vh;
    background-color: rgb(37, 35, 40);
    display: flex;
    flex-direction: column;
    justify-content: center;
    align-items: center;
    position: relative;
    z-index: 9999;
  }
  .load-circle {
    width: 80px;
    height: 80px;
    border: 8px solid orange;
    border-bottom-color: transparent;
    border-radius: 50%;
    display: flex;
    justify-content: center;
    align-items: center;
    animation: rotate 1s linear infinite;
    filter: drop-shadow(0 0 3px orange);
  }
  .load-circle-inner {
    width: 40px;
    height: 40px;
    border: 8px solid orange;
    border-top-color: transparent;
    border-radius: 50%;
    animation: rotate-reverse .5s linear infinite;
  }
  .load-text {
    margin-top: 20px;
    font-size: 24px;
    color: orange;
    display: flex;
  }
  .load-text span {
    margin: 0 5px;
    text-shadow: 5px 5px 5px orange;
    animation: move 1s linear infinite;
  }
  .load-text span:nth-child(1) {
    animation-delay: -0.6s;
  }
  .load-text span:nth-child(2) {
    animation-delay: -0.5s;
  }
  .load-text span:nth-child(3) {
    animation-delay: -0.4s;
  }
  .load-text span:nth-child(4) {
    animation-delay: -0.3s;
  }
  .load-text span:nth-child(5) {
    animation-delay: -0.2s;
  }
  .load-text span:nth-child(6) {
    animation-delay: -0.1s;
  }
  @keyframes rotate {
    0% { transform: rotate(0); }
    100% { transform: rotate(360deg); }
  }
  @keyframes rotate-reverse {
    0% { transform: rotate(0); }
    100% { transform: rotate(-360deg); }
  }
  @keyframes move {
    0% { transform: translateY(0%) rotate(0) scale(1); }
    20% { transform: translateY(20%) rotate(10deg) scale(1.2); }
    80% { transform: translateY(-10%) rotate(-20deg) scale(.8);}
    100% { transform: translateY(0) rotate(0) scale(1); }
  }

  .progress {
    position: fixed;
    left: 0; top: 0;
    width: 0;
    height: 3px;
    background-color: green;
    transition: all cubic-bezier(0.215, 0.610, 0.355, 1) .1s;
    z-index: 9999;
  }

  .to-up {
    animation: toUp .5s 1;
  }
  .gray {
    position: fixed;
    left: 0;
    top: 0;
    width: 100%;
    height: 100vh;
    z-index: 9999;
    display: none;
    pointer-events: none;
    background-color: #000;
    mix-blend-mode: color;
  }
  @keyframes toUp {
    from { transform: translateY(15px); opacity: 0; }
    to { transform: translateY(0) ; opacity: 1; }
  }
</style>
<body>
  <div id="load" class="load">
    <div class="load-circle">
      <div class="load-circle-inner"></div>
    </div>
    <p class="load-text">
      <span>L</span>
      <span>O</span>
      <span>A</span>
      <span>D</span>
      <span>I</span>
      <span>N</span>
      <span>G</span>
    </p>
  </div>
  <div id="container" class="container w-100 vh-100" style="display: none;">
    <header class="header">
  <div class="header-wrapper">
    <div class="header-left">
      <div class="header-search">
        <input id="search-input" type="text" class="header-search--input" placeholder="请输入要检索的文章标题" />
        <span id="search-btn" class="header-search--icon"><i class="iconfont icon-sousuo"></i></span>
      </div>
      <div id="search-layer" class="header-search--layer hidden">
        <p class="title">
          <span>以下是搜索内容：</span>
          <span id="close-layer-btn">关闭</span>
        </p>
        <ul>
        </ul>
      </div>
    </div>
    <div class="header-right">
      <ul class="header-menu">
        <li>
          <a href="http://example.com/">
            <i class="header-menu--icon iconfont icon-shouye"></i>
            <span class="header-menu--span">首页</span>
          </a>
        </li>
        <li>
          <a href="http://example.com/log">
            <i class="header-menu--icon iconfont icon-rizhi"></i>
            <span class="header-menu--span">日志</span>
          </a>
        </li>
        <li>
          <a href="http://example.com/link">
            <i class="header-menu--icon iconfont icon-youqinglianjie"></i>
            <span class="header-menu--span">友情链接</span>
          </a>
        </li>
        <li>
          <a href="http://example.com/about">
            <i class="header-menu--icon iconfont icon-guanyuwomen"></i>
            <span class="header-menu--span">关于我</span>
          </a>
        </li>
      </ul>
    </div>
  </div>
</header>

<script>
  const ipt = document.querySelector('#search-input')
  const btn = document.querySelector('#search-btn')
  const layer = document.querySelector('#search-layer')
  const posts = JSON.parse(`[{"title":"docker命令","cover":"https://haowallpaper.com/link/common/file/getCroppingImg/71e27d1e01da8c13f3f165a1c3bcc8b571e27d1e01da8c13f3f165a1c3bcc8b5","path":"2024/03/21/Docker命令大全/"},{"title":"LV移除、缩容","cover":"https://haowallpaper.com/link/common/file/getCroppingImg/d733537fd3e06784932826b5e82a855d","path":"2023/06/14/LV逻辑卷扩展/"},{"title":"LVM逻辑卷管理","cover":"https://haowallpaper.com/link/common/file/getCroppingImg/d733537fd3e06784932826b5e82a855d","path":"2023/06/28/LVM逻辑卷管理 /"},{"title":"PXE+Kickstart无人值守安装操作系统","cover":"https://haowallpaper.com/link/common/file/getCroppingImg/82cb48f718f8acc8cb2568140eeaaec382cb48f718f8acc8cb2568140eeaaec3","path":"2023/06/26/PXE+Kickstart无人值守安装操作系统/"},{"title":"","path":"2024/09/01/PromQL 讲解/"},{"title":"python一","cover":"https://haowallpaper.com/link/common/file/getCroppingImg/15096963228077376","path":"2024/02/20/Python 1 /"},{"title":"python三","cover":"https://haowallpaper.com/link/common/file/getCroppingImg/15096963228077376","path":"2024/02/25/Python 3/"},{"title":"python四","cover":"https://haowallpaper.com/link/common/file/getCroppingImg/15096963228077376","path":"2024/03/01/Python 4/"},{"title":"python二","cover":"https://haowallpaper.com/link/common/file/getCroppingImg/15096963228077376","path":"2024/02/21/Python 2/"},{"title":"TCP协议","cover":"https://haowallpaper.com/link/common/file/getCroppingImg/15047394039467328","path":"2023/06/23/TCP协议/"},{"title":"ansible模块","cover":"https://haowallpaper.com/link/common/file/getCroppingImg/1e624a7ba7e09f195b3f2f384b2b9bb1","path":"2023/08/17/ansible 模块扩展/"},{"title":"docker容器","cover":"https://haowallpaper.com/link/common/file/getCroppingImg/71e27d1e01da8c13f3f165a1c3bcc8b571e27d1e01da8c13f3f165a1c3bcc8b5","path":"2024/03/11/docker容器/"},{"title":"FTP文件服务器","cover":"https://haowallpaper.com/link/common/file/getCroppingImg/a9045286aa9b50dcc09302eff83b328a","path":"2023/06/23/ftp/"},{"title":"","path":"2024/09/01/galera/"},{"title":"","path":"2024/09/01/nginx1/"},{"title":"","path":"2024/09/01/nginx2/"},{"title":"","path":"2024/09/01/nnginx5/"},{"title":"","path":"2024/09/01/prometheus 监控/"},{"title":"","path":"2024/09/01/redis集群/"},{"title":"","path":"2024/09/01/shell脚本/"},{"title":"","path":"2024/09/01/容器技术-Docker1/"},{"title":"","path":"2024/09/01/容器技术-docker2/"},{"title":"","path":"2024/09/01/容器技术-docker5/"},{"title":"","path":"2024/09/01/node_exporter/"},{"title":"shell编程","cover":"https://haowallpaper.com/link/common/file/getCroppingImg/9217d5c6d87ce0e8ec7422ca7469db95","path":"2023/07/21/shell_newrain/"},{"title":"","path":"2024/09/01/容器技术docker4/"},{"title":"用户文件权限","cover":"https://haowallpaper.com/link/common/file/getCroppingImg/3719037aa1a43c4806d84ac9bd3dbc34","path":"2023/06/01/文件权限/"},{"title":"单用户模式破解密码","cover":"https://haowallpaper.com/link/common/file/getCroppingImg/3f6ae566e1f093d2d9dbcc3df361fc4b3f6ae566e1f093d2d9dbcc3df361fc4b","path":"2023/07/01/破解密码/"},{"title":"磁盘阵列","cover":"https://haowallpaper.com/link/common/file/getCroppingImg/69d9906ff9bf88dbc02184ecb8504fc5","path":"2023/07/09/磁盘阵列RAID/"},{"title":"linux文件管理","cover":"https://haowallpaper.com/link/common/file/getCroppingImg/de0f7b079a80d192f90989d9c2c9622d","path":"2023/06/21/文件管理/"},{"title":"存储管理--1","cover":"https://haowallpaper.com/link/common/file/getCroppingImg/d733537fd3e06784932826b5e82a855d","path":"2023/06/25/磁盘存储管理1/"},{"title":"自建YUM源","cover":"https://haowallpaper.com/link/common/file/getCroppingImg/56260873f5720f373c20f43587eab0b8","path":"2023/06/21/自建yum源笔记/"},{"title":"","path":"2024/09/01/自定义监控/"},{"title":"Linux网卡","cover":"https://haowallpaper.com/link/common/file/getCroppingImg/346f59e468f2155074d1fb3164594702","path":"2023/06/11/网络管理基础/"},{"title":"","path":"2024/09/01/微服务概念/"},{"title":"走进网络世界","cover":"https://haowallpaper.com/link/common/file/getCroppingImg/583716b0cb306203c308cc0def55dd9e583716b0cb306203c308cc0def55dd9e","path":"2023/06/16/走进网络世界/"}]`)
  ipt.addEventListener('keyup', e => {
    if (e.key === 'Enter') {
      handleSearch()
    }
  })
  btn.addEventListener('click', () => {
    handleSearch()
  })

  document.querySelector('#close-layer-btn').addEventListener('click', () => {
    layer.classList.toggle('hidden')
  })

  function handleSearch() {
    if (ipt.value.trim() === '') {
      return
    }
    let html = ''
    const targetPosts = posts.filter(post => post.title.includes(ipt.value))
    targetPosts.forEach(post => {
      html += `
        <li>
          <div>
            <a href="/${post.path}">${post.title.replace(new RegExp(ipt.value), `<span>${ipt.value}</span>`)}</a>
          </div>
          <img src="${post.cover || '/imgs/default-cover.webp' }" />
        </li>
      `
    })
    if (html.trim () === '') {
      html += '<p class="empty">没有搜索到内容</p>'
    }
    layer.querySelector('ul').innerHTML = html
    layer.classList.remove('hidden')
  }
</script> 
    <section id="main" class="main">
      <div class="main-left-wrapper">
<div class="main-left">
  <div class="main-left--block">
    <div class="main-left--info">
      <img src="/imgs/avatar.jpg"" class="main-left--avatar" />
      <div class="main-left--intro">
        <p class="main-left--name">Mr.Long</p>
        <div class="main-left--tags">
          <span class="main-left--tag">唱跳rap篮球</span>
          <span class="main-left--tag">宅但不肥</span>
        </div>
      </div>
    </div>
  
    <div>
      <div class="main-left--motto">
        <p>“花有重开日，人无再少年”</p>
        <p>“一个简单普通的男孩”</p>
      </div>
      <div class="main-left--github">
        <span class="line"></span>
        <a target="_blank" rel="noopener" href="https://github.com/MyRong99/MyRong99.github.io"><i class="logo iconfont icon-github-fill"></i></a>
        <span class="line"></span>
      </div>
      <div class="main-left--statics">
        <a href="/categories">
          <div>
            <span>3</span>
            <span>分类</span>
          </div>
        </a>
        <a href="/tags">
          <div>
            <span>4</span>
            <span>标签</span>
          </div>
        </a>
        <a href="/archives">
          <div>
            <span>6 </span>
            <span>归档</span>
          </div>
        </a>
      </div>
    </div>
  </div>

  <div class="main-left--block">
    <ul class="main-left--menu">
      
        <li>
          <a href="/">
            <span class="header-menu--span">小站首页</span>
            <i class="header-menu--icon iconfont icon-shouye"></i>
          </a>
        </li>
      
        <li>
          <a href="/log">
            <span class="header-menu--span">个人日志</span>
            <i class="header-menu--icon iconfont icon-rizhi"></i>
          </a>
        </li>
      
        <li>
          <a href="/link">
            <span class="header-menu--span">友情链接</span>
            <i class="header-menu--icon iconfont icon-youqinglianjie"></i>
          </a>
        </li>
      
        <li>
          <a href="/about">
            <span class="header-menu--span">关于自己</span>
            <i class="header-menu--icon iconfont icon-guanyuwomen"></i>
          </a>
        </li>
      
        <li>
          <a href="/tools">
            <span class="header-menu--span">我的工具</span>
            <i class="header-menu--icon iconfont icon-gongju"></i>
          </a>
        </li>
      
    </ul>
  </div>

  <div class="main-left--block">
    <div class="main-left--site">
      <h5 class="main-left--title">
        <span>站点信息</span>
        <i class="iconfont icon-zhandian"></i>
      </h5>
      <p class="main-left--subtitle">
        <span>文章数目：</span>
        <span>36 篇</span>
      </p>
      <p class="main-left--subtitle">
        <span>最近动态：</span>
        <span>今天</span>
      </p>
      <p class="main-left--subtitle">
        <span>上线时间：</span>
        <span>439天</span>
      </p>
      <p class="main-left--subtitle">
        <span>当前版本：</span>
        <span>v1.0.2</span>
      </p>
    </div>
  </div>
</div></div>
      <div id="main-container" class="main-container">


  <link rel="stylesheet" href="/css/partial/article.css" />

<div class="article-container">
  <div class="article">
    <h1 class="article-title"></h1>
    <div class="article-info">
      <div class="article-info--item">
        <div class="article-info--info">
          
          <div class="article-info--categories">
            <span>分类：</span>
            
          </div>
          
          
          <div class="article-info--tags">
            <span>标签：</span>
            
          </div>
          
          <p class="article-info--date">日期：2024-09-01 17:36:01</p>
        </div>
        <img src="/imgs/default-cover.webp" alt="" class="article-cover">
      </div>
    </div>
    <article class="article-content markdown-body">
      <p>title: 微服务<br>cover: ‘<a target="_blank" rel="noopener" href="https://haowallpaper.com/link/common/file/getCroppingImg/3719037aa1a43c4806d84ac9bd3dbc34">https://haowallpaper.com/link/common/file/getCroppingImg/3719037aa1a43c4806d84ac9bd3dbc34</a>‘<br>author: CAO<br>tags:<br>    -<br>categories:<br>    -<br>date: 2024-07-26 20:34:37</p>
<h1 id="微服务"><a href="#微服务" class="headerlink" title="微服务"></a>微服务</h1><h1 id="01-微服务介绍"><a href="#01-微服务介绍" class="headerlink" title="01.微服务介绍"></a>01.微服务介绍</h1><h2 id="01-单体和微服务介绍"><a href="#01-单体和微服务介绍" class="headerlink" title="01.单体和微服务介绍"></a>01.单体和微服务介绍</h2><h3 id="1-1-单体服务架构"><a href="#1-1-单体服务架构" class="headerlink" title="1.1 单体服务架构"></a>1.1 单体服务架构</h3><p><img src="https://img.beyourself.org.cn/image-20211121103537418.9bc71e33.png#id=dhQMk&originHeight=424&originWidth=911&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p>
<h3 id="1-2-微服务架构介绍"><a href="#1-2-微服务架构介绍" class="headerlink" title="1.2 微服务架构介绍"></a>1.2 微服务架构介绍</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">通俗来说，微服务架构就是把一个大系统按业务功能分解成多个职责单一的小系统，并利用简单的方法使多个小系统相互协作，组合成一个大系统</span><br></pre></td></tr></table></figure>

<ul>
<li>微服务（Microservices）是一种架构风格，一个大型复杂软件应用由一个或多个微服务组成。</li>
<li>系统中的各个微服务可被独立部署，各个微服务之间是松耦合的。</li>
<li>每个微服务仅关注于完成一件任务并很好地完成该任务。</li>
<li>在所有情况下，每个任务代表着一个小的业务能力。</li>
</ul>
<p><img src="https://img.beyourself.org.cn/image-20211121103638208.2ea6a8f1.png#id=ttdo5&originHeight=413&originWidth=991&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p>
<h3 id="1-3-简单微服务访问缺陷"><a href="#1-3-简单微服务访问缺陷" class="headerlink" title="1.3 简单微服务访问缺陷"></a>1.3 简单微服务访问缺陷</h3><ul>
<li>比如要查询订单商品信息 <ul>
<li>第一：通过 <code>用户</code> 服务的ip和端口号访问到用户信息</li>
<li>第二：拿着用户返回的信息，去查询 <code>订单</code> 服务ip和端口号查询到订单</li>
<li>第三： 拿着订单的信息，去查询 <code>产品</code> 服务 ip:端口号 查询到最终商品的信息</li>
</ul>
</li>
<li>缺点： <ul>
<li><code>一旦某一个服务升级后，ip和端口号发生变化，所有调用服务都需要修改调用的ip和端口和重启服务</code></li>
</ul>
</li>
</ul>
<p><img src="https://img.beyourself.org.cn/image-20211121111827470.b2ed1867.png#id=K1CXU&originHeight=515&originWidth=625&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p>
<h3 id="1-4-域名解决方案"><a href="#1-4-域名解决方案" class="headerlink" title="1.4 域名解决方案"></a>1.4 域名解决方案</h3><p><img src="https://img.beyourself.org.cn/image-20211121181719600.1cee55c7.png#id=HgAEG&originHeight=531&originWidth=873&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p>
<ul>
<li>微服务访问之域名解析 <ul>
<li>这个时候每一个服务都需要一个nginx代理，到后面的真实服务集群中</li>
<li>这样会使得整个服务变得很复杂</li>
</ul>
</li>
</ul>
<p><img src="https://img.beyourself.org.cn/image-20211121181849711.dd860c1b.png#id=PyeYN&originHeight=354&originWidth=927&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p>
<h2 id="02-微服务架构"><a href="#02-微服务架构" class="headerlink" title="02.微服务架构"></a>02.微服务架构</h2><h3 id="2-1-微服务组件"><a href="#2-1-微服务组件" class="headerlink" title="2.1 微服务组件"></a>2.1 微服务组件</h3><ul>
<li>服务注册 <code>Eureka、consul、nacos</code> <ul>
<li>服务提供方将自己调用地址注册到服务注册中心，让服务调用方能够方便地找到自己。</li>
</ul>
</li>
<li>服务发现 <code>Config、consul、nacos</code> <ul>
<li>服务调用方从服务注册中心找到自己需要调用的服务的地址。</li>
</ul>
</li>
<li>负载均衡 <code>Ribbon</code> <ul>
<li>服务提供方一般以多实例的形式提供服务，负载均衡功能能够让服务调用方连接到合适的服务节点。</li>
<li>并且，节点选择的工作对服务调用方来说是透明的。</li>
</ul>
</li>
<li>服务网关 <code>ZUUL、gateway</code> <ul>
<li>服务网关是服务调用的唯一入口，可以在这个组件是实现用户鉴权、动态路由、灰度发布、A&#x2F;B 测试、负载限流等功能。</li>
</ul>
</li>
<li>配置中心 <code>Config、nacos、consul</code> <ul>
<li>将本地化的配置信息（properties, xml, yaml 等）注册到配置中心，实现程序包在开发、测试、生产环境的无差别性，方便程序包的迁移。</li>
</ul>
</li>
<li>API 管理 <ul>
<li>以方便的形式编写及更新 API 文档，并以方便的形式供调用者查看和测试。</li>
</ul>
</li>
<li>集成框架 <code>Spring-cloud、Double、Go-micro</code> <ul>
<li>微服务组件都以职责单一的程序包对外提供服务，</li>
<li>集成框架以配置的形式将所有微服务组件（特别是管理端组件）集成到统一的界面框架下</li>
<li>让用户能够在统一的界面中使用系统。</li>
</ul>
</li>
<li>分布式事务 <ul>
<li>对于重要的业务，需要通过分布式事务技术（TCC、高可用消息服务、最大努力通知）保证数据的一致性。</li>
</ul>
</li>
<li>调用链 <code>Skywalking、zipkin、Pinpoint、CAT</code> <ul>
<li>记录完成一个业务逻辑时调用到的微服务，并将这种串行或并行的调用关系展示出来。</li>
<li>在系统出错时，可以方便地找到出错点。</li>
</ul>
</li>
<li>支撑平台 <ul>
<li>系统微服务化后，系统变得更加碎片化，系统的部署、运维、监控等都比单体架构更加复杂，那么，就需要将大部分的工作自动化。</li>
<li>现在，可以通过 Docker 等工具来中和这些微服务架构带来的弊端。</li>
<li>例如持续集成、蓝绿发布、健康检查、性能健康等等。</li>
<li><code>可以这么说，如果没有合适的支撑平台或工具，就不要使用微服务架构</code>。</li>
</ul>
</li>
</ul>
<h3 id="2-2-微服务架构优点"><a href="#2-2-微服务架构优点" class="headerlink" title="2.2 微服务架构优点"></a>2.2 微服务架构优点</h3><ul>
<li><strong>降低系统复杂度</strong>：每个服务都比较简单，只关注于一个业务功能。</li>
<li><strong>松耦合</strong>：微服务架构方式是松耦合的，每个微服务可由不同团队独立开发，互不影响。</li>
<li>跨语言 <ul>
<li>只要符合服务 API 契约，开发人员可以自由选择开发技术。</li>
<li>这就意味着开发人员可以采用新技术编写或重构服务，由于服务相对较小，所以这并不会对整体应用造成太大影响。</li>
</ul>
</li>
<li>独立部署 <ul>
<li>微服务架构可以使每个微服务独立部署，开发人员无需协调对服务升级或更改的部署。</li>
<li>这些更改可以在测试通过后立即部署，所以微服务架构也使得 CI／CD 成为可能。</li>
</ul>
</li>
<li><strong>Docker 容器</strong>：和 Docker 容器结合的更好。</li>
<li><strong>DDD 领域驱动设计</strong>：和 DDD 的概念契合，结合开发会更好。</li>
</ul>
<h3 id="2-3-微服务架构的缺点"><a href="#2-3-微服务架构的缺点" class="headerlink" title="2.3 微服务架构的缺点"></a>2.3 微服务架构的缺点</h3><ul>
<li>微服务的分布式特点带来的复杂性 <ul>
<li>开发人员需要基于 RPC 或者消息实现微服务之间的调用和通信</li>
<li>而这就使得服务之间的发现、服务调用链的跟踪和质量问题变得的相当棘手</li>
</ul>
</li>
<li>分区的数据库体系和分布式事务 <ul>
<li>更新多个业务实体的业务交易相当普遍，不同服务可能拥有不同的数据库。</li>
<li>CAP 原理的约束，使得我们不得不放弃传统的强一致性，而转而追求最终一致性，这个对开发人员来说是一个挑战。</li>
</ul>
</li>
<li>测试挑战 <ul>
<li>传统的单体WEB应用只需测试单一的 REST API 即可，而对微服务进行测试，需要启动它依赖的所有其他服务。</li>
<li>这种复杂性不可低估。</li>
</ul>
</li>
<li>跨多个服务的更改 <ul>
<li>比如在传统单体应用中，若有 A、B、C 三个服务需要更改，A 依赖 B，B 依赖 C。</li>
<li>我们只需更改相应的模块，然后一次性部署即可。</li>
<li>但是在微服务架构中，我们需要仔细规划和协调每个服务的变更部署。</li>
<li>我们需要先更新 C，然后更新 B，最后更新 A。</li>
</ul>
</li>
<li>部署复杂 <ul>
<li>微服务由不同的大量服务构成，每种服务可能拥有自己的配置、应用实例数量以及基础服务地址。</li>
<li>这里就需要不同的配置、部署、扩展和监控组件。</li>
<li>此外，我们还需要服务发现机制，以便服务可以发现与其通信的其他服务的地址。</li>
<li>因此，成功部署微服务应用需要开发人员有更好地部署策略和高度自动化的水平。</li>
</ul>
</li>
<li>总的来说（问题和挑战） <ul>
<li>API Gateway、服务间调用、服务发现、服务容错、服务部署、数据调用。</li>
</ul>
</li>
</ul>
<h2 id="03-微服务实现流程"><a href="#03-微服务实现流程" class="headerlink" title="03.微服务实现流程"></a>03.微服务实现流程</h2><h3 id="3-1-微服务实现流程"><a href="#3-1-微服务实现流程" class="headerlink" title="3.1 微服务实现流程"></a>3.1 微服务实现流程</h3><p>1、服务都注册到服务注册中心</p>
<ul>
<li>要构建微服务体系，首先我们需要独立部署一款实现服务注册&#x2F;发现功能的组件服务，目前可供选择的主流方案一般有Eureka、Consul、Nacos等</li>
<li>搞定服务注册&#x2F;发现后，我们编写一个Java微服务，此时为了将该服务注册到服务注册中心</li>
<li>一般会引入Spring Cloud提供的支持对应注册中心接入的SDK，并在应用入口类中通过@EnableDiscoveryClient注解的方式标注</li>
<li>之后SDK中的逻辑就会在应用启动时执行服务注册动作，并提供给注册中心相应地探测接口，以此实现微服务与服务注册中心之间的连接。</li>
<li>以此类推，我们可以通过这种方式将一组微服务都注册到服务注册中心！</li>
</ul>
<p>2、服务之间要互相调用</p>
<ul>
<li>一般我们会通过编写FeignClient接口来实现微服务之间的调用</li>
<li>而其底层的逻辑则是通过Feign所集成的Ribbon组件去注册中心中获取目标服务的服务地址列表</li>
<li>之后Ribbon根据服务地址列表进行负载均衡调用。</li>
<li>至于服务与注册中心之间如何保证连接有效性，则依赖于服务注册中心与其SDK之间的协作机制。</li>
</ul>
<p>3、负载均衡、熔断、限流、网关</p>
<ul>
<li>而高级一点，服务之间的调用除了实现负载均衡，还要实现熔断限流</li>
<li>那么此时可以通过部署服务网关组件（例如Zuul&#x2F;Spring Cloud GateWay）来实现微服务入口的熔断限流</li>
<li>内部服务之间的限流熔断则通过集成Hystrix或Sentinel组件，以客户端本地配置或远程配置中心的方式来实现。</li>
</ul>
<h3 id="3-2-微服务遇到的问题"><a href="#3-2-微服务遇到的问题" class="headerlink" title="3.2 微服务遇到的问题"></a>3.2 微服务遇到的问题</h3><p><code>**1、框架/SDK太多，后续升级维护困难**</code></p>
<ul>
<li>在这套体系中，与服务治理相关的逻辑都是以SDK代码依赖的方式嵌入在微服务之中</li>
<li>如果某天我们想升级下服务注册中心的SDK版本，或者熔断限流组件Hystrix或Sentinel的版本，那么需要升级改造的微服务可能会是成百上千</li>
<li>且由于这些组件都与业务应用绑定在一起，在升级的过程中会不会影响业务稳定，这都是需要谨慎对待的事情，所以对SDK的升级难度可想而知的！</li>
</ul>
<p><code>**2、多语言微服务SDK维护成本高**</code></p>
<ul>
<li>试想下如果构建的微服务体系，也要支持像Go、Python或者其他语言编写的微服务的话</li>
<li>那么上述这些微服务治理相关的SDK是不是得单独再维护几套呢？</li>
<li>所以在这种体系结构中，对多语言微服务的支持就成了一个问题！</li>
</ul>
<p><code>**3、服务治理策略难以统一控制**</code></p>
<ul>
<li>基于该套体系构建的微服务体系，在对像熔断、限流、负载均衡等服务治理相关的策略管理上，都是比较分散的</li>
<li>可能有人会写到自己的本地配置文件，有人会硬编码到代码逻辑中，也可能有人会将其配置到远程配置中心</li>
<li>总之对于服务治理策略逻辑都是由对应的开发人员自己控制，这样就很难形成统一的控制体系！</li>
</ul>
<p><code>**4、服务治理逻辑嵌入业务应用，占有业务服务资源**</code></p>
<ul>
<li>在这套微服务体系中，服务治理相关的逻辑都是在微服务应用进程中寄生运行的</li>
<li>这多少会占有宝贵的业务服务器资源，影响应用性能的发挥！</li>
</ul>
<p><code>**5、额外的服务治理组件的维护成本**</code></p>
<ul>
<li>无论是服务注册中心、还是服务网关，这些除了微服务应用本身之外服务治理组件，都需要我们以中间件基础服务的方式进行维护</li>
<li>需要额外的人力、额外的服务器成本</li>
</ul>
<h2 id="04-各语言微服务框架"><a href="#04-各语言微服务框架" class="headerlink" title="04.各语言微服务框架"></a>04.各语言微服务框架</h2><h3 id="4-1-Java"><a href="#4-1-Java" class="headerlink" title="4.1 Java"></a>4.1 Java</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Spring Boot</span><br></pre></td></tr></table></figure>

<ul>
<li>Spring Boot的设计目的是简化新Spring应用初始搭建以及开发过程，2017年有64.4%的受访者决定使用Spring Boot，可以说是最受欢迎的微服务开发框架。</li>
<li>利用Spring Boot开发的便捷度简化分布式系统基础设施的开发，比如像配置中心、注册、负载均衡等方面都可以做到一键启动和一键部署。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Spring Cloud</span><br></pre></td></tr></table></figure>

<ul>
<li>Spring Cloud是一个系列框架的合计，基于HTTP（s）的RETS服务构建服务体系，Spring Cloud能够帮助架构师构建一整套完整的微服务架构技术生态链。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Dubbo</span><br></pre></td></tr></table></figure>

<ul>
<li>Dubbo是由阿里巴巴开源的分布式服务化治理框架，通过RPC请求方式访问。</li>
<li>Dubbo是在阿里巴巴的电商平台中逐渐探索演进所形成的，经历过复杂业务的高并发挑战，比Spring Cloud的开源时间还要早。</li>
<li>目前阿里、京东、当当、携程、去哪等一些企业都在使用Dubbo。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Dropwizard</span><br></pre></td></tr></table></figure>

<ul>
<li>Dropwizard将Java生态系统中各个问题域里最好的组建集成于一身，能够快速打造一个Rest风格的后台，还可以整合Dropwizard核心以外的项目。</li>
<li>国内现在使用Dropwizard还很少，资源也不多，但是与Spring Boot相比，Dropwizard在轻量化上更有优势，同时如果用过Spring，那么基本也会使用Spring Boot。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">框架对比</span><br></pre></td></tr></table></figure>

<ul>
<li><p><strong>从公司整体规划：</strong> 不会选择很久没人维护的 dubbo，重启之后也未必是原班人马</p>
</li>
<li><p><strong>从程序员招聘难度</strong> ：招 springcloud 的程序员会更好招，因为更新更炫</p>
</li>
<li><p><strong>从系统结构简易程序：</strong> </p>
<ul>
<li>springcloud 的系统结构更简单、“注册 + springmvc&#x3D;springcloud”</li>
</ul>
</li>
<li><p><strong>从性能：</strong> </p>
<ul>
<li>dubbo 的网络消耗小于 springcloud，但是在国内 95% 的公司内，网络消耗不是什么太大问题</li>
<li>如果真的成了问题，通过压缩、二进制、高速缓存、分段降级等方法，很容易解</li>
</ul>
</li>
<li><p><strong>从开发难易度：</strong> </p>
<ul>
<li>dubbo 的神坑是 jar 包依赖，开发阶段难度极大</li>
</ul>
</li>
</ul>
<h3 id="4-2-Go"><a href="#4-2-Go" class="headerlink" title="4.2 Go"></a>4.2 Go</h3><ul>
<li><code>Go-Kit</code>是分布式开发的工具合集，适合用于大型业务场景下构建微服务；</li>
<li><code>Goa</code>是用Go语言构建的微服务框架；</li>
<li><code>Dubbogo</code>是和阿里巴巴开源的Dubbo能够兼容的Golang微服务框架。</li>
</ul>
<h3 id="4-3-Python"><a href="#4-3-Python" class="headerlink" title="4.3 Python"></a>4.3 Python</h3><ul>
<li>Python相关的微服务框架非常少，用的比较多的是<code>Nameko</code>。</li>
<li>Nameko让实现微服务变得更简单，同时也提供了很丰富的功能，比如支持负载均衡、服务发现还支持依赖自动注入等</li>
<li>使用起来很方便，但是有限速、超时和权限机制不完善等缺点。</li>
</ul>
<h1 id="02-Eureka注册中心"><a href="#02-Eureka注册中心" class="headerlink" title="02.Eureka注册中心"></a>02.Eureka注册中心</h1><h2 id="01-注册中心原理"><a href="#01-注册中心原理" class="headerlink" title="01.注册中心原理"></a>01.注册中心原理</h2><h3 id="1-1-为什么需要注册中心"><a href="#1-1-为什么需要注册中心" class="headerlink" title="1.1 为什么需要注册中心"></a>1.1 为什么需要注册中心</h3><ul>
<li>在RPC服务和微服务诞生的时候，就已经有了注册中心的需求了。</li>
<li>在最初的架构体系中，集群的概念还不那么流行，且机器数量也比较少</li>
<li><code>此时直接使用DNS+Nginx</code>就可以满足几乎所有RESTful服务的发现，<code>相关的注册信息直接配置在Nginx</code>。</li>
<li>但是随着微服务的流行与流量的激增，机器规模逐渐变大，并且机器会有频繁的上下线行为</li>
<li>这种时候需要<code>运维手动地去维护这个配置信息</code>是一个很麻烦的操作。</li>
<li>所以开发者们开始希望有这么一个东西，它能维护一个服务列表，哪个机器上线了，哪个机器宕机了</li>
<li>这些信息都会<code>自动更新到服务列表上</code>，客户端拿到这个列表，直接进行服务调用即，这个就是注册中心</li>
</ul>
<h3 id="1-2-注册中心原理"><a href="#1-2-注册中心原理" class="headerlink" title="1.2 注册中心原理"></a>1.2 注册中心原理</h3><ul>
<li>注册中心主要涉及到三大角色 <ul>
<li>服务提供者</li>
<li>服务消费者</li>
<li>注册中心</li>
</ul>
</li>
<li>它们之间的关系大致如下 <ul>
<li>各个微服务在启动时，将自己的网络地址等信息注册到注册中心，注册中心存储这些数据。</li>
<li>服务消费者从注册中心查询服务提供者的地址，并通过该地址调用服务提供者的接口。</li>
<li>各个微服务与注册中心使用一定机制（例如心跳）通信。如果注册中心与某微服务长时间无法通信，就会注销该实例。</li>
<li>微服务网络地址发送变化（例如实例增加或IP变动等）时，会重新注册到注册中心。</li>
<li>这样，服务消费者就无需人工修改提供者的网络地址了。</li>
</ul>
</li>
<li>注册中心的架构图如下</li>
</ul>
<p><img src="https://img.beyourself.org.cn/image-20211122091206507.2f75b0a0.png#id=QZCQj&originHeight=770&originWidth=1174&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p>
<h3 id="1-3-注册中心功能"><a href="#1-3-注册中心功能" class="headerlink" title="1.3 注册中心功能"></a>1.3 注册中心功能</h3><ul>
<li><code>1）服务注册表</code> <ul>
<li>服务注册表是注册中心的核心，它用来记录各个微服务的信息，例如微服务的名称、IP、端口等。</li>
<li>服务注册表提供查询API和管理API，查询API用于查询可用的微服务实例，管理API用于服务的注册与注销</li>
</ul>
</li>
<li><code>2）服务注册与发现</code> <ul>
<li>服务注册是指微服务在启动时，将自己的信息注册到注册中心的过程。</li>
<li>服务发现是指查询可用的微服务列表及网络地址的机制。</li>
</ul>
</li>
<li><code>3）服务检查</code> <ul>
<li>注册中心使用一定的机制定时检测已注册的服务，如发现某实例长时间无法访问，就会从服务注册表移除该实例。</li>
</ul>
</li>
</ul>
<h2 id="02-Eureka注册中心-1"><a href="#02-Eureka注册中心-1" class="headerlink" title="02.Eureka注册中心"></a>02.Eureka注册中心</h2><h3 id="2-1-Eureka图解"><a href="#2-1-Eureka图解" class="headerlink" title="2.1 Eureka图解"></a>2.1 Eureka图解</h3><ul>
<li>第一：服务注册 <ul>
<li>user和product两个微服务，在启动时将自己的 名称、IP、端口等注册到 Eureka服务端</li>
</ul>
</li>
<li>第二：服务发现 <ul>
<li>user微服务要访问产品微服务，会请求Eureka服务端，Eureka返回 user微服务注册的 ip:端口 列表</li>
<li>user微服务根据负载均衡策略选择其中一个 ip:端口 来访问 product产品微服务</li>
</ul>
</li>
<li>第三：服务检查 <ul>
<li><strong>在应用启动后</strong>，将会向Eureka Server发送心跳,<strong>默认周期为30秒</strong></li>
<li>如果Eureka Server在多个心跳周期内没有接收到某个节点的心跳，Eureka Server将会从服务注册表中把这个<strong>服务节点移除(默认90秒)</strong></li>
</ul>
</li>
</ul>
<p><img src="https://img.beyourself.org.cn/image-20211122090509488.35bdd882.png#id=uQctx&originHeight=690&originWidth=1520&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p>
<h3 id="2-2-Eureka介绍"><a href="#2-2-Eureka介绍" class="headerlink" title="2.2 Eureka介绍"></a>2.2 Eureka介绍</h3><ul>
<li>Eureka是Netflix开发的服务发现框架，本身是一个基于REST的服务，主要用于定位运行在AWS域中的中间层服务，以达到负载均衡和中间层服务故障转移的目的。</li>
<li>SpringCloud将它集成在其子项目spring-cloud-netflix中，以实现SpringCloud的服务发现功能。</li>
<li>Eureka重要概念 <ul>
<li>Register(服务注册)：把自己的IP和端口注册给Eureka。</li>
<li>Renew(服务续约)：发送心跳包，每30秒发送一次。告诉Eureka自己还活着。</li>
<li>Cancel(服务下线)：当provider关闭时会向Eureka发送消息，把自己从服务列表中删除。防止consumer调用到不存在的服务。</li>
<li>Get Registry(获取服务注册列表)：获取其他服务列表。</li>
<li>Replicate(集群中数据同步)：eureka集群中的数据复制与同步。</li>
<li>Make Remote Call(远程调用)：完成服务的远程调用。</li>
</ul>
</li>
</ul>
<h3 id="2-3-Eureka组件功能"><a href="#2-3-Eureka组件功能" class="headerlink" title="2.3 Eureka组件功能"></a>2.3 Eureka组件功能</h3><ul>
<li>Eureka包含两个组件：Eureka Server和Eureka Client。</li>
<li>Eureka Server <ul>
<li>Eureka Server提供服务注册服务，各个节点启动后，会在Eureka Server中进行注册</li>
<li>这样Eureka Server中的服务注册表中将会存储所有可用服务节点的信息，服务节点的信息可以在界面中直观的看到。</li>
</ul>
</li>
<li>Eureka Client <ul>
<li>Eureka Client是一个java客户端，用于简化与Eureka Server的交互</li>
<li>客户端同时也具备一个内置的、使用轮询(round-robin)负载算法的负载均衡器。</li>
<li><strong>在应用启动后</strong>，将会向Eureka Server发送心跳,<strong>默认周期为30秒</strong>，如果Eureka Server在多个心跳周期内没有接收到某个节点的心跳</li>
<li>Eureka Server将会从服务注册表中把这个**服务节点移除(默认90秒)**。</li>
</ul>
</li>
</ul>
<h2 id="03-常用注册中心比较"><a href="#03-常用注册中心比较" class="headerlink" title="03.常用注册中心比较"></a>03.常用注册中心比较</h2><h3 id="3-0-CAP理论"><a href="#3-0-CAP理论" class="headerlink" title="3.0 CAP理论"></a><img src="https://img.beyourself.org.cn/image-20211129100659497.8c8aa4c9.png#id=Fuslg&originHeight=1074&originWidth=1940&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=">3.0 CAP理论</h3><p><code>C（Consistency）</code>这里指的是强一致性</p>
<ul>
<li><code>保证在一定时间内，集群中的各个节点会达到较强的一致性</code>，同时，为了达到这一点，一般会牺牲一点响应时间。</li>
<li>而放弃C也不意味着放弃一致性，而是放弃强一致性，允许系统内有一定的数据不一致情况的存在</li>
</ul>
<p><code>A (Avalibility)：可用性</code></p>
<ul>
<li>意味着系统一直处于可用状态，个别节点的故障不会影响整个服务的运作</li>
</ul>
<p><code>P（Partition Tolerance)：分区容忍性</code></p>
<ul>
<li>当系统出现网络分区等情况时，依然能对外提供服务。</li>
<li>想到达到这一点，一般来说会把数据复制到多个分区里，来提高分区容忍性。这个一般是不会被抛弃的</li>
</ul>
<h3 id="3-1-Zookeeper"><a href="#3-1-Zookeeper" class="headerlink" title="3.1 Zookeeper"></a>3.1 Zookeeper</h3><ul>
<li>特点： <ul>
<li>1）牺牲可用性，保证一致性</li>
<li>2）主从模式，无配置管理</li>
</ul>
</li>
<li>Apache Zookeeper所选择的是<strong>CP</strong>，也就是放弃了高可用性。</li>
<li>为了达到C，Zookeeper采用的是自己的ZAB协议。</li>
<li>总得来说，Zookeeper集群在进行消息同步的时候，必须有一半以上结点完成了同步才会返回；</li>
<li>而当Master结点挂了或者集群中有过半的结点不能工作了，此时就会触发故障恢复，重新进行Master选举。</li>
<li><code>在这个过程中，整个Zookeeper集群无法对外提供服务，从而失去了A（可用性）</code></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">牺牲服务可用性、保证数据一致性</span><br></pre></td></tr></table></figure>

<ul>
<li>对于大多数的分布式环境来说，特别是数据储存的环境，数据一致性是非常重要的标准。</li>
<li>但对于服务发现来说，其实并没有那么严格。</li>
<li>就算一个注册中心没有及时获取到实时的服务实例状态，直接把服务列表（可能存在错误）发给客户端，也不会导致灾难性的错误。</li>
<li>因为对于客户端来说会有重试机制，少数的实例无法访问不会导致大问题。</li>
</ul>
<h3 id="3-2-Eureka"><a href="#3-2-Eureka" class="headerlink" title="3.2 Eureka"></a>3.2 Eureka</h3><ul>
<li>特点： <ul>
<li>1）牺牲一致性，保证可用性</li>
<li>2）无主从模式，无配置管理</li>
</ul>
</li>
<li>Spring Cloud Eureka所选择的是<strong>AP</strong>，放弃了强一致性。</li>
<li>从使用角度来看，Eureka的特点就是使用Java语言来开发的，并且也是Spring Cloud的子项目</li>
<li>所以可以直接通过引入jar包的方式来集成Eureka，这点非常方便</li>
<li>而在架构上，Eureka集群采用的是去中心化结构，也就是说Eureka集群中的各个结点都是平等的，<code>没有主从的概念</code>。</li>
<li>通过互相注册的方式来进行消息同步和保证高可用。</li>
<li>并且一个Eureka Server结点挂掉了，还有其他同等的结点来提供服务，并不会引发服务的中断。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">保证可用性，牺牲强一致性</span><br></pre></td></tr></table></figure>

<ul>
<li>但同样的也会带来一定的不一致性。但是之前也说了，在服务注册这种场景，一致性的要求其实并没有很高</li>
<li>另外，Eureka还有一个自我保护机制，用来应对网络问题导致的服务不可用，从而能更进一步地保证可用性。</li>
</ul>
<h3 id="3-3-Consul"><a href="#3-3-Consul" class="headerlink" title="3.3 Consul"></a>3.3 Consul</h3><ul>
<li>特点： <ul>
<li>1）牺牲可用性，保证一致性</li>
<li>2）主从模式，有配置管理</li>
</ul>
</li>
<li>Consul是HashiCorp公司推出的一个开源工具。</li>
<li>它和Eureka一个区别就似乎，<code>Consul是用Go语言编写的，所以无法像Eureka那样直接引入jar包就能集成</code>，它还需要去服务器中进行额外的安装。</li>
<li>Consul的功能相比于Eureka来说也更加强大，因为除了注册中心的功能之外，<code>Consul还能起到配置中心的作用</code>。</li>
<li>而Eureka只能当注册中心，想搞配置中心的话，还得搭配Spring Cloud Config+Spring Cloud Bus。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">牺牲服务可用性、保证数据一致性</span><br></pre></td></tr></table></figure>

<ul>
<li>Consul它保证的是<strong>CP</strong>，使用raft协议，要求必须有过半的结点都写入成功才算是注册成功了</li>
<li>并且它也有Master和Follower的概念，在Master挂掉后，也需要自己内部进行新一轮Master选举，在此期间，Consul服务不可用</li>
</ul>
<h3 id="3-4-Nacos"><a href="#3-4-Nacos" class="headerlink" title="3.4 Nacos"></a>3.4 Nacos</h3><ul>
<li>特点： <ul>
<li>1）强一致性和强可用性，可以自己选择</li>
<li>2）无主从模式，有配置中心</li>
</ul>
</li>
<li>Nacos是阿里巴巴旗下的开源项目，在2018年开源，是Spring Cloud Alibaba的子项目。</li>
<li>Nacos一大特性是即支持CP，也支持AP，可以根据需要灵活选择。</li>
<li>Nacos除了注册中心之外，也能充当配置中心的作用。</li>
<li>且配置中心可以按照namespace，group等维度来进行数据隔离，来达到不同环境之间配置隔离的功能。</li>
<li>另外值得一提的是，Nacos作为配置中心的持久化机制可以依赖于Mysql来完成（默认依赖于内置数据库）。</li>
<li>只需要将Nacos目录下的sql脚本放到mysql中执行（会生成11个表），然后在nacos配置文件里面配一下mysql的账号密码即可。</li>
<li>这样使用mysql作为数据源的方式相比于nacos内置数据库来说更容易管理</li>
</ul>
<h1 id="03-Ribbon负载均衡"><a href="#03-Ribbon负载均衡" class="headerlink" title="03.Ribbon负载均衡"></a>03.Ribbon负载均衡</h1><h2 id="01-负载均衡介绍"><a href="#01-负载均衡介绍" class="headerlink" title="01.负载均衡介绍"></a>01.负载均衡介绍</h2><h3 id="1-1-服务端负载均衡"><a href="#1-1-服务端负载均衡" class="headerlink" title="1.1 服务端负载均衡"></a>1.1 服务端负载均衡</h3><ul>
<li><code>客户端发送请求被服务端负载均衡拦截，根据负载均衡算法分发请求到具体服务器上处理请求</code></li>
</ul>
<p><img src="https://img.beyourself.org.cn/image-20211122094839603.91998d1e.png#id=llBPw&originHeight=798&originWidth=1454&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p>
<h3 id="1-2-Ribbon客户端负载均衡"><a href="#1-2-Ribbon客户端负载均衡" class="headerlink" title="1.2 Ribbon客户端负载均衡"></a>1.2 Ribbon客户端负载均衡</h3><ul>
<li>第一：通过微服务域名从注册中获取要访问的服务列表</li>
<li>第二：使用负载均算法，从服务列表中获取到合适的 ip服务</li>
</ul>
<p><img src="https://img.beyourself.org.cn/image-20211122095314206.75d77edf.png#id=HMnn3&originHeight=1120&originWidth=1752&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p>
<h2 id="02-Ribbon介绍"><a href="#02-Ribbon介绍" class="headerlink" title="02.Ribbon介绍"></a>02.Ribbon介绍</h2><ul>
<li>Ribbon是Spring Cloud核心组件之一，它提供的最重要的功能就是负载均衡，和硬件负载均衡F5不同，它的负载均衡是基于客户端的</li>
<li>Zuul网关和Feign可以通过Ribbon轻松的实现服务的负载均衡，同时避免了与业务无关的冗余代码。</li>
</ul>
<h3 id="2-1-LoadBalanced原理"><a href="#2-1-LoadBalanced原理" class="headerlink" title="2.1 @LoadBalanced原理"></a>2.1 @LoadBalanced原理</h3><ul>
<li>在Ribbon示例中可以看到，Ribbon通过一个@LoadBalanced注解就实现了RestTemplate请求的负载均衡</li>
<li>RestTemplate在发送请求的时候会被ClientHttpRequestInterceptor拦截，LoadBalancerInterceptor是ClientHttpRequestInterceptor的实现类</li>
<li>它的作用就是用于RestTemplate的负载均衡，LoadBalancerInterceptor将负载均衡的核心逻辑交给了loadBalancer</li>
</ul>
<h3 id="2-2-获取服务实例列表"><a href="#2-2-获取服务实例列表" class="headerlink" title="2.2 获取服务实例列表"></a>2.2 获取服务实例列表</h3><ul>
<li>Ribbon使用ServerList接口抽象服务实例列表，Ribbon获取服务实例有如下两种方法，可以使用参数{service-name}.ribbon.NIWSServerListClassName进行选择。</li>
<li>Ribbon通过ConfigurationBasedServerList类实现配置服务列表,多个服务实例用逗号隔开</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">spring.application.name=shop-order</span><br><span class="line">shop-product.ribbon.listOfServers=http:<span class="comment">//localhost:8001,http://localhost:8002</span></span><br></pre></td></tr></table></figure>

<ul>
<li>利用注册中心获取 <ul>
<li>利用配置文件获取服务实例列表扩展性很差，因为在服务实例上线或者下线的情况下，需要手动修改配置文件，扩展性很低</li>
<li>一个健壮的微服务系统会采用注册中心的方式维护服务的上下线。</li>
<li>Ribbon可以使用DiscoveryEnabledNIWSServerList维护和Eureka之间的服务上下线</li>
</ul>
</li>
</ul>
<h3 id="2-3-动态更新服务实例列表"><a href="#2-3-动态更新服务实例列表" class="headerlink" title="2.3 动态更新服务实例列表"></a>2.3 动态更新服务实例列表</h3><ul>
<li>服务实例上下线在微服务系统中是一个非常常见的场景，Ribbon也实现了该功能，Ribbon定时更新的接口抽象为ServerListUpdater。</li>
<li>当Ribbon从注册中心获取了服务实例列表之后，Ribbon需要动态更新服务实例列表，抽象接口为ServerListUpdater</li>
<li>更新的方式有两种，一种是通过定时任务定时拉取服务实例列表，另一种是通过Eureka服务事件通知的方式。</li>
<li>Ribbon可以通过配置项{service-name}.ribbon.ServerListUpdaterClassName进行选择更新方</li>
<li><code>方法1：定时拉取</code> <ul>
<li>Ribbon会使用一个定时任务线程池定时拉取更新数据。</li>
</ul>
</li>
<li><code>方法2：事件通知</code> <ul>
<li>和PollingServerListUpdater不同的是，如果注册中心是Eureka，可以采用事件通知的方式</li>
<li>即当Eureka注册中心发生注册信息变更的时候，那么就将消息发送到事件监听者</li>
<li>Ribbon使用EurekaNotificationServerListUpdater实现类进行更新，首先会创建一个Eureka监听器</li>
<li>当接口接受到通知事件之后，会将更新逻辑提交到线程池中执行</li>
</ul>
</li>
</ul>
<h3 id="2-4-对服务进行心跳检测"><a href="#2-4-对服务进行心跳检测" class="headerlink" title="2.4 对服务进行心跳检测"></a>2.4 对服务进行心跳检测</h3><ul>
<li>服务列表中的服务实例未必一直都处于可用的状态，Ribbon会对服务实例进行检测</li>
<li>PingerStrategy接口抽象检测的策略，Ribbon默认采用了串行的方式进行检测，如果有必要，我们可以通过该接口实现并行的检测方式。</li>
<li>Pinger会定时通过PingerStrategy获取更新的服务实例，并调用监听者。</li>
</ul>
<h3 id="2-5-负载均衡调度器"><a href="#2-5-负载均衡调度器" class="headerlink" title="2.5 负载均衡调度器"></a>2.5 负载均衡调度器</h3><ul>
<li>从ServerListFilter获取到一个微服务实例集合后，ILoadBalancer需要使用某个策略从集合中选择一个服务实例， 而策略的抽象接口为IRule</li>
<li>选择服务实例之后，ILoadBalancer在调用过程中，会记录请求的执行结果，比如请求的失败成功情况，调用耗时等，IRule接口也可以根据这些信息决定是否使用某个Server。<table>
<thead>
<tr>
<th>名称</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td>RoundRobinRule</td>
<td>轮训策略</td>
</tr>
<tr>
<td>RandomRule</td>
<td>随机策略</td>
</tr>
<tr>
<td>BestAvailableRule</td>
<td>过滤出故障服务器后，选择一个并发量最小的</td>
</tr>
<tr>
<td>WeightedResponseTimeRule</td>
<td>针对响应时间加权轮询</td>
</tr>
<tr>
<td>AvailabilityFilteringRule</td>
<td>可用过滤策略，先过滤出故障的或并发请求大于阈值的一部分服务实例，然后再以线性轮询的方式从过滤后的实例清单中选出一个;</td>
</tr>
<tr>
<td>ZoneAvoidanceRule</td>
<td>从最佳区域实例集合中选择一个最优性能的服务实例</td>
</tr>
<tr>
<td>RetryRule</td>
<td>选择一个Server，如果失败，重新选择一个Server重试</td>
</tr>
</tbody></table>
</li>
</ul>
<h1 id="04-Hystrix熔断"><a href="#04-Hystrix熔断" class="headerlink" title="04.Hystrix熔断"></a>04.Hystrix熔断</h1><h2 id="01-背景介绍"><a href="#01-背景介绍" class="headerlink" title="01.背景介绍"></a>01.背景介绍</h2><h3 id="1-1-服务雪崩"><a href="#1-1-服务雪崩" class="headerlink" title="1.1 服务雪崩"></a>1.1 服务雪崩</h3><ul>
<li>分布式系统环境下，服务间类似依赖非常常见，一个业务调用通常依赖多个基础服务</li>
</ul>
<p><img src="https://img.beyourself.org.cn/image-20211123091649019.eddd02de.png#id=ZuKVc&originHeight=182&originWidth=800&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p>
<ul>
<li>但是如果其中一个服务崩坏掉会出现什么样的情况呢？如下图</li>
</ul>
<p><img src="https://img.beyourself.org.cn/image-20211123091756201.e301137e.png#id=M91Fl&originHeight=520&originWidth=1012&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">So，简单地讲，一个服务失败，导致整条链路的服务都失败的情形，我们称之为服务雪崩。</span><br></pre></td></tr></table></figure>

<ul>
<li>当Service A的流量波动很大，流量经常会突然性增加！那么在这种情况下，就算Service A能扛得住请求，Service B和Service C未必能扛得住这突发的请求。</li>
<li>此时，如果Service C因为抗不住请求，变得不可用。</li>
<li>那么Service B的请求也会阻塞，慢慢耗尽Service B的线程资源，Service B就会变得不可用。</li>
<li>紧接着，Service A也会不可用。</li>
</ul>
<h3 id="1-2-引起雪崩的原因"><a href="#1-2-引起雪崩的原因" class="headerlink" title="1.2 引起雪崩的原因"></a>1.2 引起雪崩的原因</h3><ul>
<li><strong>原因</strong>大致有四 <ul>
<li>1、硬件故障；</li>
<li>2、程序Bug；</li>
<li>3、缓存击穿（用户大量访问缓存中没有的键值，导致大量请求查询数据库，使数据库压力过大）；</li>
<li>4、用户大量请求；</li>
</ul>
</li>
<li>服务雪崩的三个阶段 <ul>
<li><strong>第一阶段</strong>: 服务不可用；</li>
<li><strong>第二阶段</strong>：调用端重试加大流量（用户重试&#x2F;代码逻辑重试）；</li>
<li><strong>第三阶段</strong>：服务调用者不可用（同步等待造成的资源耗尽）；</li>
</ul>
</li>
</ul>
<h3 id="1-3-解决雪崩的方案"><a href="#1-3-解决雪崩的方案" class="headerlink" title="1.3 解决雪崩的方案"></a>1.3 解决雪崩的方案</h3><ul>
<li>1） 应用扩容（扩大服务器承受力） <ul>
<li>加机器</li>
<li>升级硬件</li>
</ul>
</li>
<li>2）流量控制<br>（超出限定流量，返回类似重试页面让用户稍后再试） <ul>
<li>限流</li>
<li>关闭重试</li>
</ul>
</li>
<li>3） 缓存 <ul>
<li>将用户可能访问的数据大量的放入缓存中，减少访问数据库的请求。</li>
</ul>
</li>
<li>4）服务降级 <ul>
<li>服务接口拒绝服务</li>
<li>页面拒绝服务</li>
<li>延迟持久化</li>
<li>随机拒绝服务</li>
</ul>
</li>
<li>5） 服务熔断 <ul>
<li>如果对服务降级和服务熔断的概念模糊 <a href="##02.%E6%9C%8D%E5%8A%A1%E7%86%94%E6%96%AD%E4%B8%8E%E6%9C%8D%E5%8A%A1%E9%99%8D%E7%BA%A7">点击此处了解详情</a></li>
</ul>
</li>
</ul>
<h2 id="02-服务熔断与服务降级"><a href="#02-服务熔断与服务降级" class="headerlink" title="02.服务熔断与服务降级"></a>02.服务熔断与服务降级</h2><h3 id="2-1-什么是服务熔断"><a href="#2-1-什么是服务熔断" class="headerlink" title="2.1 什么是服务熔断"></a>2.1 什么是服务熔断</h3><ul>
<li>当下游的服务因为某种原因突然变得不可用或响应过慢，上游服务为了保证自己整体服务的可用性</li>
<li>不再继续调用目标服务，直接返回，快速释放资源。如果目标服务情况好转则恢复调用</li>
</ul>
<h3 id="2-2-服务熔断的原理"><a href="#2-2-服务熔断的原理" class="headerlink" title="2.2 服务熔断的原理"></a>2.2 服务熔断的原理</h3><ul>
<li>当远程服务被调用时，断路器将监视这个调用，如调用时间太长，断路器将会介入并中断调用。</li>
<li>此外，断路器将监视所有对远程资源的调用，如对某一个远程资源的调用失败次数足够多</li>
<li>那么断路器会出现并采取快速失败，阻止将来调用此远程资源的请求.</li>
<li>断路器模式的状态图</li>
</ul>
<p><img src="https://img.beyourself.org.cn/image-20220322100455997.png#id=TwRn9&originHeight=464&originWidth=780&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p>
<ul>
<li>最开始处于closed状态，一旦检测到错误到达一定阈值，便转为open状态；</li>
<li>这时候会有个 reset timeout，到了这个时间了，会转移到half open状态，尝试放行一部分请求到后端</li>
<li>一旦检测成功便回归到closed状态，即恢复服务</li>
</ul>
<p>断路器实现：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">阿里公司出的Sentinel</span><br><span class="line">netflix的Hystrix</span><br></pre></td></tr></table></figure>

<p>Hystrix中熔断的常用配置：</p>
<p><code>circuitBreaker.requestVolumeThreshold</code><br>默认值20.意思是至少有20个请求才进行errorThresholdPercentage错误百分比计算。比如一段时间（10s）内有19个请求全部失败了。错误百分比是100%，但熔断器不会打开，因为requestVolumeThreshold的值是20. 这个参数非常重要，</p>
<p><code>circuitBreaker.sleepWindowInMilliseconds</code><br>过多长时间，熔断器再次检测是否开启，默认为5000，即5s钟</p>
<p><code>circuitBreaker.errorThresholdPercentage</code><br>设定错误百分比，默认值50%，例如一段时间（10s）内有100个请求，其中有55个超时或者异常返回了，那么这段时间内的错误百分比是55%，大于了默认值50%，这种情况下触发熔断器-打开。</p>
<p>按照以上配置的熔断器如下：<br>每当20个请求中，有50%失败时，熔断器就会打开，此时再调用此服务，将会直接返回失败，不再调远程服务。直到5s钟之后，重新检测该触发条件，判断是否把熔断器关闭，或者继续打开</p>
<h3 id="2-3-服务降级"><a href="#2-3-服务降级" class="headerlink" title="2.3 服务降级"></a>2.3 服务降级</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">服务熔断可视为降级方式的一种！</span><br></pre></td></tr></table></figure>

<ul>
<li>一、当下游的服务因为某种原因响应过慢，下游服务主动停掉一些不太重要的业务，释放出服务器资源，增加响应速度！</li>
<li>二、当下游的服务因为某种原因不可用，上游主动调用本地的一些降级逻辑，避免卡顿，迅速返回给用户！</li>
</ul>
<p><code>**在实际的项目中，采用以下的方式来完成降级工作**</code></p>
<ul>
<li>梳理出核心业务流程和非核心业务流程。</li>
<li>然后在非核心业务流程上加上开关，一旦发现系统扛不住，关掉开关，结束这些次要流程。</li>
<li>一个微服务下肯定有很多功能，那自己区分出主要功能和次要功能。</li>
<li>然后次要功能加上开关，需要降级的时候，把次要功能关了吧！</li>
<li>降低一致性了，即将核心业务流程的同步改异步，将强一致性改最终一致性。</li>
</ul>
<h2 id="03-Hystrix"><a href="#03-Hystrix" class="headerlink" title="03.Hystrix"></a>03.Hystrix</h2><h3 id="3-1-Hystrix简介"><a href="#3-1-Hystrix简介" class="headerlink" title="3.1 Hystrix简介"></a>3.1 Hystrix简介</h3><ul>
<li>Hystrix是由Netflix创建一个类库。</li>
<li>在微服务的分布式环境中，系统存在许多服务依赖。在高并发访问下,这些依赖的稳定性与否对系统的影响非常大,</li>
<li>但是依赖有很多不可控问题:如网络连接缓慢，资源繁忙，暂时不可用，服务脱机等。</li>
<li>Hystrix可以通过添加延迟容错和容错逻辑来帮助我们控制这些分布式服务之间的交互。</li>
<li>Hystrix通过隔离服务之间的接入点，<code>阻止它们之间的级联故障，并提供备用选项，从而提高系统的整体弹性</code>。</li>
<li><code>断路器就是能够在发生问题的时候将请求断开，类似于保险丝</code>，当电压过高的时候自动熔断。这也就是断路器的熔断机制。</li>
</ul>
<p>设计目标</p>
<figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1. 对来自依赖的延迟和故障进行防护和控制——这些依赖通常都是通过网络访问的</span><br><span class="line">2. 阻止故障的连锁反应</span><br><span class="line">3. 快速失败并迅速恢复</span><br><span class="line">4. 回退并优雅降级</span><br><span class="line">5. 提供近实时的监控与告警</span><br></pre></td></tr></table></figure>

<p>设计原则</p>
<figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1. 防止任何单独的依赖耗尽资源（线程）</span><br><span class="line">2. 过载立即切断并快速失败，防止排队</span><br><span class="line">3. 尽可能提供回退以保护用户免受故障</span><br><span class="line">4. 使用隔离技术（例如隔板，泳道和断路器模式）来限制任何一个依赖的影响</span><br><span class="line">5. 通过近实时的指标，监控和告警，确保故障被及时发现</span><br><span class="line">6. 通过动态修改配置属性，确保故障及时恢复</span><br><span class="line">7. 防止整个依赖客户端执行失败，而不仅仅是网络通信</span><br></pre></td></tr></table></figure>

<h3 id="3-2-服务提供方降级"><a href="#3-2-服务提供方降级" class="headerlink" title="3.2 服务提供方降级"></a>3.2 服务提供方降级</h3><ul>
<li>场景假设1( 服务提供方报错) : <ul>
<li>在服务提供端中因为访问不到数据库中的数据(比如数据不存在，或是数据库压力过大，查询请求队列中)</li>
<li>在这种情况下，服务提供方这边如何实现服务降级,以防止服务雪崩.</li>
</ul>
</li>
<li>在 ProductController中加入断路逻辑</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/get/&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="meta">@HystrixCommand(fallbackMethod=&quot;errorCallBack&quot;)</span>   <span class="comment">//模仿没有这个数据时，服务降级</span></span><br><span class="line">  <span class="keyword">public</span> Object <span class="title function_">get</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> <span class="type">long</span> id)</span>&#123;</span><br><span class="line">        Product p=<span class="built_in">this</span>.productService.findById(id);</span><br><span class="line">        <span class="keyword">if</span>( p==<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;查无此产品&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//指定一个降级的方法</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">errorCallBack</span><span class="params">(  <span class="meta">@PathVariable(&quot;id&quot;)</span> <span class="type">long</span> id   )</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> id+<span class="string">&quot;不存在,error&quot;</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>启动服务后测试</li>
</ul>
<p><img src="https://img.beyourself.org.cn/image-20211123093428747.65e4240a.png#id=WJvrE&originHeight=440&originWidth=1506&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p>
<h3 id="3-3-服务消费方降级"><a href="#3-3-服务消费方降级" class="headerlink" title="3.3 服务消费方降级"></a>3.3 服务消费方降级</h3><ul>
<li>场景假设2: <ul>
<li>因为网络抖动，或服务端维护导致的服务暂时不可用，此时是客户端联接不到服务器</li>
<li>因为feign有重试机制，这样会导致系统长时间不响应,那么在这种情况上如何通过 feign+hystrix 在服务的消费方实现服务熔断(回退机制)呢?</li>
</ul>
</li>
<li><code>1）建立一个包 fallback</code> <ul>
<li>用于存回退处理类 IProductClientServiceFallbackFactory，这个类有出现请求异常时的处理</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.yc.springcloud2.fallback;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.yc.springcloud2.bean.Product;</span><br><span class="line"><span class="keyword">import</span> com.yc.springcloud2.service.IProductClientService;</span><br><span class="line"><span class="keyword">import</span> feign.hystrix.FallbackFactory;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="meta">@Component</span>    <span class="comment">//必须被spring 托管</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">IProductClientServiceFallbackFactory</span> <span class="keyword">implements</span> <span class="title class_">FallbackFactory</span>&lt;IProductClientService&gt; &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> IProductClientService <span class="title function_">create</span><span class="params">(Throwable throwable)</span> &#123;</span><br><span class="line">        <span class="comment">//这里提供请求方法出问题时回退处理机制</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">IProductClientService</span>()&#123;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> Product <span class="title function_">getProduct</span><span class="params">(<span class="type">long</span> id)</span> &#123;</span><br><span class="line">                Product p=<span class="keyword">new</span> <span class="title class_">Product</span>();</span><br><span class="line">                p.setProductId(<span class="number">999999999L</span>);</span><br><span class="line">                p.setProductDesc(<span class="string">&quot;error&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> p;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> List&lt;Product&gt; <span class="title function_">listProduct</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">addPorduct</span><span class="params">(Product product)</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>2）在业务接口上加入 fallbackFactory属性指定异常处理类</code></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FeignClient(name=&quot;MICROSERVICE-PROVIDER-PRODUCT&quot;,</span></span><br><span class="line"><span class="meta">        configuration = FeignClientConfig.class,</span></span><br><span class="line"><span class="meta">        fallbackFactory = IProductClientServiceFallbackFactory.class)</span>  <span class="comment">// 配置要按自定义的类FeignClientConfig</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">IProductClientService</span> &#123;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>3）启动 microservice-consumer-feign客户端进行测试, 在测试时，尝试关闭生产端，看它是否回退</code></li>
</ul>
<p><img src="https://img.beyourself.org.cn/image-20211123094025349.8aa49213.png#id=obKJj&originHeight=542&originWidth=1342&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p>
<h1 id="05-Turbine监控"><a href="#05-Turbine监控" class="headerlink" title="05.Turbine监控"></a>05.Turbine监控</h1><h2 id="01-Turbine"><a href="#01-Turbine" class="headerlink" title="01.Turbine"></a>01.Turbine</h2><h3 id="1-1-Turbine介绍"><a href="#1-1-Turbine介绍" class="headerlink" title="1.1 Turbine介绍"></a>1.1 Turbine介绍</h3><ul>
<li><strong>Turbine是聚合服务器发送事件流数据的一个工具，Hystrix的监控中，只能监控单个节点，实际生产中都为集群</strong></li>
<li><strong>因此可以通过Turbine来监控集群下Hystrix的metrics情况</strong></li>
<li><strong>Turbine的github地址：</strong><a target="_blank" rel="noopener" href="https://github.com/Netflix/Turbine"><strong>https://github.com/Netflix/Turbine</strong></a></li>
</ul>
<h3 id="1-2-使用场景"><a href="#1-2-使用场景" class="headerlink" title="1.2 使用场景"></a>1.2 使用场景</h3><ul>
<li><strong>在复杂的分布式系统中，相同服务的结点经常需要部署上百甚至上千个</strong></li>
<li>**很多时候，运维人员希望能够把相同服务的节点状态以一个整体集群的形式展现出来，这样可以更好的把握整个系统的状态。 **</li>
<li><strong>为此，</strong><code>**Netflix**</code><strong>又提供了一个开源项目</strong><code>**Turbine**</code>**来提供把多个 **<code>**hystrix.stream**</code><strong>的内容聚合为一个数据源供</strong><code>**Dashboard**</code><strong>展示。</strong></li>
<li><code>**Turbine**</code><strong>使用了Netflix的另一个开源项目</strong><code>**Archaius**</code><strong>来做配置文件的管理，其提供了非常强大的</strong></li>
</ul>
<h1 id="06-ZUUL网关"><a href="#06-ZUUL网关" class="headerlink" title="06.ZUUL网关"></a>06.ZUUL网关</h1><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/duanxz/p/7527765.html">https://www.cnblogs.com/duanxz/p/7527765.html</a></p>
<h2 id="01-网关介绍"><a href="#01-网关介绍" class="headerlink" title="01.网关介绍"></a>01.网关介绍</h2><h3 id="1-1-微服务架构-不足"><a href="#1-1-微服务架构-不足" class="headerlink" title="1.1 微服务架构-不足"></a>1.1 微服务架构-不足</h3><ul>
<li>现有架构介绍 <ul>
<li>我们使用Spring Cloud Netflix中的Eureka实现了服务注册中心以及服务注册与发现；</li>
<li>而服务间通过Ribbon或Feign实现服务的消费以及均衡负载；</li>
<li>通过Spring Cloud Config实现了应用多环境的外部化配置以及版本管理。</li>
<li>为了使得服务集群更为健壮，使用Hystrix的融断机制来避免在微服务架构中个别服务出现异常时引起的故障蔓延。</li>
</ul>
</li>
<li>在该架构中，我们的服务集群包含 <ul>
<li>内部服务Service A和Service B，他们都会注册与订阅服务至Eureka Server</li>
<li>而Open Service是一个对外的服务，通过均衡负载公开至服务调用方。</li>
<li>这里我们把焦点聚集在对外服务这块，这样的实现是否合理，或者是否有更好的实现方式呢？</li>
</ul>
</li>
</ul>
<p><img src="https://img.beyourself.org.cn/image-20211123104602090.c85e393c.png#id=bv5iQ&originHeight=1334&originWidth=1546&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p>
<h3 id="1-2-上面架构问题"><a href="#1-2-上面架构问题" class="headerlink" title="1.2 上面架构问题"></a>1.2 上面架构问题</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">先来说说这样架构需要做的一些事儿以及存在的不足</span><br></pre></td></tr></table></figure>

<ul>
<li>第一，破坏了服务无状态特点 <ul>
<li>为了保证对外服务的安全性，我们需要实现<code>对服务访问的权限控制</code>，而开放服务的权限控制机制将会贯穿并污染整个开放服务的业务逻辑</li>
<li>这会带来的最直接问题是，破坏了服务集群中REST API无状态的特点。</li>
<li>从具体开发和测试的角度来说，在工作中除了要考虑实际的业务逻辑之外，还需要额外可续对接口访问的控制处理。</li>
</ul>
</li>
<li>第二，无法直接复用既有接口 <ul>
<li>当我们需要对一个即有的集群内访问接口，实现外部服务访问时</li>
<li>我们不得不通过在原有接口上增加校验逻辑，或增加一个代理调用来实现权限控制，无法直接复用原有的接口。</li>
</ul>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">让客户端直接与各个微服务通讯，会有以下的问题：</span><br></pre></td></tr></table></figure>

<ul>
<li>客户端会多次请求不同的微服务，增加了客户端的复杂性。</li>
<li>存在跨域请求，在一定场景下处理相对复杂。</li>
<li>认证复杂，每个服务都需要独立认证。</li>
<li>难以重构，随着项目的迭代，可能需要重新划分微服务。 <ul>
<li>例如，可能将多个服务合并成一个或者将一个服务拆分成多个。</li>
<li>如果客户端直接与微服务通讯，那么重构将会很难实施。</li>
</ul>
</li>
<li>某些微服务可能使用了防火墙&#x2F;浏览器不友好的协议，直接访问会有一定困难。</li>
</ul>
<h3 id="1-3-网关主要功能"><a href="#1-3-网关主要功能" class="headerlink" title="1.3 网关主要功能"></a>1.3 网关主要功能</h3><p><code>**路由转发**</code></p>
<ul>
<li>之前说了「API网关」是内部微服务的对外唯一入口，所以外面全部的请求都会先发到这个「API网关」上</li>
<li>然后由「API网关」来根据不同的请求去路由到不同的微服务节点上。</li>
<li>例如<code>可以 根据路径 来转发、也可以 根据参数 来转发</code>。</li>
<li>并且由于内部微服务实例也会随着业务调整不停的变更，增加或者删除节点</li>
<li>「API网关」可以与「服务注册」模块进行协同工作，保证将外部请求转发到最合适的微服务实例上面去。</li>
</ul>
<p><code>**负载均衡**</code></p>
<ul>
<li>既然「API网关」是内部微服务的单一入口，所以「API网关」在收到外部请求之后，还可以根据内部微服务每个实例的负荷情况进行动态的负载均衡调节。</li>
<li>一旦内部的某个微服务实例负载很高，甚至是不能及时响应，则「API网关」就通过负载均衡策略减少或停止向这个实例转发请求。</li>
<li>当所有的内部微服务实例都处理不过来的时候，「API网关」还可以采用限流或熔断的形式阻止外部请求，以保障整个系统的可用性。</li>
</ul>
<p><code>**安全认证**</code></p>
<ul>
<li>「API网关」就像是微服务的大门守卫，每一个请求进来之后，都必须先在「API网关」上进行身份验证</li>
<li>身份验证通过后才转发给后面的服务，转发的时候一般也会带上身份信息。</li>
<li>同时「API网关」也需要对每一个请求进行安全性检查，例如参数的安全性、传输的安全性等等。</li>
</ul>
<p><code>**日志记录**</code></p>
<ul>
<li>既然所有的请求都需要走「API网关」，那么我们就可以在「API网关」上统一集中的记录下这些行为日志。</li>
<li>这些日志既可以作为我们后续事件查询使用，也可以作为系统的性能监控使用。</li>
</ul>
<p><code>**数据转换**</code></p>
<ul>
<li>因为「API网关」对外是面向多种不同的客户端，不同的客户端所传输的数据类型可能是不一样的。</li>
<li>因此「API网关」还需要具备数据转换的功能，将不同客户端传输进来的数据转换成同一种类型再转发给内部微服务上</li>
<li>这样，兼容了这些请求的多样性，保证了微服务的灵活性。</li>
</ul>
<h3 id="1-4-开源网关服务"><a href="#1-4-开源网关服务" class="headerlink" title="1.4 开源网关服务"></a>1.4 开源网关服务</h3><p><code>**Zuul**</code></p>
<ul>
<li>Zuul 是由 Netflix 所开源的组件，基于JAVA技术栈开发的。</li>
<li>Zuul网关的使用热度非常高，并且也集成到了 Spring Cloud 全家桶中了，使用起来非常方便。</li>
<li>看到Zuul的一个简化结构，过滤器filter是整个Zuul的核心 <ul>
<li>分为前置过滤器（pre filter）</li>
<li>路由过滤器（routing filter）</li>
<li>后置过滤器（post filter）</li>
<li>错误过滤器（error filter）</li>
</ul>
</li>
<li>一个请求过来，会先执行所有的 pre filter，然后再通过 routing filter 将请求转发给后端服务，后端服务进行结果响应之后，再执行 post filter，最后再响应给客户端。</li>
<li>在不同的filter里面可以执行不同的逻辑，比如安全检查、日志记录等等。</li>
</ul>
<p><img src="https://img.beyourself.org.cn/image-20211129150009659.e92748d7.png#id=YB4Nj&originHeight=800&originWidth=1388&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Tyk</span><br></pre></td></tr></table></figure>

<ul>
<li>Tyk是一个基于GO编写的，轻量级、快速可伸缩的开源的API网关。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Kong</span><br></pre></td></tr></table></figure>

<ul>
<li>Kong可以做到高性能、插件自定义、集群以及易于使用的Restful API管理。</li>
</ul>
<h2 id="02-zuul"><a href="#02-zuul" class="headerlink" title="02.zuul"></a>02.zuul</h2><h3 id="2-1-Zuul与Nginx配合"><a href="#2-1-Zuul与Nginx配合" class="headerlink" title="2.1 Zuul与Nginx配合"></a>2.1 Zuul与Nginx配合</h3><ul>
<li>Nginx的作用是反向代理、负载均衡，Zuul的作用是保障微服务的安全访问，拦截微服务请求，校验合法性及负载均衡。</li>
</ul>
<p><img src="https://img.beyourself.org.cn/image-20211129153031582.1c6c529d.png#id=P3asm&originHeight=728&originWidth=864&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p>
<h3 id="2-2-Zuul-1-0"><a href="#2-2-Zuul-1-0" class="headerlink" title="2.2 Zuul 1.0"></a>2.2 Zuul 1.0</h3><ul>
<li>Zuul网关的核心是一系列的过滤器，这些过滤器可以对请求或者响应结果做一系列过滤</li>
<li>Zuul 提供了一个框架可以支持动态加载，编译，运行这些过滤器</li>
<li>虽然Zuul 支持任何可以在jvm上跑的语言，但是目前zuul的过滤器只能使用Groovy脚本来编写</li>
<li>编写好的过滤器脚本一般放在zuul服务器的固定目录，zuul服务器会开启一个线程定时去轮询被修改或者新增的过滤器</li>
<li>然后动态进行编译，加载到内存，然后等后续有请求进来，新增或者修改后的过滤器就会生效了。</li>
</ul>
<p>在zuul中过滤器分为四种：</p>
<ul>
<li>PRE Filters(前置过滤器) <ul>
<li>当请求会路由转发到具体后端服务器前执行的过滤器，比如鉴权过滤器，日志过滤器，还有路由选择过滤器</li>
</ul>
</li>
<li>ROUTING Filters （路由过滤器） <ul>
<li>该过滤器作用是把请求具体转发到后端服务器上，一般是通过Apache HttpClient 或者 Netflix Ribbon把请求发送到具体的后端服务器上</li>
</ul>
</li>
<li>POST Filters（后置过滤器） <ul>
<li>当把请求路由到具体后端服务器后执行的过滤器；</li>
<li>场景有添加标准http 响应头，收集一些统计数据（比如请求耗时等），写入请求结果到请求方等。</li>
</ul>
</li>
<li>ERROR Filters（错误过滤器） <ul>
<li>当上面任何一个类型过滤器执行出错时候执行该过滤器</li>
</ul>
</li>
</ul>
<p><img src="https://image.beyourself.org.cn/image-20211129150009659.e92748d7.pngundefined#id=imBWU&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p>
<h3 id="2-3-Zuul-2-0新特性"><a href="#2-3-Zuul-2-0新特性" class="headerlink" title="2.3 Zuul 2.0新特性"></a>2.3 Zuul 2.0新特性</h3><ul>
<li>Netty作为高性能异步网络通讯框架，在dubbo，rocketmq,sofa等知名开源框架中都有使用</li>
<li>netty server作为网关监听服务器监听客户端发来的请求，然后把请求转发到前置过滤器（inbound filters）进行处理</li>
<li>处理完毕后在把请求使用netty client代理到具体的后端服务器进行处理</li>
<li>处理完毕后在把结果交给后者过滤器（outbound filters）进行处理</li>
<li>然后把处理结果通过nettyServer写回客户端</li>
<li>特性说明 <ul>
<li>在zuul1.0时候客户端发起的请求后需要同步等待zuul网关返回，zuul网关这边对每个请求会分派一个线程来进行处理，这会导致并发请求数量有限。</li>
<li>而zuul2.0使用netty作为异步通讯，可以大大加大并发请求量。</li>
</ul>
</li>
</ul>
<p><img src="https://img.beyourself.org.cn/image-20211129153948794.4a0f2b67.png#id=NJLej&originHeight=1030&originWidth=1242&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p>
<h1 id="07-Config配置中心"><a href="#07-Config配置中心" class="headerlink" title="07.Config配置中心"></a>07.Config配置中心</h1><h2 id="01-配置中心介绍"><a href="#01-配置中心介绍" class="headerlink" title="01.配置中心介绍"></a>01.配置中心介绍</h2><ul>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/fengzheng/p/11242128.html">https://www.cnblogs.com/fengzheng/p/11242128.html</a></li>
</ul>
<h3 id="1-1-配置中心"><a href="#1-1-配置中心" class="headerlink" title="1.1 配置中心"></a>1.1 配置中心</h3><ul>
<li>Spring Cloud 配置中心为分布式系统中的服务器端和客户端提供外部化配置支持。</li>
<li>通过Config-Server，你可以在一个地方集中对所有环境中的应用程序的外部化配置进行管理。</li>
<li>例如，当一个应用程序从开发环境切换到测试环境，然后再从测试环境切换到生产环境</li>
<li>你可以使用Config-Server统一管理这些环境之间的配置，并确保应用程序在迁移时能够拥有它运行所需要的一切配置。</li>
<li>简而言之：<code>Config-Server 就是用来实现配置统一管理和不同环境间配置的统一切换的。</code></li>
<li>Config-Server 服务器的后端存储默认使用Git，因此它很容易支持配置环境的标签版本，同时可供多数的内容管理工具去访问。</li>
<li>你也可以很容易地添加其他的替代实现，并将它们插入到Spring配置中。</li>
<li>相关产品： <ul>
<li>来自淘宝的Diamond：<a target="_blank" rel="noopener" href="https://github.com/takeseem/diamond">https://github.com/takeseem/diamond</a></li>
<li>来自百度的Disconf：<a target="_blank" rel="noopener" href="https://disconf.readthedocs.io/zh_CN/latest/">https://disconf.readthedocs.io/zh_CN&#x2F;latest&#x2F;</a></li>
<li>来自Springcloud的Config-Server：<a target="_blank" rel="noopener" href="https://cloud.spring.io/spring-cloud-stream/">https://cloud.spring.io/spring-cloud-stream/</a></li>
</ul>
</li>
</ul>
<h3 id="1-2-配置中心三个角色"><a href="#1-2-配置中心三个角色" class="headerlink" title="1.2 配置中心三个角色"></a>1.2 配置中心三个角色</h3><ul>
<li><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1）配置中心服务端：</span><br></pre></td></tr></table></figure>


<ul>
<li>为配置客户端提供对应的配置信息，配置信息的来源是配置仓库。</li>
<li>应用启动时，会从配置仓库拉取配置信息缓存到本地仓库中。</li>
<li><code>连接配置仓库、拉取远程配置&amp;本地缓存、对外提供API接口服务。</code></li>
</ul>
</li>
<li><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2）配置中心客户端：</span><br></pre></td></tr></table></figure>


<ul>
<li>就是在启动时从服务端把配置信息拉取到本地，然后设置到 Enviroment 中。</li>
<li>Spring Cloud Config 在项目启动时加载配置内容这一机制，导致了它存在一个缺陷，修改配置文件内容后，不会自动刷新。</li>
<li>默认访问 <a target="_blank" rel="noopener" href="http://localhost:3302/actuator/refresh">http://localhost:3302/actuator/refresh</a> 接口会刷新配置</li>
<li>github 提供了一种 webhook 的方式，当有代码变更的时候，会调用我们设置的地址，实现自动刷新</li>
</ul>
</li>
<li><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">3）配置仓库：</span><br></pre></td></tr></table></figure>


<ul>
<li>为配置中心服务端提供配置信息存储，Spring Cloud Config 默认是使用git作为仓库的。</li>
</ul>
</li>
</ul>
<p><img src="https://image.beyourself.org.cn/image-20211123152842223.8de72d50.pngundefined#id=zqnaK&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p>
<h1 id="08-Skywalking调用链"><a href="#08-Skywalking调用链" class="headerlink" title="08.Skywalking调用链"></a>08.Skywalking调用链</h1><h2 id="01-调用工具链"><a href="#01-调用工具链" class="headerlink" title="01.调用工具链"></a>01.调用工具链</h2><ul>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_39866487/article/details/111581322">https://blog.csdn.net/weixin_39866487&#x2F;article&#x2F;details&#x2F;111581322</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_38004638/article/details/115975798">https://blog.csdn.net/weixin_38004638&#x2F;article&#x2F;details&#x2F;115975798</a></li>
</ul>
<h3 id="1-1-调用用工具链对比"><a href="#1-1-调用用工具链对比" class="headerlink" title="1.1 调用用工具链对比"></a>1.1 调用用工具链对比</h3><ul>
<li><code>1.CAT</code> <ul>
<li>是一个更综合性的平台,提供的监控功能最全面，国内几个大厂生产也都在使用。</li>
<li>但研发进度及版本更新相对较慢。</li>
</ul>
</li>
<li><code>2.Zipkin</code> <ul>
<li>由Twitter开源，调用链分析工具，基于spring-cloud-sleuth得到广泛使用，非常轻量，使用部署简单。</li>
</ul>
</li>
<li><code>3.Skywalking</code> <ul>
<li>专注于链路和性能监控，国产开源，埋点无侵入，UI功能较强。</li>
<li>能够加入Apache孵化器，设计思想及代码得到一定认可，后期应该也会有更多的发展空间及研发人员投入。</li>
<li>目前使用厂商最多，版本更新较快。</li>
</ul>
</li>
<li><code>4.Pinpoint</code> <ul>
<li>专注于链路和性能监控，韩国研发团队开源，埋点无侵入，UI功能较强</li>
<li>但毕竟是小团队，不知道会不会一直维护着，目前版本仍在更新中</li>
</ul>
</li>
</ul>
<h3 id="1-2-前言"><a href="#1-2-前言" class="headerlink" title="1.2 前言"></a>1.2 前言</h3><ul>
<li>在微服务架构中，一次请求往往涉及到多个模块，多个中间件，多台机器的相互协作才能完成。</li>
<li>这一系列调用请求中，有些是串行的，有些是并行的，那么如何确定这个请求背后调用了哪些应用，哪些模块，哪些节点及调用的先后顺序？</li>
<li>如果有用户反馈某个页面很慢，我们知道这个页面的请求调用链是 A —–&gt; C —–&gt; B —–&gt; D，此时如何定位可能是哪个模块引起的问题。</li>
<li>每个服务 Service A,B,C,D 都有好几台机器，怎么知道某个请求调用了服务的具体哪台机器呢？ <ul>
<li>排查问题难度大，周期长</li>
<li>特定场景难复现</li>
<li>系统性能瓶颈分析较难</li>
</ul>
</li>
</ul>
<p><img src="https://img.beyourself.org.cn/image-20211124090027693.f2a30f1d.png#id=jjhxm&originHeight=570&originWidth=1804&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p>
<ul>
<li><code>分布式调用链就是为了解决以上几个问题而生</code></li>
</ul>
<h3 id="1-3-调用链的作用"><a href="#1-3-调用链的作用" class="headerlink" title="1.3 调用链的作用"></a>1.3 调用链的作用</h3><ul>
<li>自动采取数据</li>
<li>分析数据产生<strong>完整调用链</strong>：有了请求的完整调用链，问题有很大概率可复现</li>
<li>数据可视化：每个组件的性能可视化，能帮助我们很好地定位系统的瓶颈，及时找出问题所在</li>
</ul>
<h2 id="02-调用链标准"><a href="#02-调用链标准" class="headerlink" title="02.调用链标准"></a>02.调用链标准</h2><h3 id="2-1-分布式调用链标准"><a href="#2-1-分布式调用链标准" class="headerlink" title="2.1 分布式调用链标准"></a>2.1 分布式调用链标准</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">OpenTracing 规范</span><br></pre></td></tr></table></figure>

<ul>
<li>为了解决不同的分布式追踪系统 API 不兼容的问题，诞生了 OpenTracing 规范</li>
<li>OpenTracing 是一个轻量级的标准化层，它位于应用程序&#x2F;类库和追踪或日志分析程序之间</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">OpenTracing 的数据模型，主要有以下三个</span><br></pre></td></tr></table></figure>

<ul>
<li><code>**1）Trace**</code>：一个完整请求链路 <ul>
<li>一次下单的完整请求就是一个 Trace, 显然对于这个请求来说，必须要有一个全局标识来标识这一个请求</li>
<li>一个完整请求链路的追踪ID（traceid）用于查出本次请求调用的所有服务，每一次服务调用的跨度ID（spanid）用来记录调用顺序</li>
</ul>
</li>
<li><code>**2）Span**</code>：一次调用过程(需要有开始时间和结束时间) <ul>
<li>每一次调用就称为一个 Span，每一次调用都要带上全局的 TraceId, 这样才可把全局 TraceId 与每个调用关联起来</li>
<li>上游服务parenetid用来记录调用的层级关系</li>
</ul>
</li>
<li><code>**3）SpanContext**</code>：Trace 的全局上下文信息, 如里面有traceId <ul>
<li>这个 TraceId 就是通过 SpanContext 传输的，既然要传输显然都要遵循协议来调用。</li>
<li>调用时间timestamp，把请求发出、接收、处理的时间都记录下来，计算业务处理耗时和网络耗时，然后用可视化界面展示出来每个调用链路，性能，故障</li>
</ul>
</li>
<li><code>我们把传输协议比作车，把 SpanContext 比作货，把 Span 比作路应该会更好理解一些</code></li>
</ul>
<p><img src="https://img.beyourself.org.cn/image-20211124094533988.a73a513d.png#id=hIr8j&originHeight=1188&originWidth=1974&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p>
<h3 id="2-2-调用链图解"><a href="#2-2-调用链图解" class="headerlink" title="2.2 调用链图解"></a>2.2 调用链图解</h3><ul>
<li><code>理解了这三个概念，接下来我看看分布式追踪系统如何采集统一图中的微服务调用链</code></li>
</ul>
<p><img src="https://img.beyourself.org.cn/image-20211124100220799.0629bcb7.png#id=KnCE8&originHeight=1418&originWidth=1156&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p>
<ul>
<li>有了这些信息，Collector 收集的每次调用的信息如下</li>
</ul>
<p><img src="https://img.beyourself.org.cn/image-20211124095923241.095e7ce6.png#id=q4RcB&originHeight=284&originWidth=1456&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p>
<ul>
<li><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">以上实现看起来确实简单，但有以下几个问题需要我们仔细思考一下</span><br></pre></td></tr></table></figure>


<ul>
<li>怎么自动采集 span 数据：自动采集，对业务代码无侵入</li>
<li>如何跨进程传递 context</li>
<li>traceId 如何保证全局唯一</li>
<li>请求量这么多采集会不会影响性能</li>
</ul>
</li>
</ul>
<h2 id="03-SkyWalking结构设计"><a href="#03-SkyWalking结构设计" class="headerlink" title="03.SkyWalking结构设计"></a>03.SkyWalking结构设计</h2><h3 id="3-1-skywalking的工作机制"><a href="#3-1-skywalking的工作机制" class="headerlink" title="3.1 skywalking的工作机制"></a>3.1 skywalking的工作机制</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">skywalking的工作机制，需要三块协同</span><br></pre></td></tr></table></figure>

<ul>
<li>第一块是skywalking server：负责接收、存储并展示，所以server模块包含一个展示web子模块；</li>
<li>第二块是agent：负责代理微服务并收集需要的信息，转发给server；</li>
<li>第三块便是微服务本身：需要在启动时指定agent，以便生成代理类；</li>
</ul>
<p><img src="https://img.beyourself.org.cn/image-20211125095145882.e54e9143.png#id=rvMqX&originHeight=976&originWidth=1886&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p>
<h3 id="3-2-SkyWalking-核心模块介绍"><a href="#3-2-SkyWalking-核心模块介绍" class="headerlink" title="3.2 SkyWalking 核心模块介绍"></a>3.2 SkyWalking 核心模块介绍</h3><ul>
<li><code>1）Skywalking Agent</code> <ul>
<li>链路数据采集tracing（调用链数据）和metric（指标）信息并上报，上报通过HTTP或者gRPC方式发送数据到Skywalking Collector</li>
</ul>
</li>
<li><code>2）Skywalking Collector</code> <ul>
<li>链路数据收集器，对agent传过来的tracing和metric数据进行整合分析通过Analysis Core模块处理并落入相关的数据存储中</li>
<li>同时会通过Query Core模块进行二次统计和监控告警</li>
</ul>
</li>
<li><code>3）Storage</code> <ul>
<li>Skywalking的存储，支持以ElasticSearch、Mysql、TiDB、H2等主流存储作为存储介质进行数据存储,H2仅作为临时演示单机用。</li>
</ul>
</li>
<li><code>4）SkyWalking UI</code> <ul>
<li>Web可视化平台，用来展示落地的数据，目前官方采纳了RocketBot作为SkyWalking的主UI</li>
</ul>
</li>
</ul>
<h2 id="04-SkyWalking原理"><a href="#04-SkyWalking原理" class="headerlink" title="04.SkyWalking原理"></a>04.SkyWalking原理</h2><h3 id="4-1-自动采集-span-数据"><a href="#4-1-自动采集-span-数据" class="headerlink" title="4.1 自动采集 span 数据"></a>4.1 自动采集 span 数据</h3><ul>
<li>SkyWalking 采用了<strong>插件化</strong> + <strong>javaagent</strong> 的形式来实现了 span 数据的自动采集</li>
<li>这样可以做到对代码的 <strong>无侵入性</strong>，插件化意味着可插拔，扩展性好</li>
</ul>
<h3 id="4-2-跨进程传递-context"><a href="#4-2-跨进程传递-context" class="headerlink" title="4.2 跨进程传递 context"></a>4.2 跨进程传递 context</h3><ul>
<li>我们知道数据一般分为 header 和 body, 就像 http 有 header 和 body</li>
<li>RocketMQ 也有 MessageHeader，Message Body, body 一般放着业务数据</li>
<li>所以不宜在 body 中传递 context，应该在 header 中传递 context</li>
</ul>
<p><img src="https://img.beyourself.org.cn/image-20211124183138542.02933807.png#id=wWb9W&originHeight=996&originWidth=1800&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p>
<h3 id="4-3-traceId保证全局唯一"><a href="#4-3-traceId保证全局唯一" class="headerlink" title="4.3 traceId保证全局唯一"></a>4.3 traceId保证全局唯一</h3><ul>
<li>要保证全局唯一 ，我们可以采用分布式或者本地生成的 ID</li>
<li>使用分布式话需要有一个发号器，每次请求都要先请求一下发号器，会有一次网络调用的开销</li>
<li>所以 SkyWalking 最终采用了本地生成 ID 的方式，它采用了大名鼎鼎的 snowflow 算法，性能很高</li>
</ul>
<p><img src="https://img.beyourself.org.cn/image-20211124183515740.807db895.png#id=BDDHB&originHeight=406&originWidth=1482&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p>
<ul>
<li>时间回拨 <ul>
<li>每个 id，都会记录一下生成 id 的时间(lastTimestamp)，如果发现当前时间比上一次生成 id 的时间(lastTimestamp)还小</li>
<li>那说明发生了时间回拨，此时会生成一个随机数来作为 traceId。</li>
</ul>
</li>
</ul>
<h3 id="4-4-全部采集性能如何"><a href="#4-4-全部采集性能如何" class="headerlink" title="4.4 全部采集性能如何"></a>4.4 全部采集性能如何</h3><ul>
<li>如果对每个请求调用都采集，那毫无疑问数据量会非常大，其实没有必要</li>
<li>我们可以设置采样频率，只采样部分数据，<code>SkyWalking 默认设置了 3 秒采样 3 次</code>，其余请求不采样</li>
<li><code>如果上游有携带 Context</code>过来(说明上游采样了)，则下游<strong>强制</strong>采集数据。这样可以保证链路完整。</li>
</ul>
<h2 id="05-Skywalking-Agent原理"><a href="#05-Skywalking-Agent原理" class="headerlink" title="05.Skywalking Agent原理"></a>05.Skywalking Agent原理</h2><p>使用Skywalking的时候，并没有修改程序中任何一行 Java 代码，这里便使用到了 Java Agent 技术，我们接下来展开对Java Agent 技术的学习。</p>
<h3 id="5-1-Java-Agent"><a href="#5-1-Java-Agent" class="headerlink" title="5.1 Java Agent"></a>5.1 Java Agent</h3><ul>
<li>Java Agent 是从 JDK1.5 开始引入的，算是一个比较老的技术了。 </li>
<li>我们常用的命令之一就是 java 命令，而 Java Agent 本身就是 java 命令的一个参数（即 -javaagent）。 </li>
<li>-javaagent 参数之后需要指定一个 jar 包，这个 jar 包需要同时满足下面两个条件 <ul>
<li>第一：在 META-INF 目录下的 MANIFEST.MF 文件中<code>必须指定 premain-class 配置项</code>。 </li>
<li>第二：premain-class 配置项指定的类 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">必须提供了 premain() 方法</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<p>。 </p>
<pre><code>  - 在 Java 虚拟机启动时，执行 main() 函数之前，虚拟机会先找到 -javaagent 命令指定 jar 包
  - 然后执行premain-class 中的 premain() 方法。
  - 用一句概括其功能的话就是：main() 函数之前的一个拦截器。
</code></pre>
<ul>
<li><h2 id="使用-Java-Agent-的步骤大致如下-1）定义一个-MANIFEST-MF-文件，在其中添加-premain-class-配置项-2）创建-premain-class-配置项指定的类，并在其中实现-premain-方法，方法签名如下"><a href="#使用-Java-Agent-的步骤大致如下-1）定义一个-MANIFEST-MF-文件，在其中添加-premain-class-配置项-2）创建-premain-class-配置项指定的类，并在其中实现-premain-方法，方法签名如下" class="headerlink" title="使用 Java Agent 的步骤大致如下-  1）定义一个 MANIFEST.MF 文件，在其中添加 premain-class 配置项-  2）创建 premain-class 配置项指定的类，并在其中实现 premain() 方法，方法签名如下 "></a><code>使用 Java Agent 的步骤大致如下</code><br>-  1）定义一个 MANIFEST.MF 文件，在其中添加 premain-class 配置项<br>-  2）创建 premain-class 配置项指定的类，并在其中实现 premain() 方法，方法签名如下 </h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">premain</span><span class="params">(String agentArgs, Instrumentation inst)</span>&#123; </span><br><span class="line">    <span class="comment">//... </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p>1<br>2<br>3 </p>
<ul>
<li>3）将 MANIFEST.MF 文件和 premain-class 指定的类一起打包成一个 jar 包 </li>
<li>4）使用 -javaagent 指定该 jar 包的路径即可执行其中的 premain() 方法</li>
</ul>
<h3 id="5-2-探针"><a href="#5-2-探针" class="headerlink" title="5.2 探针"></a>5.2 探针</h3><ul>
<li>在 SkyWalking中，探针表示集成到目标系统中的代理或SDK库，它负责收集遥测数据，包括链路追踪和性能指标。</li>
<li>根据目标系统的技术栈，探针可能有差异巨大的方式来达到以上功能。</li>
<li>但从根本上来说都是一样的，即<code>收集并格式化数据，并发送到后端</code>。</li>
</ul>
<h3 id="5-3-服务自动打点代理"><a href="#5-3-服务自动打点代理" class="headerlink" title="5.3 服务自动打点代理"></a>5.3 服务自动打点代理</h3><ul>
<li>对于最终用户来说他们不需要修改代码(至少在绝大多数情况下)，只是被代理给修改了，这种做法通常叫做”在运行时操作代码”。</li>
<li>底层原理就是自动打点代理利用了虚拟机提供的用于修改代码的接口来动态加入打点的代码，如通过 javaagent premain 来修改 Java 类。</li>
<li>此外, 我们说大部分自动打点代理是基于虚拟机的，但实际上你也可以在编译期构建这样的工具。</li>
</ul>
<h1 id="09-skywalking安装"><a href="#09-skywalking安装" class="headerlink" title="09.skywalking安装"></a>09.skywalking安装</h1><h2 id="01-skywalking安装"><a href="#01-skywalking安装" class="headerlink" title="01.skywalking安装"></a>01.skywalking安装</h2><h3 id="1-1-下载对应版本"><a href="#1-1-下载对应版本" class="headerlink" title="1.1 下载对应版本"></a>1.1 下载对应版本</h3><ul>
<li>参考：<a target="_blank" rel="noopener" href="https://www.cnblogs.com/yizhipanghu/p/14738492.html">https://www.cnblogs.com/yizhipanghu/p/14738492.html</a></li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[root@skywalking skywalking]# <span class="built_in">mkdir</span> /usr/local/skywalking    <span class="comment"># 创建安装路径</span></span><br><span class="line"><span class="string">&#x27;&#x27;</span><span class="string">&#x27;1、elasticsearch-7.12.0.tar.gz，下载地址&#x27;</span><span class="string">&#x27;&#x27;</span></span><br><span class="line">[root@~]#  wget https://artifacts.elastic.co/downloads/elasticsearch/elasticsearch-7.12.0-linux-x86_64.tar.gz</span><br><span class="line"><span class="string">&#x27;&#x27;</span><span class="string">&#x27;2、apache-skywalking-apm-es7-8.5.0.tar.gz，下载地址&#x27;</span><span class="string">&#x27;&#x27;</span></span><br><span class="line">[root@~]#  wget https://archive.apache.org/dist/skywalking/8.5.0/apache-skywalking-apm-es7-8.5.0.tar.gz</span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;</span><span class="string">&#x27;3、安装JDK &#x27;</span><span class="string">&#x27;&#x27;</span></span><br><span class="line">[root@skywalking ~]# yum -y install java-1.8.0-openjdk-devel</span><br></pre></td></tr></table></figure>

<h2 id="02-安装ES"><a href="#02-安装ES" class="headerlink" title="02.安装ES"></a>02.安装ES</h2><h3 id="2-1-配置所有者"><a href="#2-1-配置所有者" class="headerlink" title="2.1 配置所有者"></a>2.1 配置所有者</h3><ul>
<li><code>1）创建安装路径</code></li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@skywalking skywalking]# <span class="built_in">mkdir</span> /usr/local/skywalking    <span class="comment"># 创建安装路径</span></span><br><span class="line">[root@skywalking skywalking]# tar -zxvf elasticsearch-7.12.0-linux-x86_64.tar.gz</span><br><span class="line">[root@skywalking skywalking]# <span class="built_in">cd</span> elasticsearch-7.12.0</span><br></pre></td></tr></table></figure>

<ul>
<li><code>2）修改两个配置</code></li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[root@skywalking skywalking]#  vi /etc/security/limits.conf     <span class="comment"># 修改后自动生效 (#末尾新增下面四行)</span></span><br><span class="line">es soft nofile 65536</span><br><span class="line">es hard nofile 65536</span><br><span class="line">es soft <span class="built_in">nproc</span> 4096</span><br><span class="line">es hard <span class="built_in">nproc</span> 4096</span><br><span class="line"></span><br><span class="line">[root@skywalking skywalking]#  vi /etc/sysctl.conf   <span class="comment"># 末尾新增下面一行</span></span><br><span class="line">vm.max_map_count=262144</span><br><span class="line"></span><br><span class="line">[root@skywalking skywalking]#  sysctl -p        <span class="comment"># 修改后执行sysctl -p 生效</span></span><br></pre></td></tr></table></figure>

<ul>
<li><code>3）创建独立用户与组（es默认不允许root用户登录）</code></li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@skywalking skywalking]# groupadd es          <span class="comment"># 创建用户组</span></span><br><span class="line">[root@skywalking skywalking]# useradd -g es es      <span class="comment"># 创建用户es，并添加至用户组es</span></span><br><span class="line">[root@skywalking skywalking]# passwd es     <span class="comment"># 设置密码</span></span><br><span class="line">New password:123456</span><br><span class="line">Retype new password:123456</span><br></pre></td></tr></table></figure>

<ul>
<li><code>4）更改软件包属主属组</code></li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@skywalking skywalking]# <span class="built_in">chown</span> -R es:es /usr/local/skywalking/elasticsearch-7.12.0</span><br></pre></td></tr></table></figure>

<h3 id="2-2-修改配置文件"><a href="#2-2-修改配置文件" class="headerlink" title="2.2 修改配置文件"></a>2.2 修改配置文件</h3><ul>
<li><code>1）单节点配置ip</code></li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">[root@skywalking config]# vim /usr/local/skywalking/elasticsearch-7.12.0/config/elasticsearch.yml</span><br><span class="line"><span class="comment"># 修改如下7个配置</span></span><br><span class="line">cluster.name: CollectorDBCluster</span><br><span class="line">path.data: /data/elasticsearch/data</span><br><span class="line">path.logs: /data/elasticsearch/logs</span><br><span class="line">network.host: 192.168.56.65</span><br><span class="line">http.port: 9200</span><br><span class="line">node.name: node-1</span><br><span class="line">cluster.initial_master_nodes: [<span class="string">&quot;node-1&quot;</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 注意：一定要将elasticsearch.yml中的  #cluster.initial_master_nodes: [&quot;node-1&quot;,&quot;node-2&quot;]注释去掉，并将“node-2”去掉</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建数据存储目录和日志存储目录</span></span><br><span class="line">[root@skywalking elasticsearch-7.12.0]# <span class="built_in">mkdir</span> -p /data/elasticsearch/data</span><br><span class="line">[root@skywalking elasticsearch-7.12.0]# <span class="built_in">mkdir</span> -p /data/elasticsearch/logs</span><br><span class="line"><span class="comment">#更改属主和属组</span></span><br><span class="line">[root@skywalking elasticsearch-7.12.0]# <span class="built_in">chown</span> -R es:es /data/elasticsearch</span><br></pre></td></tr></table></figure>

<ul>
<li>配置参数说明</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">各配置项含义：</span><br><span class="line">cluster.name    集群名称，各节点配成相同的集群名称。</span><br><span class="line">node.name       节点名称，各节点配置不同。</span><br><span class="line">node.master     指示某个节点是否符合成为主节点的条件。</span><br><span class="line">node.data       指示节点是否为数据节点。数据节点包含并管理索引的一部分。</span><br><span class="line">path.data       数据存储目录。</span><br><span class="line">path.logs       日志存储目录。</span><br><span class="line">bootstrap.memory_lock           内存锁定，是否禁用交换。</span><br><span class="line">bootstrap.system_call_filter    系统调用过滤器。</span><br><span class="line">network.host    绑定节点IP。</span><br><span class="line">http.port       端口。</span><br><span class="line">discovery.zen.ping.unicast.hosts    提供其他 Elasticsearch 服务节点的单点广播发现功能。</span><br><span class="line">discovery.zen.minimum_master_nodes  集群中可工作的具有Master节点资格的最小数量，官方的推荐值是(N/2)+1，其中N是具有master资格的节点的数量。</span><br><span class="line">discovery.zen.ping_timeout          节点在发现过程中的等待时间。</span><br><span class="line">discovery.zen.fd.ping_retries       节点发现重试次数。</span><br><span class="line">http.cors.enabled                   是否允许跨源 REST 请求，用于允许head插件访问ES。</span><br><span class="line">http.cors.allow-origin              允许的源地址。</span><br></pre></td></tr></table></figure>

<h3 id="2-3-启动并访问"><a href="#2-3-启动并访问" class="headerlink" title="#2.3 启动并访问"></a><a target="_blank" rel="noopener" href="http://v5blog.cn/pages/888017/#_2-3-%E5%90%AF%E5%8A%A8%E5%B9%B6%E8%AE%BF%E9%97%AE">#</a>2.3 启动并访问</h3><ul>
<li>切换至elasticsearch用户</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@skywalking elasticsearch-7.12.0]#  su es</span><br><span class="line">[es@k8s-node1 root]$   <span class="built_in">cd</span> /usr/local/skywalking/elasticsearch-7.12.0/bin/</span><br><span class="line">[es@k8s-node1 bin]$   ./elasticsearch </span><br><span class="line">[es@skywalking bin]$  <span class="built_in">cat</span> ../logs/elasticsearch.log       <span class="comment"># 查看启动日志</span></span><br></pre></td></tr></table></figure>

<ul>
<li>访问页面会显示版本号和一些配置信息</li>
</ul>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">curl http<span class="punctuation">:</span><span class="comment">//192.168.56.65:9200</span></span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;name&quot;</span> <span class="punctuation">:</span> <span class="string">&quot;node-1&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;cluster_name&quot;</span> <span class="punctuation">:</span> <span class="string">&quot;CollectorDBCluster&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;cluster_uuid&quot;</span> <span class="punctuation">:</span> <span class="string">&quot;sW-D83J9SPueVsQJvML22Q&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;version&quot;</span> <span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;number&quot;</span> <span class="punctuation">:</span> <span class="string">&quot;7.12.0&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;build_flavor&quot;</span> <span class="punctuation">:</span> <span class="string">&quot;default&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;build_type&quot;</span> <span class="punctuation">:</span> <span class="string">&quot;tar&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;build_hash&quot;</span> <span class="punctuation">:</span> <span class="string">&quot;78722783c38caa25a70982b5b042074cde5d3b3a&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;build_date&quot;</span> <span class="punctuation">:</span> <span class="string">&quot;2021-03-18T06:17:15.410153305Z&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;build_snapshot&quot;</span> <span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;lucene_version&quot;</span> <span class="punctuation">:</span> <span class="string">&quot;8.8.0&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;minimum_wire_compatibility_version&quot;</span> <span class="punctuation">:</span> <span class="string">&quot;6.8.0&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;minimum_index_compatibility_version&quot;</span> <span class="punctuation">:</span> <span class="string">&quot;6.0.0-beta1&quot;</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;tagline&quot;</span> <span class="punctuation">:</span> <span class="string">&quot;You Know, for Search&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<h2 id="03-安装Skywalking服务"><a href="#03-安装Skywalking服务" class="headerlink" title="03.安装Skywalking服务"></a>03.安装Skywalking服务</h2><h3 id="3-1-替换存储为ES"><a href="#3-1-替换存储为ES" class="headerlink" title="3.1 替换存储为ES"></a>3.1 替换存储为ES</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[es@skywalking skywalking]$ <span class="built_in">pwd</span></span><br><span class="line">/usr/local/skywalking</span><br><span class="line">[es@skywalking skywalking]$ tar -zxvf apache-skywalking-apm-es7-8.5.0.tar.gz</span><br></pre></td></tr></table></figure>

<ul>
<li>配置（说明 SkyWalking服务默认使用H2存储，不具有持久存储的特性，所以需要将存储组件修改为elasticsearch。）</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[root@skywalking config]# vim /usr/local/skywalking/apache-skywalking-apm-bin-es7/config/application.yml</span><br><span class="line">修改配置如下：</span><br><span class="line"><span class="comment">#注释h2的selector，添加elasticsearch7,注意elasticsearch7中localhost改为ip地址</span></span><br><span class="line">storage: </span><br><span class="line"><span class="comment">#selector: $&#123;SW_STORAGE:h2&#125; </span></span><br><span class="line">selector: <span class="variable">$&#123;SW_STORAGE:elasticsearch7&#125;</span></span><br><span class="line">　　elasticsearch7:</span><br><span class="line">　　nameSpace: <span class="variable">$&#123;SW_NAMESPACE:&quot;skywalking-index&quot;&#125;</span></span><br><span class="line">　　clusterNodes: <span class="variable">$&#123;SW_STORAGE_ES_CLUSTER_NODES:10.153.61.71:9200&#125;</span></span><br><span class="line">　　protocol: <span class="variable">$&#123;SW_STORAGE_ES_HTTP_PROTOCOL:&quot;http&quot;&#125;</span></span><br><span class="line">　　trustStorePath: <span class="variable">$&#123;SW_STORAGE_ES_SSL_JKS_PATH:&quot;&quot;&#125;</span></span><br><span class="line">　　trustStorePass: <span class="variable">$&#123;SW_STORAGE_ES_SSL_JKS_PASS:&quot;&quot;&#125;</span></span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th>参数</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>selector</td>
<td>存储选择器。本文设置为elasticsearch7。</td>
</tr>
<tr>
<td>nameSpace</td>
<td>命名空间。Elasticsearch实例中，所有索引的命名会使用此参数值作为前缀。</td>
</tr>
<tr>
<td>clusterNodes</td>
<td>指定Elasticsearch实例的访问地址。由于实例与SkyWalking不在同一专有网络VPC（Virtual Private Cloud）下，因此要使用公网访问地址，获取方式请参见<a target="_blank" rel="noopener" href="https://help.aliyun.com/document_detail/67804.htm#task-2449896">查看实例的基本信息</a></td>
</tr>
<tr>
<td>。</td>
<td></td>
</tr>
<tr>
<td>user</td>
<td>Elasticsearch实例的访问用户名，默认为elastic。</td>
</tr>
<tr>
<td>password</td>
<td>对应用户的密码。elastic用户的密码在创建实例时指定，如果忘记可重置。重置密码的注意事项和操作步骤，请参见<a target="_blank" rel="noopener" href="https://help.aliyun.com/document_detail/159883.htm#task-2458093">重置实例访问密码</a></td>
</tr>
<tr>
<td>。</td>
<td></td>
</tr>
</tbody></table>
<h3 id="3-2-修改端口"><a href="#3-2-修改端口" class="headerlink" title="3.2 修改端口"></a>3.2 修改端口</h3><ul>
<li>webapp&#x2F;webapp.yml 保持默认配置即可，如果8080端口被其他服务占用，可以修改8080端口为18080</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[root@skywalking webapp]# <span class="built_in">cat</span> /usr/local/skywalking/apache-skywalking-apm-bin-es7/webapp/webapp.yml</span><br><span class="line">server:</span><br><span class="line">  port: 18080</span><br><span class="line"></span><br><span class="line">collector:</span><br><span class="line">  path: /graphql</span><br><span class="line">  ribbon:</span><br><span class="line">    ReadTimeout: 10000</span><br><span class="line">    <span class="comment"># Point to all backend&#x27;s restHost:restPort, split by ,</span></span><br><span class="line">    listOfServers: 192.168.56.65:12800</span><br></pre></td></tr></table></figure>

<h3 id="3-3-开放端口并启动服务"><a href="#3-3-开放端口并启动服务" class="headerlink" title="3.3 开放端口并启动服务"></a>3.3 开放端口并启动服务</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">[root@skywalking webapp]# firewall-cmd --list-ports</span><br><span class="line">[root@skywalking webapp]# firewall-cmd --zone=public --add-port=18080/tcp --permanent</span><br><span class="line">[root@skywalking webapp]# firewall-cmd --zone=public --add-port=11800/tcp --permanent</span><br><span class="line">[root@skywalking webapp]# firewall-cmd --zone=public --add-port=12800/tcp --permanent</span><br><span class="line">[root@skywalking webapp]# firewall-cmd --reload</span><br><span class="line">[root@k8s-node1 bin]# <span class="built_in">cd</span> /usr/local/skywalking/apache-skywalking-apm-bin-es7/bin/</span><br><span class="line">[root@localhost bin]# sh startup.sh   <span class="comment"># 启动</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 启动sky前要确保es已经正常运行 </span></span><br><span class="line"><span class="comment"># jps查看进程，skywalking,有两个进程skywalking-webapp.jar和OAPServerStartUp</span></span><br><span class="line">[root@skywalking webapp]# jps</span><br><span class="line">26662 skywalking-webapp.jar</span><br><span class="line">46391 Jps</span><br><span class="line">33080 OAPServerStartUp</span><br><span class="line">32379 Elasticsearch</span><br></pre></td></tr></table></figure>

<h1 id="10-skywalking使用"><a href="#10-skywalking使用" class="headerlink" title="10.skywalking使用"></a>10.skywalking使用</h1><h2 id="01-skywalking-python"><a href="#01-skywalking-python" class="headerlink" title="01.skywalking-python"></a>01.skywalking-python</h2><h3 id="1-0-参考"><a href="#1-0-参考" class="headerlink" title="1.0 参考"></a>1.0 参考</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">官网：<span class="attr">https</span>:<span class="comment">//skywalking.apache.org/docs/skywalking-python/v0.7.0/en/setup/intrusive/</span></span><br><span class="line">包官网：<span class="attr">https</span>:<span class="comment">//pypi.org/project/apache-skywalking/</span></span><br><span class="line"><span class="title class_">GitHub</span>：<span class="attr">https</span>:<span class="comment">//github.com/apache/skywalking-python/tree/1d25b08c5a3d6b16719966406fec2c51291b0126</span></span><br><span class="line">博客案例：<span class="attr">https</span>:<span class="comment">//blog.csdn.net/qq_30355341/article/details/114641498</span></span><br><span class="line">flask使用skywalking：<span class="attr">https</span>:<span class="comment">//blog.csdn.net/qq_30355341/article/details/114641498</span></span><br></pre></td></tr></table></figure>

<h3 id="1-1-安装"><a href="#1-1-安装" class="headerlink" title="1.1 安装"></a>1.1 安装</h3><ul>
<li><a target="_blank" rel="noopener" href="https://skywalking.apache.org/docs/skywalking-python/v0.7.0/en/setup/installation/">https://skywalking.apache.org/docs/skywalking-python/v0.7.0/en/setup/installation/</a></li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Install the latest version, using the default gRPC protocol to report data to OAP</span></span><br><span class="line">pip install <span class="string">&quot;apache-skywalking&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Install the latest version, using the http protocol to report data to OAP</span></span><br><span class="line">pip install <span class="string">&quot;apache-skywalking[http]&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Install the latest version, using the kafka protocol to report data to OAP</span></span><br><span class="line">pip install <span class="string">&quot;apache-skywalking[kafka]&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Install a specific version x.y.z</span></span><br><span class="line"><span class="comment"># pip install apache-skywalking==x.y.z</span></span><br><span class="line">pip install apache-skywalking==<span class="number">0.1</span><span class="number">.0</span>  <span class="comment"># For example, install version 0.1.0 no matter what the latest version is</span></span><br></pre></td></tr></table></figure>

<h3 id="1-2-使用测试"><a href="#1-2-使用测试" class="headerlink" title="1.2 使用测试"></a>1.2 使用测试</h3><ul>
<li>只需在启动前初始化 skywalking的配置文件</li>
<li>官方文档：<a target="_blank" rel="noopener" href="https://pypi.org/project/apache-skywalking/">https://pypi.org/project/apache-skywalking/</a></li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#! /usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask</span><br><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> request</span><br><span class="line"><span class="keyword">from</span> skywalking <span class="keyword">import</span> agent, config</span><br><span class="line"></span><br><span class="line">config.init(collector_address=<span class="string">&#x27;192.168.56.65:11800&#x27;</span>, service_name=<span class="string">&#x27;flask_test02&#x27;</span>)</span><br><span class="line">agent.start()</span><br><span class="line">agent.start()</span><br><span class="line"></span><br><span class="line">app=Flask(__name__)</span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&#x27;/user/&lt;name&gt;&#x27;</span></span>)  </span><span class="comment">#设置url传参数 http://127.0.0.1:5000/user/zhangsan?name=aaa</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">first_flask</span>(<span class="params">name</span>):      <span class="comment">#视图必须有对应接收参数</span></span><br><span class="line">    <span class="built_in">print</span>(name)             <span class="comment"># zhangsan</span></span><br><span class="line">    <span class="built_in">print</span>(request.form)     <span class="comment"># 获取post请求</span></span><br><span class="line">    <span class="built_in">print</span>(request.values.get(<span class="string">&#x27;name&#x27;</span>))   <span class="comment"># 获取get请求中参数</span></span><br><span class="line">    <span class="built_in">print</span>(request.args.get(<span class="string">&#x27;name&#x27;</span>))     <span class="comment"># 获取get请求中参数</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;Hello World&#x27;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    app.run(debug=<span class="literal">True</span>,port=<span class="number">8001</span>)</span><br></pre></td></tr></table></figure>

<h1 id="11-ServiceMesh"><a href="#11-ServiceMesh" class="headerlink" title="11.ServiceMesh"></a>11.ServiceMesh</h1><h2 id="01-微服务问题"><a href="#01-微服务问题" class="headerlink" title="01.微服务问题"></a>01.微服务问题</h2><ul>
<li><a target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000039672263">https://segmentfault.com/a/1190000039672263</a></li>
</ul>
<h3 id="1-1-微服务实现流程"><a href="#1-1-微服务实现流程" class="headerlink" title="1.1 微服务实现流程"></a>1.1 微服务实现流程</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1、服务都注册到服务注册中心</span><br></pre></td></tr></table></figure>

<ul>
<li>要构建微服务体系，首先我们需要独立部署一款实现服务注册&#x2F;发现功能的组件服务，目前可供选择的主流方案一般有Eureka、Consul、Nacos等</li>
<li>搞定服务注册&#x2F;发现后，我们编写一个Java微服务，此时为了将该服务注册到服务注册中心</li>
<li>一般会引入Spring Cloud提供的支持对应注册中心接入的SDK，并在应用入口类中通过@EnableDiscoveryClient注解的方式标注</li>
<li>之后SDK中的逻辑就会在应用启动时执行服务注册动作，并提供给注册中心相应地探测接口，以此实现微服务与服务注册中心之间的连接。</li>
<li>以此类推，我们可以通过这种方式将一组微服务都注册到服务注册中心！</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2、服务之间要互相调用</span><br></pre></td></tr></table></figure>

<ul>
<li>一般我们会通过编写FeignClient接口来实现微服务之间的调用</li>
<li>而其底层的逻辑则是通过Feign所集成的Ribbon组件去注册中心中获取目标服务的服务地址列表</li>
<li>之后Ribbon根据服务地址列表进行负载均衡调用。</li>
<li>至于服务与注册中心之间如何保证连接有效性，则依赖于服务注册中心与其SDK之间的协作机制。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">3、负载均衡、熔断、限流、网关</span><br></pre></td></tr></table></figure>

<ul>
<li>而高级一点，服务之间的调用除了实现负载均衡，还要实现熔断限流</li>
<li>那么此时可以通过部署服务网关组件（例如Zuul&#x2F;Spring Cloud GateWay）来实现微服务入口的熔断限流</li>
<li>内部服务之间的限流熔断则通过集成Hystrix或Sentinel组件，以客户端本地配置或远程配置中心的方式来实现。</li>
</ul>
<h3 id="1-2-微服务遇到的问题"><a href="#1-2-微服务遇到的问题" class="headerlink" title="1.2 微服务遇到的问题"></a>1.2 微服务遇到的问题</h3><p><code>**1、框架/SDK太多，后续升级维护困难**</code></p>
<ul>
<li>在这套体系中，与服务治理相关的逻辑都是以SDK代码依赖的方式嵌入在微服务之中</li>
<li>如果某天我们想升级下服务注册中心的SDK版本，或者熔断限流组件Hystrix或Sentinel的版本，那么需要升级改造的微服务可能会是成百上千</li>
<li>且由于这些组件都与业务应用绑定在一起，在升级的过程中会不会影响业务稳定，这都是需要谨慎对待的事情，所以对SDK的升级难度可想而知的！</li>
</ul>
<p><code>**2、多语言微服务SDK维护成本高**</code></p>
<ul>
<li>试想下如果构建的微服务体系，也要支持像Go、Python或者其他语言编写的微服务的话</li>
<li>那么上述这些微服务治理相关的SDK是不是得单独再维护几套呢？</li>
<li>所以在这种体系结构中，对多语言微服务的支持就成了一个问题！</li>
</ul>
<p><code>**3、服务治理策略难以统一控制**</code></p>
<ul>
<li>基于该套体系构建的微服务体系，在对像熔断、限流、负载均衡等服务治理相关的策略管理上，都是比较分散的</li>
<li>可能有人会写到自己的本地配置文件，有人会硬编码到代码逻辑中，也可能有人会将其配置到远程配置中心</li>
<li>总之对于服务治理策略逻辑都是由对应的开发人员自己控制，这样就很难形成统一的控制体系！</li>
</ul>
<p><code>**4、服务治理逻辑嵌入业务应用，占有业务服务资源**</code></p>
<ul>
<li>在这套微服务体系中，服务治理相关的逻辑都是在微服务应用进程中寄生运行的</li>
<li>这多少会占有宝贵的业务服务器资源，影响应用性能的发挥！</li>
</ul>
<p><code>**5、额外的服务治理组件的维护成本**</code></p>
<ul>
<li>无论是服务注册中心、还是服务网关，这些除了微服务应用本身之外服务治理组件，都需要我们以中间件基础服务的方式进行维护</li>
<li>需要额外的人力、额外的服务器成本</li>
</ul>
<h2 id="02-Service-Mesh实现"><a href="#02-Service-Mesh实现" class="headerlink" title="02.Service Mesh实现"></a>02.Service Mesh实现</h2><h3 id="2-1-Service-Mesh是什么"><a href="#2-1-Service-Mesh是什么" class="headerlink" title="2.1 Service Mesh是什么"></a>2.1 Service Mesh是什么</h3><ul>
<li>如果用一句话来解释什么是 Service Mesh，可以将它比作是<strong>应用程序或者说微服务间的 TCP&#x2F;IP，负责服务之间的网络调用、限流、熔断和监控</strong>。</li>
<li>对于编写应用程序来说一般无须关心 TCP&#x2F;IP 这一层（比如通过 HTTP 协议的 RESTful 应用）</li>
<li>同样使用 Service Mesh 也就无须关系服务之间的那些原来是通过应用程序或者其他框架实现的事情</li>
<li>比如 Spring Cloud、OSS，现在只要交给 Service Mesh 就可以了。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Service Mesh 有如下几个特点</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>应用程序间通讯的中间层</strong></li>
<li><strong>轻量级网络代理</strong></li>
<li><strong>应用程序无感知</strong></li>
<li><strong>解耦应用程序的重试&#x2F;超时、监控、追踪和服务发现</strong></li>
</ul>
<h3 id="2-2-Service-Mesh网格"><a href="#2-2-Service-Mesh网格" class="headerlink" title="2.2 Service Mesh网格"></a>2.2 Service Mesh网格</h3><ul>
<li>其中绿色的正方形表示正常部署的微服务，而蓝色的正方形表示一个网络代理，也就是大家通常所说的<strong>SideCar</strong>。</li>
<li>在Service Mesh架构下，每部署一个微服务，都需要部署一个与之相对应的代理服务，所有与微服务本身的交互都通过SideCar代理</li>
<li>而SideCar之间会形成一张形似网格的交互链路，这就是服务网格名称的来由</li>
<li>在Service Mesh中，当我们将一个服务部署在Kubernetes之后</li>
<li>安装在Kubernetes中的Service Mesh组件（例如Istio）就会自动在该微服务的同一个Pod之中启动一个与之对应的代理进程（例如istio-proxy)</li>
<li>这个保姆式的代理进程会代替微服务本身去实现原先在Spring Cloud体系中需要微服务自身完成的服务注册、负载均衡、熔断限流等微服务治理功能。</li>
<li>并且，这些代理进程并不是孤军奋战，而是会通过像xDS协议（Service Mesh中数据面与控制面通信的通用协议）与Service Mesh控制组件保持连接。</li>
</ul>
<p><img src="https://img.beyourself.org.cn/image-20211126105936598.acad5e0c.png#id=IsBUn&originHeight=548&originWidth=868&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p>
<h3 id="2-3-ServiceMesh开源项目"><a href="#2-3-ServiceMesh开源项目" class="headerlink" title="2.3 ServiceMesh开源项目"></a>2.3 ServiceMesh开源项目</h3><ul>
<li><strong>Linkerd</strong>（<a target="_blank" rel="noopener" href="https://github.com/linkerd/linkerd%EF%BC%89%EF%BC%9A%E7%AC%AC%E4%B8%80%E4%BB%A3">https://github.com/linkerd/linkerd）：第一代</a> Service Mesh，2016 年 1 月 15 日首发布，业界第一个 Service Mesh 项目，由 Buoyant 创业小公司开发（前 Twitter 工程师），2017 年 7 月 11 日，宣布和 Istio 集成，成为 Istio 的数据面板。</li>
<li><strong>Envoy</strong>（<a target="_blank" rel="noopener" href="https://github.com/envoyproxy/envoy%EF%BC%89%EF%BC%9A%E7%AC%AC%E4%B8%80%E4%BB%A3">https://github.com/envoyproxy/envoy）：第一代</a> Service Mesh，2016 年 9 月 13 日首发布，由 Matt Klein 个人开发（Lyft 工程师），之后默默发展，版本较稳定。</li>
<li><strong>Istio</strong>（<a target="_blank" rel="noopener" href="https://github.com/istio/istio%EF%BC%89%EF%BC%9A%E7%AC%AC%E4%BA%8C%E4%BB%A3">https://github.com/istio/istio）：第二代</a> Service Mesh，2017 年 5 月 24 日首发布，由 Google、IBM 和 Lyft 联合开发，只支持 Kubernetes 平台，2017 年 11 月 30 日发布 0.3 版本，开始支持非 Kubernetes 平台，之后稳定的开发和发布。</li>
<li><strong>Conduit</strong>（<a target="_blank" rel="noopener" href="https://github.com/runconduit/conduit%EF%BC%89%EF%BC%9A%E7%AC%AC%E4%BA%8C%E4%BB%A3">https://github.com/runconduit/conduit）：第二代</a> Service Mesh，2017 年 12 月 5 日首发布，由 Buoyant 公司开发（借鉴 Istio 整体架构，部分进行了优化），对抗 Istio 压力山大，也期待 Buoyant 公司的毅力。</li>
<li><strong>nginMesh</strong>（<a target="_blank" rel="noopener" href="https://github.com/nginmesh/nginmesh%EF%BC%89%EF%BC%9A2017">https://github.com/nginmesh/nginmesh）：2017</a> 年 9 月首发布，由 Nginx 开发，定位是作为 Istio 的服务代理，也就是替代 Envoy，思路跟 Linkerd 之前和 Istio 集成很相似，极度低调，GitHub 上的 star 也只有不到 100。</li>
<li><strong>Kong</strong>（<a target="_blank" rel="noopener" href="https://github.com/Kong/kong%EF%BC%89%EF%BC%9A%E6%AF%94">https://github.com/Kong/kong）：比</a> nginMesh 更加低调，默默发展中。</li>
</ul>

    </article>
    
    <div class="read-nums">
      <!-- id 将作为查询条件 -->
      <span id="2024/09/01/微服务概念/" class="leancloud_visitors" data-flag-title="Your Article Title">
        <em class="post-meta-item-text">浏览量</em>
        <i class="leancloud-visitors-count"></i>
      </span>
    </div>
    <div class="comments-intro">
      <h2>评论区</h2>
      <p>欢迎你留下宝贵的意见，昵称输入QQ号会显示QQ头像哦~</p>
    </div>
    <div id="vcomments" class="vcomments"></div>
    
  </div>
  <div class="article-catelogue">
    <div class="article-catelogue--wrapper">
      <div class="catelogue catelogue-1">
        <h3>目录</h3>
        <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%BE%AE%E6%9C%8D%E5%8A%A1"><span class="toc-number">1.</span> <span class="toc-text">微服务</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#01-%E5%BE%AE%E6%9C%8D%E5%8A%A1%E4%BB%8B%E7%BB%8D"><span class="toc-number">2.</span> <span class="toc-text">01.微服务介绍</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#01-%E5%8D%95%E4%BD%93%E5%92%8C%E5%BE%AE%E6%9C%8D%E5%8A%A1%E4%BB%8B%E7%BB%8D"><span class="toc-number">2.1.</span> <span class="toc-text">01.单体和微服务介绍</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-%E5%8D%95%E4%BD%93%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84"><span class="toc-number">2.1.1.</span> <span class="toc-text">1.1 单体服务架构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84%E4%BB%8B%E7%BB%8D"><span class="toc-number">2.1.2.</span> <span class="toc-text">1.2 微服务架构介绍</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-3-%E7%AE%80%E5%8D%95%E5%BE%AE%E6%9C%8D%E5%8A%A1%E8%AE%BF%E9%97%AE%E7%BC%BA%E9%99%B7"><span class="toc-number">2.1.3.</span> <span class="toc-text">1.3 简单微服务访问缺陷</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-4-%E5%9F%9F%E5%90%8D%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88"><span class="toc-number">2.1.4.</span> <span class="toc-text">1.4 域名解决方案</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#02-%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84"><span class="toc-number">2.2.</span> <span class="toc-text">02.微服务架构</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-%E5%BE%AE%E6%9C%8D%E5%8A%A1%E7%BB%84%E4%BB%B6"><span class="toc-number">2.2.1.</span> <span class="toc-text">2.1 微服务组件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84%E4%BC%98%E7%82%B9"><span class="toc-number">2.2.2.</span> <span class="toc-text">2.2 微服务架构优点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84%E7%9A%84%E7%BC%BA%E7%82%B9"><span class="toc-number">2.2.3.</span> <span class="toc-text">2.3 微服务架构的缺点</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#03-%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%AE%9E%E7%8E%B0%E6%B5%81%E7%A8%8B"><span class="toc-number">2.3.</span> <span class="toc-text">03.微服务实现流程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%AE%9E%E7%8E%B0%E6%B5%81%E7%A8%8B"><span class="toc-number">2.3.1.</span> <span class="toc-text">3.1 微服务实现流程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-%E5%BE%AE%E6%9C%8D%E5%8A%A1%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98"><span class="toc-number">2.3.2.</span> <span class="toc-text">3.2 微服务遇到的问题</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#04-%E5%90%84%E8%AF%AD%E8%A8%80%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%A1%86%E6%9E%B6"><span class="toc-number">2.4.</span> <span class="toc-text">04.各语言微服务框架</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-Java"><span class="toc-number">2.4.1.</span> <span class="toc-text">4.1 Java</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-Go"><span class="toc-number">2.4.2.</span> <span class="toc-text">4.2 Go</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-3-Python"><span class="toc-number">2.4.3.</span> <span class="toc-text">4.3 Python</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#02-Eureka%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83"><span class="toc-number">3.</span> <span class="toc-text">02.Eureka注册中心</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#01-%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83%E5%8E%9F%E7%90%86"><span class="toc-number">3.1.</span> <span class="toc-text">01.注册中心原理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83"><span class="toc-number">3.1.1.</span> <span class="toc-text">1.1 为什么需要注册中心</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83%E5%8E%9F%E7%90%86"><span class="toc-number">3.1.2.</span> <span class="toc-text">1.2 注册中心原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-3-%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83%E5%8A%9F%E8%83%BD"><span class="toc-number">3.1.3.</span> <span class="toc-text">1.3 注册中心功能</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#02-Eureka%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83-1"><span class="toc-number">3.2.</span> <span class="toc-text">02.Eureka注册中心</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-Eureka%E5%9B%BE%E8%A7%A3"><span class="toc-number">3.2.1.</span> <span class="toc-text">2.1 Eureka图解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-Eureka%E4%BB%8B%E7%BB%8D"><span class="toc-number">3.2.2.</span> <span class="toc-text">2.2 Eureka介绍</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-Eureka%E7%BB%84%E4%BB%B6%E5%8A%9F%E8%83%BD"><span class="toc-number">3.2.3.</span> <span class="toc-text">2.3 Eureka组件功能</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#03-%E5%B8%B8%E7%94%A8%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83%E6%AF%94%E8%BE%83"><span class="toc-number">3.3.</span> <span class="toc-text">03.常用注册中心比较</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-0-CAP%E7%90%86%E8%AE%BA"><span class="toc-number">3.3.1.</span> <span class="toc-text">3.0 CAP理论</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-Zookeeper"><span class="toc-number">3.3.2.</span> <span class="toc-text">3.1 Zookeeper</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-Eureka"><span class="toc-number">3.3.3.</span> <span class="toc-text">3.2 Eureka</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3-Consul"><span class="toc-number">3.3.4.</span> <span class="toc-text">3.3 Consul</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-4-Nacos"><span class="toc-number">3.3.5.</span> <span class="toc-text">3.4 Nacos</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#03-Ribbon%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1"><span class="toc-number">4.</span> <span class="toc-text">03.Ribbon负载均衡</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#01-%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E4%BB%8B%E7%BB%8D"><span class="toc-number">4.1.</span> <span class="toc-text">01.负载均衡介绍</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-%E6%9C%8D%E5%8A%A1%E7%AB%AF%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1"><span class="toc-number">4.1.1.</span> <span class="toc-text">1.1 服务端负载均衡</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-Ribbon%E5%AE%A2%E6%88%B7%E7%AB%AF%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1"><span class="toc-number">4.1.2.</span> <span class="toc-text">1.2 Ribbon客户端负载均衡</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#02-Ribbon%E4%BB%8B%E7%BB%8D"><span class="toc-number">4.2.</span> <span class="toc-text">02.Ribbon介绍</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-LoadBalanced%E5%8E%9F%E7%90%86"><span class="toc-number">4.2.1.</span> <span class="toc-text">2.1 @LoadBalanced原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-%E8%8E%B7%E5%8F%96%E6%9C%8D%E5%8A%A1%E5%AE%9E%E4%BE%8B%E5%88%97%E8%A1%A8"><span class="toc-number">4.2.2.</span> <span class="toc-text">2.2 获取服务实例列表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-%E5%8A%A8%E6%80%81%E6%9B%B4%E6%96%B0%E6%9C%8D%E5%8A%A1%E5%AE%9E%E4%BE%8B%E5%88%97%E8%A1%A8"><span class="toc-number">4.2.3.</span> <span class="toc-text">2.3 动态更新服务实例列表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-4-%E5%AF%B9%E6%9C%8D%E5%8A%A1%E8%BF%9B%E8%A1%8C%E5%BF%83%E8%B7%B3%E6%A3%80%E6%B5%8B"><span class="toc-number">4.2.4.</span> <span class="toc-text">2.4 对服务进行心跳检测</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-5-%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E8%B0%83%E5%BA%A6%E5%99%A8"><span class="toc-number">4.2.5.</span> <span class="toc-text">2.5 负载均衡调度器</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#04-Hystrix%E7%86%94%E6%96%AD"><span class="toc-number">5.</span> <span class="toc-text">04.Hystrix熔断</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#01-%E8%83%8C%E6%99%AF%E4%BB%8B%E7%BB%8D"><span class="toc-number">5.1.</span> <span class="toc-text">01.背景介绍</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-%E6%9C%8D%E5%8A%A1%E9%9B%AA%E5%B4%A9"><span class="toc-number">5.1.1.</span> <span class="toc-text">1.1 服务雪崩</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-%E5%BC%95%E8%B5%B7%E9%9B%AA%E5%B4%A9%E7%9A%84%E5%8E%9F%E5%9B%A0"><span class="toc-number">5.1.2.</span> <span class="toc-text">1.2 引起雪崩的原因</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-3-%E8%A7%A3%E5%86%B3%E9%9B%AA%E5%B4%A9%E7%9A%84%E6%96%B9%E6%A1%88"><span class="toc-number">5.1.3.</span> <span class="toc-text">1.3 解决雪崩的方案</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#02-%E6%9C%8D%E5%8A%A1%E7%86%94%E6%96%AD%E4%B8%8E%E6%9C%8D%E5%8A%A1%E9%99%8D%E7%BA%A7"><span class="toc-number">5.2.</span> <span class="toc-text">02.服务熔断与服务降级</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-%E4%BB%80%E4%B9%88%E6%98%AF%E6%9C%8D%E5%8A%A1%E7%86%94%E6%96%AD"><span class="toc-number">5.2.1.</span> <span class="toc-text">2.1 什么是服务熔断</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-%E6%9C%8D%E5%8A%A1%E7%86%94%E6%96%AD%E7%9A%84%E5%8E%9F%E7%90%86"><span class="toc-number">5.2.2.</span> <span class="toc-text">2.2 服务熔断的原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-%E6%9C%8D%E5%8A%A1%E9%99%8D%E7%BA%A7"><span class="toc-number">5.2.3.</span> <span class="toc-text">2.3 服务降级</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#03-Hystrix"><span class="toc-number">5.3.</span> <span class="toc-text">03.Hystrix</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-Hystrix%E7%AE%80%E4%BB%8B"><span class="toc-number">5.3.1.</span> <span class="toc-text">3.1 Hystrix简介</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-%E6%9C%8D%E5%8A%A1%E6%8F%90%E4%BE%9B%E6%96%B9%E9%99%8D%E7%BA%A7"><span class="toc-number">5.3.2.</span> <span class="toc-text">3.2 服务提供方降级</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3-%E6%9C%8D%E5%8A%A1%E6%B6%88%E8%B4%B9%E6%96%B9%E9%99%8D%E7%BA%A7"><span class="toc-number">5.3.3.</span> <span class="toc-text">3.3 服务消费方降级</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#05-Turbine%E7%9B%91%E6%8E%A7"><span class="toc-number">6.</span> <span class="toc-text">05.Turbine监控</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#01-Turbine"><span class="toc-number">6.1.</span> <span class="toc-text">01.Turbine</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-Turbine%E4%BB%8B%E7%BB%8D"><span class="toc-number">6.1.1.</span> <span class="toc-text">1.1 Turbine介绍</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">6.1.2.</span> <span class="toc-text">1.2 使用场景</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#06-ZUUL%E7%BD%91%E5%85%B3"><span class="toc-number">7.</span> <span class="toc-text">06.ZUUL网关</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#01-%E7%BD%91%E5%85%B3%E4%BB%8B%E7%BB%8D"><span class="toc-number">7.1.</span> <span class="toc-text">01.网关介绍</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84-%E4%B8%8D%E8%B6%B3"><span class="toc-number">7.1.1.</span> <span class="toc-text">1.1 微服务架构-不足</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-%E4%B8%8A%E9%9D%A2%E6%9E%B6%E6%9E%84%E9%97%AE%E9%A2%98"><span class="toc-number">7.1.2.</span> <span class="toc-text">1.2 上面架构问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-3-%E7%BD%91%E5%85%B3%E4%B8%BB%E8%A6%81%E5%8A%9F%E8%83%BD"><span class="toc-number">7.1.3.</span> <span class="toc-text">1.3 网关主要功能</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-4-%E5%BC%80%E6%BA%90%E7%BD%91%E5%85%B3%E6%9C%8D%E5%8A%A1"><span class="toc-number">7.1.4.</span> <span class="toc-text">1.4 开源网关服务</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#02-zuul"><span class="toc-number">7.2.</span> <span class="toc-text">02.zuul</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-Zuul%E4%B8%8ENginx%E9%85%8D%E5%90%88"><span class="toc-number">7.2.1.</span> <span class="toc-text">2.1 Zuul与Nginx配合</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-Zuul-1-0"><span class="toc-number">7.2.2.</span> <span class="toc-text">2.2 Zuul 1.0</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-Zuul-2-0%E6%96%B0%E7%89%B9%E6%80%A7"><span class="toc-number">7.2.3.</span> <span class="toc-text">2.3 Zuul 2.0新特性</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#07-Config%E9%85%8D%E7%BD%AE%E4%B8%AD%E5%BF%83"><span class="toc-number">8.</span> <span class="toc-text">07.Config配置中心</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#01-%E9%85%8D%E7%BD%AE%E4%B8%AD%E5%BF%83%E4%BB%8B%E7%BB%8D"><span class="toc-number">8.1.</span> <span class="toc-text">01.配置中心介绍</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-%E9%85%8D%E7%BD%AE%E4%B8%AD%E5%BF%83"><span class="toc-number">8.1.1.</span> <span class="toc-text">1.1 配置中心</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-%E9%85%8D%E7%BD%AE%E4%B8%AD%E5%BF%83%E4%B8%89%E4%B8%AA%E8%A7%92%E8%89%B2"><span class="toc-number">8.1.2.</span> <span class="toc-text">1.2 配置中心三个角色</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#08-Skywalking%E8%B0%83%E7%94%A8%E9%93%BE"><span class="toc-number">9.</span> <span class="toc-text">08.Skywalking调用链</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#01-%E8%B0%83%E7%94%A8%E5%B7%A5%E5%85%B7%E9%93%BE"><span class="toc-number">9.1.</span> <span class="toc-text">01.调用工具链</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-%E8%B0%83%E7%94%A8%E7%94%A8%E5%B7%A5%E5%85%B7%E9%93%BE%E5%AF%B9%E6%AF%94"><span class="toc-number">9.1.1.</span> <span class="toc-text">1.1 调用用工具链对比</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-%E5%89%8D%E8%A8%80"><span class="toc-number">9.1.2.</span> <span class="toc-text">1.2 前言</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-3-%E8%B0%83%E7%94%A8%E9%93%BE%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="toc-number">9.1.3.</span> <span class="toc-text">1.3 调用链的作用</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#02-%E8%B0%83%E7%94%A8%E9%93%BE%E6%A0%87%E5%87%86"><span class="toc-number">9.2.</span> <span class="toc-text">02.调用链标准</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-%E5%88%86%E5%B8%83%E5%BC%8F%E8%B0%83%E7%94%A8%E9%93%BE%E6%A0%87%E5%87%86"><span class="toc-number">9.2.1.</span> <span class="toc-text">2.1 分布式调用链标准</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-%E8%B0%83%E7%94%A8%E9%93%BE%E5%9B%BE%E8%A7%A3"><span class="toc-number">9.2.2.</span> <span class="toc-text">2.2 调用链图解</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#03-SkyWalking%E7%BB%93%E6%9E%84%E8%AE%BE%E8%AE%A1"><span class="toc-number">9.3.</span> <span class="toc-text">03.SkyWalking结构设计</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-skywalking%E7%9A%84%E5%B7%A5%E4%BD%9C%E6%9C%BA%E5%88%B6"><span class="toc-number">9.3.1.</span> <span class="toc-text">3.1 skywalking的工作机制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-SkyWalking-%E6%A0%B8%E5%BF%83%E6%A8%A1%E5%9D%97%E4%BB%8B%E7%BB%8D"><span class="toc-number">9.3.2.</span> <span class="toc-text">3.2 SkyWalking 核心模块介绍</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#04-SkyWalking%E5%8E%9F%E7%90%86"><span class="toc-number">9.4.</span> <span class="toc-text">04.SkyWalking原理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-%E8%87%AA%E5%8A%A8%E9%87%87%E9%9B%86-span-%E6%95%B0%E6%8D%AE"><span class="toc-number">9.4.1.</span> <span class="toc-text">4.1 自动采集 span 数据</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-%E8%B7%A8%E8%BF%9B%E7%A8%8B%E4%BC%A0%E9%80%92-context"><span class="toc-number">9.4.2.</span> <span class="toc-text">4.2 跨进程传递 context</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-3-traceId%E4%BF%9D%E8%AF%81%E5%85%A8%E5%B1%80%E5%94%AF%E4%B8%80"><span class="toc-number">9.4.3.</span> <span class="toc-text">4.3 traceId保证全局唯一</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-4-%E5%85%A8%E9%83%A8%E9%87%87%E9%9B%86%E6%80%A7%E8%83%BD%E5%A6%82%E4%BD%95"><span class="toc-number">9.4.4.</span> <span class="toc-text">4.4 全部采集性能如何</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#05-Skywalking-Agent%E5%8E%9F%E7%90%86"><span class="toc-number">9.5.</span> <span class="toc-text">05.Skywalking Agent原理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#5-1-Java-Agent"><span class="toc-number">9.5.1.</span> <span class="toc-text">5.1 Java Agent</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8-Java-Agent-%E7%9A%84%E6%AD%A5%E9%AA%A4%E5%A4%A7%E8%87%B4%E5%A6%82%E4%B8%8B-1%EF%BC%89%E5%AE%9A%E4%B9%89%E4%B8%80%E4%B8%AA-MANIFEST-MF-%E6%96%87%E4%BB%B6%EF%BC%8C%E5%9C%A8%E5%85%B6%E4%B8%AD%E6%B7%BB%E5%8A%A0-premain-class-%E9%85%8D%E7%BD%AE%E9%A1%B9-2%EF%BC%89%E5%88%9B%E5%BB%BA-premain-class-%E9%85%8D%E7%BD%AE%E9%A1%B9%E6%8C%87%E5%AE%9A%E7%9A%84%E7%B1%BB%EF%BC%8C%E5%B9%B6%E5%9C%A8%E5%85%B6%E4%B8%AD%E5%AE%9E%E7%8E%B0-premain-%E6%96%B9%E6%B3%95%EF%BC%8C%E6%96%B9%E6%B3%95%E7%AD%BE%E5%90%8D%E5%A6%82%E4%B8%8B"><span class="toc-number">9.6.</span> <span class="toc-text">使用 Java Agent 的步骤大致如下-  1）定义一个 MANIFEST.MF 文件，在其中添加 premain-class 配置项-  2）创建 premain-class 配置项指定的类，并在其中实现 premain() 方法，方法签名如下 </span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#5-2-%E6%8E%A2%E9%92%88"><span class="toc-number">9.6.1.</span> <span class="toc-text">5.2 探针</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-3-%E6%9C%8D%E5%8A%A1%E8%87%AA%E5%8A%A8%E6%89%93%E7%82%B9%E4%BB%A3%E7%90%86"><span class="toc-number">9.6.2.</span> <span class="toc-text">5.3 服务自动打点代理</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#09-skywalking%E5%AE%89%E8%A3%85"><span class="toc-number">10.</span> <span class="toc-text">09.skywalking安装</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#01-skywalking%E5%AE%89%E8%A3%85"><span class="toc-number">10.1.</span> <span class="toc-text">01.skywalking安装</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-%E4%B8%8B%E8%BD%BD%E5%AF%B9%E5%BA%94%E7%89%88%E6%9C%AC"><span class="toc-number">10.1.1.</span> <span class="toc-text">1.1 下载对应版本</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#02-%E5%AE%89%E8%A3%85ES"><span class="toc-number">10.2.</span> <span class="toc-text">02.安装ES</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-%E9%85%8D%E7%BD%AE%E6%89%80%E6%9C%89%E8%80%85"><span class="toc-number">10.2.1.</span> <span class="toc-text">2.1 配置所有者</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-%E4%BF%AE%E6%94%B9%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6"><span class="toc-number">10.2.2.</span> <span class="toc-text">2.2 修改配置文件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-%E5%90%AF%E5%8A%A8%E5%B9%B6%E8%AE%BF%E9%97%AE"><span class="toc-number">10.2.3.</span> <span class="toc-text">2.3 启动并访问</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#03-%E5%AE%89%E8%A3%85Skywalking%E6%9C%8D%E5%8A%A1"><span class="toc-number">10.3.</span> <span class="toc-text">03.安装Skywalking服务</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-%E6%9B%BF%E6%8D%A2%E5%AD%98%E5%82%A8%E4%B8%BAES"><span class="toc-number">10.3.1.</span> <span class="toc-text">3.1 替换存储为ES</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-%E4%BF%AE%E6%94%B9%E7%AB%AF%E5%8F%A3"><span class="toc-number">10.3.2.</span> <span class="toc-text">3.2 修改端口</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3-%E5%BC%80%E6%94%BE%E7%AB%AF%E5%8F%A3%E5%B9%B6%E5%90%AF%E5%8A%A8%E6%9C%8D%E5%8A%A1"><span class="toc-number">10.3.3.</span> <span class="toc-text">3.3 开放端口并启动服务</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#10-skywalking%E4%BD%BF%E7%94%A8"><span class="toc-number">11.</span> <span class="toc-text">10.skywalking使用</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#01-skywalking-python"><span class="toc-number">11.1.</span> <span class="toc-text">01.skywalking-python</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-0-%E5%8F%82%E8%80%83"><span class="toc-number">11.1.1.</span> <span class="toc-text">1.0 参考</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-%E5%AE%89%E8%A3%85"><span class="toc-number">11.1.2.</span> <span class="toc-text">1.1 安装</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-%E4%BD%BF%E7%94%A8%E6%B5%8B%E8%AF%95"><span class="toc-number">11.1.3.</span> <span class="toc-text">1.2 使用测试</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#11-ServiceMesh"><span class="toc-number">12.</span> <span class="toc-text">11.ServiceMesh</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#01-%E5%BE%AE%E6%9C%8D%E5%8A%A1%E9%97%AE%E9%A2%98"><span class="toc-number">12.1.</span> <span class="toc-text">01.微服务问题</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%AE%9E%E7%8E%B0%E6%B5%81%E7%A8%8B"><span class="toc-number">12.1.1.</span> <span class="toc-text">1.1 微服务实现流程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-%E5%BE%AE%E6%9C%8D%E5%8A%A1%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98"><span class="toc-number">12.1.2.</span> <span class="toc-text">1.2 微服务遇到的问题</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#02-Service-Mesh%E5%AE%9E%E7%8E%B0"><span class="toc-number">12.2.</span> <span class="toc-text">02.Service Mesh实现</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-Service-Mesh%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-number">12.2.1.</span> <span class="toc-text">2.1 Service Mesh是什么</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-Service-Mesh%E7%BD%91%E6%A0%BC"><span class="toc-number">12.2.2.</span> <span class="toc-text">2.2 Service Mesh网格</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-ServiceMesh%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE"><span class="toc-number">12.2.3.</span> <span class="toc-text">2.3 ServiceMesh开源项目</span></a></li></ol></li></ol></li></ol>
      </div>
      
        <div class="catelogue catelogue-2">
          
            <p>
              <span>上一篇：</span>
              <a href="/2024/09/01/nginx1/"></a>
            </p>
           
          
            <p>
              <span>下一篇</span>
              <a href="/2024/09/01/galera/"></a>
            </p>
          
        </div>
      
    </div>
  </div>
</div>


<script>
  // var定义，避免pjax重新进来造成的重复声明错误
  var config = JSON.parse('{"enable":true,"appId":"Pf8zCXGEH1qsprnWfikVVujL-gzGzoHsz","appKey":"qOqoiUHhH1TGtLRUYURkLRQX","placeholder":"请留下你宝贵的意见吧~","meta":["nick"],"recordIP":true,"visitor":true,"enableQQ":true}')
  new Valine({
    el: '#vcomments',
    appId: config.appId,
    appKey: config.appKey,
    placeholder: config.placeholder,
    meta: config.meta,
    recordIP: config.recordIP,
    visitor: config.visitor,
    enableQQ: config.enableQQ,
    path: '2024/09/01/微服务概念/'
  })
</script>


<script>
  $(document).on('pjax:complete', function() {
    const tocs = document.querySelector('.toc')
    const links = tocs ? tocs.querySelectorAll('a') : []
    links.forEach(link => {
      link.addEventListener('click', e => {
        const href = decodeURIComponent(e.href)
        href.search(/#(.*)/)
        const id = RegExp.$1
        const target = document.querySelector('#' + id)
        const top = target.offsetTop
        document.documentElement.scrollTo({
          top: top - 100,
          behavior: 'smooth'
        })
        e.preventDefault()
      })
    })
  })
</script> 

</div>
      <div class="main-right-wrapper"><div class="main-right">
  <div class="main-right--board">
    <div class="main-right--title">
      <h5>公告栏</h5>
      <i class="iconfont icon-gonggao"></i>
    </div>
    <div class="main-right--content">
      Hello~大噶好。唔系小曹宅，欢迎你们来到我的博客小站，希望能在这里收获到有用的东西哦！ 
    </div>
  </div>

  <div id="aplayer" class="main-right--music"></div>

  <div class="operate-items">
    <div class="operate-item backtop">
      <i class="iconfont icon-huidaodingbu"></i>
      <span>回到顶部</span>
    </div>
    
    <div class="operate-item turn-comment hidden">
      <i class="iconfont icon-pinglun"></i>
      <span>查看评论</span>
    </div>
    
  </div>

  <div class="main-right--site">
    <div class="main-right--power">
      <p>Power By <a target="_blank" rel="noopener" href="https://hexo.io/zh-cn/docs/">Hexo</a>.</p>
      <p>Theme：<a target="_blank" rel="noopener" href="https://github.com/Aizener/hexo-theme-cola">Cola.</a></p>
    </div>
    <p class="main-right--refer"><a target="_blank" rel="noopener" href="https://beian.miit.gov.cn/#/Integrated/index">2262690094</a> </p>
  </div>
</div>

<script>
  function setOperateItem () {
    const reg = /\d{4}\/\d{2}\/\d{2}\/.+/
    const path = location.pathname
    const operateDom = document.querySelector('.main-right .operate-items')
    const commentDom = document.querySelector('.turn-comment')
    const cateloguDom = document.querySelector('.article-catelogue > .article-catelogue--wrapper');

    if (commentDom) {
      if (reg.test(path) || path.match(/\/log\/.+/)) {
        commentDom.classList.remove('hidden')
        const newDom = operateDom.cloneNode(true);
        const _backtopDom = newDom.querySelector('.backtop');
        const _commentDom = newDom.querySelector('.turn-comment');
        _backtopDom.addEventListener('click', () => backTopEvent());
        _commentDom.addEventListener('click', () => commentDomEvent());
        cateloguDom.appendChild(newDom);
      } else {
        commentDom.classList.add('hidden')
      }
    }
  }

  setOperateItem()
  const musics = JSON.parse(`[{"name":"不找了","artist":"隔壁老樊","url":"music/隔壁老樊 - 不找了.mp3","cover":"https://img2.baidu.com/it/u=1260056724,1076343118&fm=253&fmt=auto&app=138&f=JPEG?w=500&h=500"},{"name":"于是天气刚好","artist":"泪桥","url":"music/于是天气刚好 - 泪桥.mp3","cover":"https://img2.baidu.com/it/u=705831265,2862720033&fm=253&fmt=auto&app=138&f=JPEG?w=500&h=500"},{"name":"安和桥","artist":"林芬宇","url":"music/林芬宇 - 安和桥.mp3","cover":"https://encrypted-tbn0.gstatic.com/images?q=tbn:ANd9GcQo0SWQx6YrNA8lElaG4OOKLkNkNzLO1PflKg&usqp=CAU"}]`)
  const ap = new APlayer({
    container: document.querySelector('#aplayer'),
    audio: musics,
  })

  $(document).on('pjax:complete', function() {
    setOperateItem()
  })

  document.querySelector('.backtop').addEventListener('click', () => {
    backTopEvent();
  })
  const dom = document.querySelector('.turn-comment')
  dom && dom.addEventListener('click', () => {
    commentDomEvent();
  })

  function backTopEvent() {
    document.documentElement.scrollTo({
      top: 0,
      behavior: 'smooth'
    })
  }

  function commentDomEvent() {
    const commentDom = document.querySelector('.comments-intro')
    if (!commentDom) return
    const top = commentDom.offsetTop, height = commentDom.offsetHeight
    document.documentElement.scrollTo({
      top: top - 2 * height,
      behavior: 'smooth'
    })
  }
</script></div>
    </section>
  </div>
  <div id="progress" class="progress"></div>
  <div id="gray" class="gray"></div>

  <script>
    function initScroll () {
      document.addEventListener('scroll', () => {
        const doc = document.documentElement
        const scrollTop = doc.scrollTop
        const pageHeight = doc.offsetHeight
        const clientHeight = doc.clientHeight
        const ratio = scrollTop / (pageHeight - clientHeight)
        const progress = document.querySelector('#progress')
        const avatarImg = document.querySelector('.main-left--avatar')
        progress.style.width = (100 * ratio) + '%'
        avatarImg.style.transform = `rotate(${360 * ratio}deg)`
      })
    }

    const rootPath = "/"

    const checkAndSetArticlePageLayout = () => {
      const path = location.pathname.replace(rootPath, '');
      if (
        /^\/?\d{4}\/\d{2}\/\d{2}\/.*/.test(path) ||
        /^log\/.+/.test(path)
      ) {
        $('.main-container, .main-right, .main-right-wrapper').addClass('is-article')
      } else {
        $('.main-container, .main-right, .main-right-wrapper').removeClass('is-article')
      }
    }

    const gray = "none"
    const setGrayStyle = () => {
      if (gray === 'none') {
        return
      } else if (gray === 'index') {
        location.pathname === '/' ? $('#gray').show() : $('#gray').hide()
      } else if (gray === 'all') {
        $('#gray').show()
      }
    }
    setGrayStyle()


    window.onload = function () {
      checkAndSetArticlePageLayout()
      setTimeout(() => {
        $('#load').slideUp()
        $('#container').slideToggle()
        setTimeout(() => {
          initScroll();
        }, 500)
      }, 500)
    }
    
    let status = 0
    // 对所有链接跳转事件绑定pjax容器container
    $(document).pjax('a[target!=_blank]', '#main-container', {
      container: '#main-container',
      fragment: '#main-container',
      timeout: 8000
    })

    $(document).on('pjax:start', function() {
    })
    $(document).on('pjax:complete', function() {
      status = 0
      $('.main-container').addClass('to-up').on('animationend', function() {
        $(this).removeClass('to-up')
      })
      setGrayStyle()
      checkAndSetArticlePageLayout()
    })
    $(document).on('pjax:popstate', function() {
      status = -1
      checkAndSetArticlePageLayout()
    });
  </script>
</body>
</html>