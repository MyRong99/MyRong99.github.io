<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>我的技术与生活——PQL | Mr.Long</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <link rel="shortcut icon" href="/imgs/shortcut-icon.ico" type="image/x-icon">
  <link rel="stylesheet" href="/css/public.css" />
  <link rel="stylesheet" href="/css/layout.css" />
  <link rel="stylesheet" href="/css/iconfont.css" />
  <link rel="stylesheet" href="/css/APlayer.min.css" />
  <script src="/js/APlayer.min.js"></script>
  <script src="/js/jquery.min.js"></script>
  <script src="/js/jquery.pjax.min.js"></script>

  <script src='//unpkg.com/valine/dist/Valine.min.js'></script>
  <script>
    document.title = `我的技术与生活——PQL`
  </script>
<meta name="generator" content="Hexo 7.3.0"></head>

<style>
  .load {
    width: 100%;
    height: 100vh;
    background-color: rgb(37, 35, 40);
    display: flex;
    flex-direction: column;
    justify-content: center;
    align-items: center;
    position: relative;
    z-index: 9999;
  }
  .load-circle {
    width: 80px;
    height: 80px;
    border: 8px solid orange;
    border-bottom-color: transparent;
    border-radius: 50%;
    display: flex;
    justify-content: center;
    align-items: center;
    animation: rotate 1s linear infinite;
    filter: drop-shadow(0 0 3px orange);
  }
  .load-circle-inner {
    width: 40px;
    height: 40px;
    border: 8px solid orange;
    border-top-color: transparent;
    border-radius: 50%;
    animation: rotate-reverse .5s linear infinite;
  }
  .load-text {
    margin-top: 20px;
    font-size: 24px;
    color: orange;
    display: flex;
  }
  .load-text span {
    margin: 0 5px;
    text-shadow: 5px 5px 5px orange;
    animation: move 1s linear infinite;
  }
  .load-text span:nth-child(1) {
    animation-delay: -0.6s;
  }
  .load-text span:nth-child(2) {
    animation-delay: -0.5s;
  }
  .load-text span:nth-child(3) {
    animation-delay: -0.4s;
  }
  .load-text span:nth-child(4) {
    animation-delay: -0.3s;
  }
  .load-text span:nth-child(5) {
    animation-delay: -0.2s;
  }
  .load-text span:nth-child(6) {
    animation-delay: -0.1s;
  }
  @keyframes rotate {
    0% { transform: rotate(0); }
    100% { transform: rotate(360deg); }
  }
  @keyframes rotate-reverse {
    0% { transform: rotate(0); }
    100% { transform: rotate(-360deg); }
  }
  @keyframes move {
    0% { transform: translateY(0%) rotate(0) scale(1); }
    20% { transform: translateY(20%) rotate(10deg) scale(1.2); }
    80% { transform: translateY(-10%) rotate(-20deg) scale(.8);}
    100% { transform: translateY(0) rotate(0) scale(1); }
  }

  .progress {
    position: fixed;
    left: 0; top: 0;
    width: 0;
    height: 3px;
    background-color: green;
    transition: all cubic-bezier(0.215, 0.610, 0.355, 1) .1s;
    z-index: 9999;
  }

  .to-up {
    animation: toUp .5s 1;
  }
  .gray {
    position: fixed;
    left: 0;
    top: 0;
    width: 100%;
    height: 100vh;
    z-index: 9999;
    display: none;
    pointer-events: none;
    background-color: #000;
    mix-blend-mode: color;
  }
  @keyframes toUp {
    from { transform: translateY(15px); opacity: 0; }
    to { transform: translateY(0) ; opacity: 1; }
  }
</style>
<body>
  <div id="load" class="load">
    <div class="load-circle">
      <div class="load-circle-inner"></div>
    </div>
    <p class="load-text">
      <span>L</span>
      <span>O</span>
      <span>A</span>
      <span>D</span>
      <span>I</span>
      <span>N</span>
      <span>G</span>
    </p>
  </div>
  <div id="container" class="container w-100 vh-100" style="display: none;">
    <header class="header">
  <div class="header-wrapper">
    <div class="header-left">
      <div class="header-search">
        <input id="search-input" type="text" class="header-search--input" placeholder="请输入要检索的文章标题" />
        <span id="search-btn" class="header-search--icon"><i class="iconfont icon-sousuo"></i></span>
      </div>
      <div id="search-layer" class="header-search--layer hidden">
        <p class="title">
          <span>以下是搜索内容：</span>
          <span id="close-layer-btn">关闭</span>
        </p>
        <ul>
        </ul>
      </div>
    </div>
    <div class="header-right">
      <ul class="header-menu">
        <li>
          <a href="http://example.com/">
            <i class="header-menu--icon iconfont icon-shouye"></i>
            <span class="header-menu--span">首页</span>
          </a>
        </li>
        <li>
          <a href="http://example.com/log">
            <i class="header-menu--icon iconfont icon-rizhi"></i>
            <span class="header-menu--span">日志</span>
          </a>
        </li>
        <li>
          <a href="http://example.com/link">
            <i class="header-menu--icon iconfont icon-youqinglianjie"></i>
            <span class="header-menu--span">友情链接</span>
          </a>
        </li>
        <li>
          <a href="http://example.com/about">
            <i class="header-menu--icon iconfont icon-guanyuwomen"></i>
            <span class="header-menu--span">关于我</span>
          </a>
        </li>
      </ul>
    </div>
  </div>
</header>

<script>
  const ipt = document.querySelector('#search-input')
  const btn = document.querySelector('#search-btn')
  const layer = document.querySelector('#search-layer')
  const posts = JSON.parse(`[{"title":"docker命令","cover":"https://haowallpaper.com/link/common/file/getCroppingImg/71e27d1e01da8c13f3f165a1c3bcc8b571e27d1e01da8c13f3f165a1c3bcc8b5","path":"2024/03/21/Docker命令大全/"},{"title":"Kubernetes扩展","cover":"https://haowallpaper.com/link/common/file/getCroppingImg/2e0af7de62ed4210b634c867367c10ae2e0af7de62ed4210b634c867367c10ae","path":"2024/06/01/Kubernetes容器编排技术[扩展]/"},{"title":"LVM逻辑卷管理","cover":"https://haowallpaper.com/link/common/file/getCroppingImg/d733537fd3e06784932826b5e82a855d","path":"2023/06/28/LVM逻辑卷管理/"},{"title":"LV移除、缩容","cover":"https://haowallpaper.com/link/common/file/getCroppingImg/d733537fd3e06784932826b5e82a855d","path":"2023/06/14/LV逻辑卷扩展/"},{"title":"PXE+Kickstart无人值守安装操作系统","cover":"https://haowallpaper.com/link/common/file/getCroppingImg/82cb48f718f8acc8cb2568140eeaaec382cb48f718f8acc8cb2568140eeaaec3","path":"2023/06/26/PXE+Kickstart无人值守安装操作系统/"},{"title":"python一","cover":"https://haowallpaper.com/link/common/file/getCroppingImg/15096963228077376","path":"2024/02/20/Python1/"},{"title":"python三","cover":"https://haowallpaper.com/link/common/file/getCroppingImg/15096963228077376","path":"2024/02/25/Python3/"},{"title":"PQL","cover":"https://haowallpaper.com/link/common/file/getCroppingImg/240007b00ab1bcd1e3af7bb55f18a966","path":"2024/06/30/PromQL 讲解/"},{"title":"python二","cover":"https://haowallpaper.com/link/common/file/getCroppingImg/15096963228077376","path":"2024/02/21/Python2/"},{"title":"TCP协议","cover":"https://haowallpaper.com/link/common/file/getCroppingImg/15047394039467328","path":"2023/06/23/TCP协议/"},{"title":"python四","cover":"https://haowallpaper.com/link/common/file/getCroppingImg/15096963228077376","path":"2024/03/01/Python4/"},{"title":"Kubernetes组件学习","cover":"https://haowallpaper.com/link/common/file/getCroppingImg/2e0af7de62ed4210b634c867367c10ae2e0af7de62ed4210b634c867367c10ae","path":"2024/06/02/Kubernetes组件/"},{"title":"docker容器","cover":"https://haowallpaper.com/link/common/file/getCroppingImg/71e27d1e01da8c13f3f165a1c3bcc8b571e27d1e01da8c13f3f165a1c3bcc8b5","path":"2024/03/11/docker容器/"},{"title":"FTP文件服务器","cover":"https://haowallpaper.com/link/common/file/getCroppingImg/a9045286aa9b50dcc09302eff83b328a","path":"2023/06/23/ftp/"},{"title":"Galera集群","cover":"https://haowallpaper.com/link/common/file/getCroppingImg/3719037aa1a43c4806d84ac9bd3dbc34","path":"2024/07/26/galera/"},{"title":"redis操作","cover":"https://haowallpaper.com/link/common/file/getCroppingImg/a13d778b5db38e4b127b71bdf122f695","path":"2023/09/26/Redis操作/"},{"title":"ansible模块","cover":"https://haowallpaper.com/link/common/file/getCroppingImg/1e624a7ba7e09f195b3f2f384b2b9bb1","path":"2023/08/17/ansible 模块扩展/"},{"title":"Kubernetes数据库","cover":"https://haowallpaper.com/link/common/file/getCroppingImg/2e0af7de62ed4210b634c867367c10ae2e0af7de62ed4210b634c867367c10ae","path":"2024/06/14/k8s集群数据库/"},{"title":"nginx2","cover":"https://haowallpaper.com/link/common/file/getCroppingImg/8c29198625ff99eee0073bbbb137bbc78c29198625ff99eee0073bbbb137bbc7","path":"2023/12/19/nginx2/"},{"title":"nginx3","cover":"https://haowallpaper.com/link/common/file/getCroppingImg/8c29198625ff99eee0073bbbb137bbc78c29198625ff99eee0073bbbb137bbc7","path":"2023/12/22/nginx3/"},{"title":"nginx1","cover":"https://haowallpaper.com/link/common/file/getCroppingImg/8c29198625ff99eee0073bbbb137bbc78c29198625ff99eee0073bbbb137bbc7","path":"2023/12/17/nginx1/"},{"title":"nginx5","cover":"https://haowallpaper.com/link/common/file/getCroppingImg/8c29198625ff99eee0073bbbb137bbc78c29198625ff99eee0073bbbb137bbc7","path":"2023/12/31/nnginx5/"},{"title":"nginx4","cover":"https://haowallpaper.com/link/common/file/getCroppingImg/8c29198625ff99eee0073bbbb137bbc78c29198625ff99eee0073bbbb137bbc7","path":"2023/12/30/nginx4/"},{"title":"redis集群安装","cover":"https://haowallpaper.com/link/common/file/getCroppingImg/a13d778b5db38e4b127b71bdf122f695","path":"2023/09/21/redis集群/"},{"title":"shell脚本","cover":"https://haowallpaper.com/link/common/file/getCroppingImg/9217d5c6d87ce0e8ec7422ca7469db95","path":"2024/08/10/shell脚本/"},{"title":"prometheus","cover":"https://haowallpaper.com/link/common/file/getCroppingImg/240007b00ab1bcd1e3af7bb55f18a966","path":"2024/06/16/prometheus 监控/"},{"title":"shell编程","cover":"https://haowallpaper.com/link/common/file/getCroppingImg/9217d5c6d87ce0e8ec7422ca7469db95","path":"2023/07/21/shell_newrain/"},{"title":"prometheus-exporter","cover":"https://haowallpaper.com/link/common/file/getCroppingImg/240007b00ab1bcd1e3af7bb55f18a966","path":"2024/06/16/node_exporter/"},{"title":"docker镜像容器","cover":"https://haowallpaper.com/link/common/file/getCroppingImg/71e27d1e01da8c13f3f165a1c3bcc8b571e27d1e01da8c13f3f165a1c3bcc8b5","path":"2024/03/14/容器技术-docker2/"},{"title":"Kubernetes集群部署","cover":"https://haowallpaper.com/link/common/file/getCroppingImg/2e0af7de62ed4210b634c867367c10ae2e0af7de62ed4210b634c867367c10ae","path":"2024/06/10/二进制方式部署k8s集群/"},{"title":"docker-Compose","cover":"https://haowallpaper.com/link/common/file/getCroppingImg/71e27d1e01da8c13f3f165a1c3bcc8b571e27d1e01da8c13f3f165a1c3bcc8b5","path":"2024/03/21/容器技术-docker5/"},{"title":"docker资源限制","cover":"https://haowallpaper.com/link/common/file/getCroppingImg/71e27d1e01da8c13f3f165a1c3bcc8b571e27d1e01da8c13f3f165a1c3bcc8b5","path":"2024/03/15/容器技术docker4/"},{"title":"docker安装","cover":"https://haowallpaper.com/link/common/file/getCroppingImg/71e27d1e01da8c13f3f165a1c3bcc8b571e27d1e01da8c13f3f165a1c3bcc8b5","path":"2024/03/06/容器技术-Docker1/"},{"title":"docker容器","cover":"https://haowallpaper.com/link/common/file/getCroppingImg/71e27d1e01da8c13f3f165a1c3bcc8b571e27d1e01da8c13f3f165a1c3bcc8b5","path":"2024/03/13/容器技术-docker3/"},{"title":"linux文件管理","cover":"https://haowallpaper.com/link/common/file/getCroppingImg/de0f7b079a80d192f90989d9c2c9622d","path":"2023/06/21/文件管理/"},{"title":"用户文件权限","cover":"https://haowallpaper.com/link/common/file/getCroppingImg/3719037aa1a43c4806d84ac9bd3dbc34","path":"2023/06/01/文件权限/"},{"title":"单用户模式破解密码","cover":"https://haowallpaper.com/link/common/file/getCroppingImg/3f6ae566e1f093d2d9dbcc3df361fc4b3f6ae566e1f093d2d9dbcc3df361fc4b","path":"2023/07/01/破解密码/"},{"title":"微服务项目","cover":"https://haowallpaper.com/link/common/file/getCroppingImg/3719037aa1a43c4806d84ac9bd3dbc34","path":"2024/07/26/微服务项目-mall-swarm/"},{"title":"存储管理--1","cover":"https://haowallpaper.com/link/common/file/getCroppingImg/d733537fd3e06784932826b5e82a855d","path":"2023/06/25/磁盘存储管理1/"},{"title":"磁盘阵列","cover":"https://haowallpaper.com/link/common/file/getCroppingImg/69d9906ff9bf88dbc02184ecb8504fc5","path":"2023/07/09/磁盘阵列RAID/"},{"title":"prometheus自定义监控","cover":"https://haowallpaper.com/link/common/file/getCroppingImg/240007b00ab1bcd1e3af7bb55f18a966","path":"2024/06/26/自定义监控/"},{"title":"微服务","cover":"https://haowallpaper.com/link/common/file/getCroppingImg/3719037aa1a43c4806d84ac9bd3dbc34","path":"2024/07/26/微服务概念/"},{"title":"Linux网卡","cover":"https://haowallpaper.com/link/common/file/getCroppingImg/346f59e468f2155074d1fb3164594702","path":"2023/06/11/网络管理基础/"},{"title":"自建YUM源","cover":"https://haowallpaper.com/link/common/file/getCroppingImg/56260873f5720f373c20f43587eab0b8","path":"2023/06/21/自建yum源笔记/"},{"title":"Kubernetes蓝鲸智云平台部署","cover":"https://haowallpaper.com/link/common/file/getCroppingImg/2e0af7de62ed4210b634c867367c10ae2e0af7de62ed4210b634c867367c10ae","path":"2024/09/01/蓝鲸智云平台部署/"},{"title":"走进网络世界","cover":"https://haowallpaper.com/link/common/file/getCroppingImg/583716b0cb306203c308cc0def55dd9e583716b0cb306203c308cc0def55dd9e","path":"2023/06/16/走进网络世界/"}]`)
  ipt.addEventListener('keyup', e => {
    if (e.key === 'Enter') {
      handleSearch()
    }
  })
  btn.addEventListener('click', () => {
    handleSearch()
  })

  document.querySelector('#close-layer-btn').addEventListener('click', () => {
    layer.classList.toggle('hidden')
  })

  function handleSearch() {
    if (ipt.value.trim() === '') {
      return
    }
    let html = ''
    const targetPosts = posts.filter(post => post.title.includes(ipt.value))
    targetPosts.forEach(post => {
      html += `
        <li>
          <div>
            <a href="/${post.path}">${post.title.replace(new RegExp(ipt.value), `<span>${ipt.value}</span>`)}</a>
          </div>
          <img src="${post.cover || '/imgs/default-cover.webp' }" />
        </li>
      `
    })
    if (html.trim () === '') {
      html += '<p class="empty">没有搜索到内容</p>'
    }
    layer.querySelector('ul').innerHTML = html
    layer.classList.remove('hidden')
  }
</script> 
    <section id="main" class="main">
      <div class="main-left-wrapper">
<div class="main-left">
  <div class="main-left--block">
    <div class="main-left--info">
      <img src="/imgs/avatar.jpg"" class="main-left--avatar" />
      <div class="main-left--intro">
        <p class="main-left--name">Mr.Long</p>
        <div class="main-left--tags">
          <span class="main-left--tag">唱跳rap篮球</span>
          <span class="main-left--tag">宅但不肥</span>
        </div>
      </div>
    </div>
  
    <div>
      <div class="main-left--motto">
        <p>“花有重开日，人无再少年”</p>
        <p>“一个简单普通的男孩”</p>
      </div>
      <div class="main-left--github">
        <span class="line"></span>
        <a target="_blank" rel="noopener" href="https://github.com/MyRong99/MyRong99.github.io"><i class="logo iconfont icon-github-fill"></i></a>
        <span class="line"></span>
      </div>
      <div class="main-left--statics">
        <a href="/categories">
          <div>
            <span>0</span>
            <span>分类</span>
          </div>
        </a>
        <a href="/tags">
          <div>
            <span>8</span>
            <span>标签</span>
          </div>
        </a>
        <a href="/archives">
          <div>
            <span>11 </span>
            <span>归档</span>
          </div>
        </a>
      </div>
    </div>
  </div>

  <div class="main-left--block">
    <ul class="main-left--menu">
      
        <li>
          <a href="/">
            <span class="header-menu--span">小站首页</span>
            <i class="header-menu--icon iconfont icon-shouye"></i>
          </a>
        </li>
      
        <li>
          <a href="/log">
            <span class="header-menu--span">个人日志</span>
            <i class="header-menu--icon iconfont icon-rizhi"></i>
          </a>
        </li>
      
        <li>
          <a href="/link">
            <span class="header-menu--span">友情链接</span>
            <i class="header-menu--icon iconfont icon-youqinglianjie"></i>
          </a>
        </li>
      
        <li>
          <a href="/about">
            <span class="header-menu--span">关于自己</span>
            <i class="header-menu--icon iconfont icon-guanyuwomen"></i>
          </a>
        </li>
      
        <li>
          <a href="/tools">
            <span class="header-menu--span">我的工具</span>
            <i class="header-menu--icon iconfont icon-gongju"></i>
          </a>
        </li>
      
    </ul>
  </div>

  <div class="main-left--block">
    <div class="main-left--site">
      <h5 class="main-left--title">
        <span>站点信息</span>
        <i class="iconfont icon-zhandian"></i>
      </h5>
      <p class="main-left--subtitle">
        <span>文章数目：</span>
        <span>46 篇</span>
      </p>
      <p class="main-left--subtitle">
        <span>最近动态：</span>
        <span>今天</span>
      </p>
      <p class="main-left--subtitle">
        <span>上线时间：</span>
        <span>439天</span>
      </p>
      <p class="main-left--subtitle">
        <span>当前版本：</span>
        <span>v1.0.2</span>
      </p>
    </div>
  </div>
</div></div>
      <div id="main-container" class="main-container">


  <link rel="stylesheet" href="/css/partial/article.css" />

<div class="article-container">
  <div class="article">
    <h1 class="article-title">PQL</h1>
    <div class="article-info">
      <div class="article-info--item">
        <div class="article-info--info">
          
          <div class="article-info--categories">
            <span>分类：</span>
            
          </div>
          
          
          <div class="article-info--tags">
            <span>标签：</span>
            <a class="tag-link" href="/tags/%E4%BA%91%E5%8E%9F%E7%94%9F/" rel="tag">-云原生</a>
          </div>
          
          <p class="article-info--date">日期：2024-06-30 19:50:56</p>
        </div>
        <img src="https://haowallpaper.com/link/common/file/getCroppingImg/240007b00ab1bcd1e3af7bb55f18a966" alt="" class="article-cover">
      </div>
    </div>
    <article class="article-content markdown-body">
      <p> Prometheus 提供了一种功能表达式语言 PromQL，允许用户实时选择和汇聚<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=%E6%97%B6%E9%97%B4%E5%BA%8F%E5%88%97&spm=1001.2101.3001.7020">时间序列</a>数据。表达式的结果可以在浏览器中显示为图形，也可以显示为表格数据，或者由外部系统通过 <a target="_blank" rel="noopener" href="https://prometheus.io/docs/prometheus/latest/querying/api/">HTTP API</a> 调用。</p>
<h3 id="一、表达式语言数据类型"><a href="#一、表达式语言数据类型" class="headerlink" title="一、表达式语言数据类型"></a>一、表达式语言数据类型</h3><p>在 Prometheus 的表达式语言中，表达式或子表达式包括以下四种类型之一：</p>
<ul>
<li><strong>瞬时向量（Instant vector）</strong> - 一组时间序列，每个时间序列包含单个样本，它们共享相同的时间戳。也就是说，表达式的返回值中只会包含该时间序列中的最新的一个样本值。而相应的这样的表达式称之为瞬时向量表达式。</li>
<li><strong>区间向量（Range vector）</strong> - 一组时间序列，每个时间序列包含一段时间范围内的样本数据。</li>
<li><strong>标量（Scalar）</strong> - 一个浮点型的数据值。</li>
<li><strong>字符串（String）</strong> - 一个简单的字符串值。</li>
</ul>
<p>根据用户输入的表达式返回的数据类型是否合法取决于用例的不同，例如：瞬时向量表达式返回的数据类型是唯一可以直接绘制成图表的数据类型。</p>
<h3 id="二、字面量"><a href="#二、字面量" class="headerlink" title="二、字面量"></a>二、字面量</h3><h4 id="（一）字符串"><a href="#（一）字符串" class="headerlink" title="（一）字符串"></a>（一）字符串</h4><p>字符串可以用单引号、双引号或反引号指定为文字常量。<br>PromQL 遵循与 Go 相同的转义规则。在单引号或双引号中，用反斜杠来表示转义序列，后面可以跟 a, b, f, n, r, t, v 或 \。特殊字符可以使用八进制（\nnn）或者十六进制（\xnn，\unnnn 和 \Unnnnnnnn）。<br>与 Go 不同，Prometheus 不会对反引号内的换行符进行转义。<br>例如：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;this is a string&quot;</span></span><br><span class="line"><span class="string">&#x27;these are unescaped: \n \\ \t&#x27;</span></span><br><span class="line">`these are not unescaped: \n <span class="string">&#x27; &quot; \t`</span></span><br></pre></td></tr></table></figure>

<h4 id="（二）标量"><a href="#（二）标量" class="headerlink" title="（二）标量"></a>（二）标量</h4><p>标量浮点值可以字面上写成 <a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_45880055/article/details/digits">-</a>[.(digits)] 的形式。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-2.43</span><br></pre></td></tr></table></figure>

<h3 id="三、时间序列过滤器"><a href="#三、时间序列过滤器" class="headerlink" title="三、时间序列过滤器"></a>三、时间序列过滤器</h3><h4 id="（一）瞬时向量过滤器"><a href="#（一）瞬时向量过滤器" class="headerlink" title="（一）瞬时向量过滤器"></a>（一）瞬时向量过滤器</h4><p>瞬时向量过滤器允许在指定的时间戳内选择一组时间序列和每个时间序列的单个样本值。在最简单的形式中，仅指定指标（metric）名称。这将生成包含此指标名称的所有时间序列的元素的瞬时向量。<br>例如：选择指标名称为 http_requests_total 的所有时间序列：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">c</span><br></pre></td></tr></table></figure>
<p>可以通过向花括号（{}）里附加一组标签来进一步过滤时间序列。<br>例如：选择指标名称为 http_requests_total，job 标签值为 prometheus，group 标签值为 canary 的时间序列：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http_requests_total&#123;job=<span class="string">&quot;prometheus&quot;</span>,group=<span class="string">&quot;canary&quot;</span>&#125;</span><br></pre></td></tr></table></figure>
<p>PromQL 还支持用户根据时间序列的标签匹配模式来对时间序列进行过滤，目前主要支持两种匹配模式：完全匹配和正则匹配。总共有以下几种标签匹配<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=%E8%BF%90%E7%AE%97%E7%AC%A6&spm=1001.2101.3001.7020">运算符</a>：</p>
<ul>
<li>&#x3D; : 选择与提供的字符串完全相同的标签。</li>
<li>!&#x3D; : 选择与提供的字符串不相同的标签。</li>
<li>&#x3D;~ : 选择正则表达式与提供的字符串（或子字符串）相匹配的标签。</li>
<li>!~ : 选择正则表达式与提供的字符串（或子字符串）不匹配的标签。</li>
</ul>
<p>例如：选择指标名称为 http_requests_total，环境为 staging、testing 或 development，HTTP 方法为 GET 的时间序列：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http_requests_total&#123;environment=~<span class="string">&quot;staging|testing|development&quot;</span>,method=<span class="string">&quot;GET&quot;</span>&#125;</span><br></pre></td></tr></table></figure>
<p>没有指定标签的标签过滤器会选择该指标名称的所有时间序列。<br>所有的 PromQL 表达式必须至少包含一个指标名称，或者一个不会匹配到空字符串的标签过滤器。<br>以下表达式是非法的（因为会匹配到空字符串）：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;job=~<span class="string">&quot;.*&quot;</span>&#125; <span class="comment"># 非法！</span></span><br></pre></td></tr></table></figure>
<p>以下表达式是合法的：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#123;job=~<span class="string">&quot;.+&quot;</span>&#125;              <span class="comment"># 合法！</span></span><br><span class="line">&#123;job=~<span class="string">&quot;.*&quot;</span>,method=<span class="string">&quot;get&quot;</span>&#125; <span class="comment"># 合法！</span></span><br></pre></td></tr></table></figure>
<p>除了使用 {label&#x3D;value} 的形式以外，我们还可以使用内置的 <strong>name</strong> 标签来指定监控指标名称。例如：表达式 http_requests_total 等效于 {<strong>name</strong>&#x3D;”http_requests_total”}。也可以使用除 &#x3D; 之外的过滤器（&#x3D;，&#x3D;，）。以下表达式选择指标名称以 job: 开头的所有指标：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;__name__=~<span class="string">&quot;job:.*&quot;</span>&#125;</span><br></pre></td></tr></table></figure>
<p>Prometheus 中的所有正则表达式都使用 RE2语法。</p>
<h4 id="（二）区间向量过滤器"><a href="#（二）区间向量过滤器" class="headerlink" title="（二）区间向量过滤器"></a>（二）区间向量过滤器</h4><p>区间向量与瞬时向量的工作方式类似，唯一的差异在于在区间向量表达式中我们需要定义时间选择的范围，时间范围通过时间范围选择器 [] 进行定义，以指定应为每个返回的区间向量样本值中提取多长的时间范围。<br>时间范围通过数字来表示，单位可以使用以下其中之一的时间单位：</p>
<ul>
<li>s - 秒</li>
<li>m - 分钟</li>
<li>h - 小时</li>
<li>d - 天</li>
<li>w - 周</li>
<li>y - 年</li>
</ul>
<p>例如：选择在过去 5 分钟内指标名称为 http_requests_total，job 标签值为 prometheus 的所有时间序列：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http_requests_total&#123;job=<span class="string">&quot;prometheus&quot;</span>&#125;[5m]</span><br></pre></td></tr></table></figure>

<h4 id="（三）时间位移操作"><a href="#（三）时间位移操作" class="headerlink" title="（三）时间位移操作"></a>（三）时间位移操作</h4><p>在瞬时向量表达式或者区间向量表达式中，都是以当前时间为基准：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">http_request_total&#123;&#125; <span class="comment"># 瞬时向量表达式，选择当前最新的数据</span></span><br><span class="line">http_request_total&#123;&#125;[5m] <span class="comment"># 区间向量表达式，选择以当前时间为基准，5分钟内的数据</span></span><br></pre></td></tr></table></figure>
<p>而如果我们想查询，5 分钟前的瞬时样本数据，或昨天一天的区间内的样本数据呢? 这个时候我们就可以使用位移操作，位移操作的关键字为 offset。<br>例如，以下表达式返回相对于当前查询时间过去 5 分钟的 http_requests_total 值：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http_requests_total offset 5m</span><br></pre></td></tr></table></figure>
<p>注意：offset 关键字需要紧跟在选择器（{}）后面。以下表达式是正确的：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sum</span>(http_requests_total&#123;method=<span class="string">&quot;GET&quot;</span>&#125; offset 5m) // GOOD.</span><br></pre></td></tr></table></figure>
<p>下面的表达式是不合法的：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sum</span>(http_requests_total&#123;method=<span class="string">&quot;GET&quot;</span>&#125;) offset 5m // INVALID.</span><br></pre></td></tr></table></figure>
<p>该操作同样适用于区间向量。以下表达式返回指标 http_requests_total 一周前的 5 分钟之内的 HTTP 请求量的增长率：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rate(http_requests_total[5m] offset 1w)</span><br></pre></td></tr></table></figure>

<h3 id="四、操作符"><a href="#四、操作符" class="headerlink" title="四、操作符"></a>四、操作符</h3><p>使用PromQL除了能够方便的按照查询和过滤时间序列以外，PromQL还支持丰富的操作符，用户可以使用这些操作符对进一步的对事件序列进行二次加工。这些操作符包括：数学运算符，逻辑运算符，<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=%E5%B8%83%E5%B0%94%E8%BF%90%E7%AE%97&spm=1001.2101.3001.7020">布尔运算</a>符等等。</p>
<h4 id="（一）二元运算符"><a href="#（一）二元运算符" class="headerlink" title="（一）二元运算符"></a>（一）二元运算符</h4><p>Prometheus 的查询语言支持基本的逻辑运算和算术运算。对于两个瞬时向量, 匹配行为可以被改变。</p>
<h5 id="1-算术二元运算符"><a href="#1-算术二元运算符" class="headerlink" title="1. 算术二元运算符"></a>1. 算术二元运算符</h5><p>在 Prometheus 系统中支持下面的二元算术运算符：</p>
<ul>
<li>加法</li>
<li>减法</li>
<li>乘法</li>
<li>&#x2F; 除法</li>
<li>% 模</li>
<li>^ 幂等</li>
</ul>
<p>二元运算操作符支持 scalar&#x2F;scalar(标量&#x2F;标量)、vector&#x2F;scalar(向量&#x2F;标量)、和 vector&#x2F;vector(向量&#x2F;向量) 之间的操作。<br>在两个标量之间进行数学运算，得到的结果也是标量。<br>在向量和标量之间，这个运算符会作用于这个向量的每个样本值上。例如：如果一个时间序列瞬时向量除以 2，操作结果也是一个新的瞬时向量，且度量指标名称不变, 它是原度量指标瞬时向量的每个样本值除以 2。<br>如果是瞬时向量与瞬时向量之间进行数学运算时，过程会相对复杂一点，运算符会依次找到与左边向量元素匹配（标签完全一致）的右边向量元素进行运算，如果没找到匹配元素，则直接丢弃。同时新的时间序列将不会包含指标名称。</p>
<p>例如，如果我们想根据 node_disk_bytes_written 和 node_disk_bytes_read 获取主机磁盘IO的总量，可以使用如下表达式：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">node_disk_bytes_written + node_disk_bytes_read</span><br></pre></td></tr></table></figure>

<p>该表达式返回结果的示例如下所示：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#123;device=<span class="string">&quot;sda&quot;</span>,instance=<span class="string">&quot;localhost:9100&quot;</span>,job=<span class="string">&quot;node_exporter&quot;</span>&#125;=&gt;1634967552@1518146427.807 + 864551424@1518146427.807</span><br><span class="line">&#123;device=<span class="string">&quot;sdb&quot;</span>,instance=<span class="string">&quot;localhost:9100&quot;</span>,job=<span class="string">&quot;node_exporter&quot;</span>&#125;=&gt;0@1518146427.807 + 1744384@1518146427.807</span><br></pre></td></tr></table></figure>

<h5 id="2-布尔运算符"><a href="#2-布尔运算符" class="headerlink" title="2. 布尔运算符"></a>2. 布尔运算符</h5><p>目前，Prometheus 支持以下布尔运算符：</p>
<ul>
<li>&#x3D;&#x3D; (相等)</li>
<li>!&#x3D; (不相等)</li>
<li><blockquote>
<p>(大于)</p>
</blockquote>
</li>
<li>&lt; (小于)</li>
<li><blockquote>
<p>&#x3D; (大于等于)</p>
</blockquote>
</li>
<li>&lt;&#x3D; (小于等于)</li>
</ul>
<p>布尔运算符被应用于 scalar&#x2F;scalar（标量&#x2F;标量）、vector&#x2F;scalar（向量&#x2F;标量），和vector&#x2F;vector（向量&#x2F;向量）。默认情况下布尔运算符只会根据时间序列中样本的值，对时间序列进行过滤。我们可以通过在运算符后面使用 bool 修饰符来改变布尔运算的默认行为。使用 bool 修改符后，布尔运算不会对时间序列进行过滤，而是直接依次瞬时向量中的各个样本数据与标量的比较结果 0 或者 1。<br>在两个标量之间进行布尔运算，必须提供 bool 修饰符，得到的结果也是标量，即 0（false）或 1（true）。例如：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2 &gt; bool 1 <span class="comment"># 结果为 1</span></span><br></pre></td></tr></table></figure>

<p>瞬时向量和标量之间的布尔运算，这个运算符会应用到某个当前时刻的每个时序数据上，如果一个时序数据的样本值与这个标量比较的结果是 false，则这个时序数据被丢弃掉，如果是 true, 则这个时序数据被保留在结果中。如果提供了 bool 修饰符，那么比较结果是 0 的时序数据被丢弃掉，而比较结果是 1 的时序数据被保留。例如：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">http_requests_total &gt; 100 <span class="comment"># 结果为 true 或 false</span></span><br><span class="line">http_requests_total &gt; bool 100 <span class="comment"># 结果为 1 或 0</span></span><br></pre></td></tr></table></figure>

<p>瞬时向量与瞬时向量直接进行布尔运算时，同样遵循默认的匹配模式：依次找到与左边向量元素匹配（标签完全一致）的右边向量元素进行相应的操作，如果没找到匹配元素，或者计算结果为 false，则直接丢弃。如果匹配上了，则将左边向量的度量指标和标签的样本数据写入瞬时向量。如果提供了 bool 修饰符，那么比较结果是 0 的时序数据被丢弃掉，而比较结果是 1 的时序数据（只保留左边向量）被保留。</p>
<h5 id="3-集合运算符"><a href="#3-集合运算符" class="headerlink" title="3. 集合运算符"></a>3. 集合运算符</h5><p>使用瞬时向量表达式能够获取到一个包含多个时间序列的集合，我们称为瞬时向量。 通过集合运算，可以在两个瞬时向量与瞬时向量之间进行相应的集合操作。目前，Prometheus 支持以下集合运算符：</p>
<ul>
<li>and (并且)</li>
<li>or (或者)</li>
<li>unless (排除)</li>
</ul>
<p><strong>vector1 and vector2</strong> 会产生一个由 vector1 的元素组成的新的向量。该向量包含 vector1 中完全匹配 vector2 中的元素组成。<br><strong>vector1 or vector2</strong> 会产生一个新的向量，该向量包含 vector1 中所有的样本数据，以及 vector2 中没有与 vector1 匹配到的样本数据。<br><strong>vector1 unless vector2</strong> 会产生一个新的向量，新向量中的元素由 vector1 中没有与 vector2 匹配的元素组成。</p>
<h4 id="（二）匹配模式"><a href="#（二）匹配模式" class="headerlink" title="（二）匹配模式"></a>（二）匹配模式</h4><p>向量与向量之间进行运算操作时会基于默认的匹配规则：依次找到与左边向量元素匹配（标签完全一致）的右边向量元素进行运算，如果没找到匹配元素，则直接丢弃。<br>接下来将介绍在 PromQL 中有两种典型的匹配模式：一对一（one-to-one）,多对一（many-to-one）或一对多（one-to-many）。</p>
<h5 id="1-一对一匹配"><a href="#1-一对一匹配" class="headerlink" title="1. 一对一匹配"></a>1. 一对一匹配</h5><p>一对一匹配模式会从操作符两边表达式获取的瞬时向量依次比较并找到唯一匹配(标签完全一致)的样本值。默认情况下，使用表达式：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vector1 &lt;operator&gt; vector2</span><br></pre></td></tr></table></figure>

<p>在操作符两边表达式标签不一致的情况下，可以使用 on(label list) 或者 ignoring(label list）来修改便签的匹配行为。使用 ignoreing 可以在匹配时忽略某些便签。而 on 则用于将匹配行为限定在某些便签之内。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;vector <span class="built_in">expr</span>&gt; &lt;bin-op&gt; ignoring(&lt;label list&gt;) &lt;vector <span class="built_in">expr</span>&gt;</span><br><span class="line">&lt;vector <span class="built_in">expr</span>&gt; &lt;bin-op&gt; on(&lt;label list&gt;) &lt;vector <span class="built_in">expr</span>&gt;</span><br></pre></td></tr></table></figure>

<p>例如当存在样本：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">method_code:http_errors:rate5m&#123;method=<span class="string">&quot;get&quot;</span>, code=<span class="string">&quot;500&quot;</span>&#125;  24</span><br><span class="line">method_code:http_errors:rate5m&#123;method=<span class="string">&quot;get&quot;</span>, code=<span class="string">&quot;404&quot;</span>&#125;  30</span><br><span class="line">method_code:http_errors:rate5m&#123;method=<span class="string">&quot;put&quot;</span>, code=<span class="string">&quot;501&quot;</span>&#125;  3</span><br><span class="line">method_code:http_errors:rate5m&#123;method=<span class="string">&quot;post&quot;</span>, code=<span class="string">&quot;500&quot;</span>&#125; 6</span><br><span class="line">method_code:http_errors:rate5m&#123;method=<span class="string">&quot;post&quot;</span>, code=<span class="string">&quot;404&quot;</span>&#125; 21</span><br><span class="line"></span><br><span class="line">method:http_requests:rate5m&#123;method=<span class="string">&quot;get&quot;</span>&#125;  600</span><br><span class="line">method:http_requests:rate5m&#123;method=<span class="string">&quot;del&quot;</span>&#125;  34</span><br><span class="line">method:http_requests:rate5m&#123;method=<span class="string">&quot;post&quot;</span>&#125; 120</span><br></pre></td></tr></table></figure>

<p>使用 PromQL 表达式：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">method_code:http_errors:rate5m&#123;code=<span class="string">&quot;500&quot;</span>&#125; / ignoring(code) method:http_requests:rate5m</span><br></pre></td></tr></table></figure>

<p>该表达式会返回在过去 5 分钟内，HTTP 请求状态码为 500 的在所有请求中的比例。如果没有使用 ignoring(code)，操作符两边表达式返回的瞬时向量中将找不到任何一个标签完全相同的匹配项。<br>因此结果如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#123;method=<span class="string">&quot;get&quot;</span>&#125;  0.04            //  24 / 600</span><br><span class="line">&#123;method=<span class="string">&quot;post&quot;</span>&#125; 0.05            //   6 / 120</span><br></pre></td></tr></table></figure>

<p>同时由于 method 为 put 和 del 的样本找不到匹配项，因此不会出现在结果当中。</p>
<h5 id="2-多对一和一对多"><a href="#2-多对一和一对多" class="headerlink" title="2. 多对一和一对多"></a>2. 多对一和一对多</h5><p>多对一和一对多两种匹配模式指的是“一”侧的每一个向量元素可以与”多”侧的多个元素匹配的情况。在这种情况下，必须使用 group 修饰符：group_left 或者 group_right 来确定哪一个向量具有更高的基数（充当“多”的角色）。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;vector <span class="built_in">expr</span>&gt; &lt;bin-op&gt; ignoring(&lt;label list&gt;) group_left(&lt;label list&gt;) &lt;vector <span class="built_in">expr</span>&gt;</span><br><span class="line">&lt;vector <span class="built_in">expr</span>&gt; &lt;bin-op&gt; ignoring(&lt;label list&gt;) group_right(&lt;label list&gt;) &lt;vector <span class="built_in">expr</span>&gt;</span><br><span class="line">&lt;vector <span class="built_in">expr</span>&gt; &lt;bin-op&gt; on(&lt;label list&gt;) group_left(&lt;label list&gt;) &lt;vector <span class="built_in">expr</span>&gt;</span><br><span class="line">&lt;vector <span class="built_in">expr</span>&gt; &lt;bin-op&gt; on(&lt;label list&gt;) group_right(&lt;label list&gt;) &lt;vector <span class="built_in">expr</span>&gt;</span><br></pre></td></tr></table></figure>

<p>多对一和一对多两种模式一定是出现在操作符两侧表达式返回的向量标签不一致的情况。因此需要使用 ignoring 和 on 修饰符来排除或者限定匹配的标签列表。<br>例如，使用表达式：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">method_code:http_errors:rate5m / ignoring(code) group_left method:http_requests:rate5m</span><br></pre></td></tr></table></figure>

<p>该表达式中，左向量 method_code:http_errors:rate5m 包含两个标签 method 和 code。而右向量 method:http_requests:rate5m 中只包含一个标签 method，因此匹配时需要使用 ignoring 限定匹配的标签为 code。 在限定匹配标签后，右向量中的元素可能匹配到多个左向量中的元素 因此该表达式的匹配模式为多对一，需要使用 group 修饰符 group_left 指定左向量具有更好的基数。<br>最终的运算结果如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;method=<span class="string">&quot;get&quot;</span>, code=<span class="string">&quot;500&quot;</span>&#125;  0.04            //  24 / 600</span><br><span class="line">&#123;method=<span class="string">&quot;get&quot;</span>, code=<span class="string">&quot;404&quot;</span>&#125;  0.05            //  30 / 600</span><br><span class="line">&#123;method=<span class="string">&quot;post&quot;</span>, code=<span class="string">&quot;500&quot;</span>&#125; 0.05            //   6 / 120</span><br><span class="line">&#123;method=<span class="string">&quot;post&quot;</span>, code=<span class="string">&quot;404&quot;</span>&#125; 0.175           //  21 / 120</span><br></pre></td></tr></table></figure>

<p><em>提醒：group 修饰符只能在比较和数学运算符中使用。在逻辑运算 and，unless 和 or 操作中默认与右向量中的所有元素进行匹配。</em></p>
<h5 id="3-聚合操作"><a href="#3-聚合操作" class="headerlink" title="3. 聚合操作"></a>3. 聚合操作</h5><p>Prometheus 还提供了下列内置的聚合操作符，这些操作符作用于瞬时向量。可以将瞬时表达式返回的样本数据进行聚合，形成一个具有较少样本值的新的时间序列。</p>
<ul>
<li>sum (求和)</li>
<li>min (最小值)</li>
<li>max (最大值)</li>
<li>avg (平均值)</li>
<li>stddev (标准差)</li>
<li>stdvar (标准差异)</li>
<li>count (计数)</li>
<li>count_values (对 value 进行计数)</li>
<li>bottomk (样本值最小的 k 个元素)</li>
<li>topk (样本值最大的k个元素)</li>
<li>quantile (分布统计)</li>
</ul>
<p>这些操作符被用于聚合所有标签维度，或者通过 without 或者 by 子语句来保留不同的维度。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;aggr-op&gt;([parameter,] &lt;vector expression&gt;) [without|by (&lt;label list&gt;)]</span><br></pre></td></tr></table></figure>

<p>其中只有 count_values, quantile, topk, bottomk 支持参数(parameter)。<br>without 用于从计算结果中移除列举的标签，而保留其它标签。by 则正好相反，结果向量中只保留列出的标签，其余标签则移除。通过 without 和 by 可以按照样本的问题对数据进行聚合。<br>例如：<br>如果指标 http_requests_total 的时间序列的标签集为 application, instance, 和 group，我们可以通过以下方式计算所有 instance 中每个 application 和 group 的请求总量：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sum</span>(http_requests_total) without (instance)</span><br></pre></td></tr></table></figure>
<p>等价于</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sum</span>(http_requests_total) by (application, group)</span><br></pre></td></tr></table></figure>
<p>如果只需要计算整个应用的 HTTP 请求总量，可以直接使用表达式：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sum</span>(http_requests_total)</span><br></pre></td></tr></table></figure>

<p>count_values 用于时间序列中每一个样本值出现的次数。count_values 会为每一个唯一的样本值输出一个时间序列，并且每一个时间序列包含一个额外的标签。这个标签的名字由聚合参数指定，同时这个标签值是唯一的样本值。<br>例如要计算运行每个构建版本的二进制文件的数量：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">count_values(<span class="string">&quot;version&quot;</span>, build_version)</span><br></pre></td></tr></table></figure>
<p>返回结果如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;count=&quot;641&quot;&#125;   1</span><br><span class="line">&#123;count=&quot;3226&quot;&#125;  2</span><br><span class="line">&#123;count=&quot;644&quot;&#125;   4</span><br></pre></td></tr></table></figure>

<p>topk 和 bottomk 则用于对样本值进行排序，返回当前样本值前 n 位，或者后 n 位的时间序列。<br>获取 HTTP 请求数前 5 位的时序样本数据，可以使用表达式：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">topk(5, http_requests_total)</span><br></pre></td></tr></table></figure>
<p>quantile 用于计算当前样本数据值的分布情况 quantile(φ, express) ，其中 0 ≤ φ ≤ 1。<br>例如，当 φ 为 0.5 时，即表示找到当前样本数据中的中位数：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">quantile(0.5, http_requests_total)</span><br></pre></td></tr></table></figure>
<p>返回结果如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#125;   656</span><br></pre></td></tr></table></figure>

<h5 id="4-二元运算符优先级"><a href="#4-二元运算符优先级" class="headerlink" title="4. 二元运算符优先级"></a>4. 二元运算符优先级</h5><p>在 Prometheus 系统中，二元运算符优先级从高到低的顺序为：</p>
<ol>
<li>^</li>
<li>*, &#x2F;, %</li>
<li>+, -</li>
<li>&#x3D;&#x3D;, !&#x3D;, &lt;&#x3D;, &lt;, &gt;&#x3D;, &gt;</li>
<li>and, unless</li>
<li>or</li>
</ol>
<p>具有相同优先级的运算符是满足结合律的（左结合）。例如，2 _ 3 % 2 等价于 (2 _ 3) % 2。运算符 ^ 例外，^ 满足的是右结合，例如，2 ^ 3 ^ 2 等价于 2 ^ (3 ^ 2)。</p>
<h3 id="五、PromQL-内置函数"><a href="#五、PromQL-内置函数" class="headerlink" title="五、PromQL 内置函数"></a>五、PromQL 内置函数</h3><p>Prometheus 提供了其它大量的内置函数，可以对时序数据进行丰富的处理。某些函数有默认的参数，例如：year(v&#x3D;vector(time()) instant-vector)。其中参数 v 是一个瞬时向量，如果不提供该参数，将使用默认值 vector(time())。instant-vector 表示参数类型。</p>
<h5 id="1-abs"><a href="#1-abs" class="headerlink" title="1. abs()"></a>1. abs()</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">abs(v instant-vector) 返回输入向量的所有样本的绝对值。</span><br></pre></td></tr></table></figure>
<h5 id="2-absent"><a href="#2-absent" class="headerlink" title="2. absent()"></a>2. absent()</h5><p>absent(v instant-vector)，如果传递给它的向量参数具有样本数据，则返回空向量；如果传递的向量参数没有样本数据，则返回不带度量指标名称且带有标签的时间序列，且样本值为1。<br>当监控度量指标时，如果获取到的样本数据是空的， 使用 absent 方法对告警是非常有用的。例如：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 这里提供的向量有样本数据</span></span><br><span class="line">absent(http_requests_total&#123;method=<span class="string">&quot;get&quot;</span>&#125;)  =&gt; no data</span><br><span class="line">absent(<span class="built_in">sum</span>(http_requests_total&#123;method=<span class="string">&quot;get&quot;</span>&#125;))  =&gt; no data</span><br><span class="line"></span><br><span class="line"><span class="comment"># 由于不存在度量指标 nonexistent，所以 返回不带度量指标名称且带有标签的时间序列，且样本值为1</span></span><br><span class="line">absent(nonexistent&#123;job=<span class="string">&quot;myjob&quot;</span>&#125;)  =&gt; &#123;job=<span class="string">&quot;myjob&quot;</span>&#125;  1</span><br><span class="line"><span class="comment"># 正则匹配的 instance 不作为返回 labels 中的一部分</span></span><br><span class="line">absent(nonexistent&#123;job=<span class="string">&quot;myjob&quot;</span>,instance=~<span class="string">&quot;.*&quot;</span>&#125;)  =&gt; &#123;job=<span class="string">&quot;myjob&quot;</span>&#125;  1</span><br><span class="line"></span><br><span class="line"><span class="comment"># sum 函数返回的时间序列不带有标签，且没有样本数据</span></span><br><span class="line">absent(<span class="built_in">sum</span>(nonexistent&#123;job=<span class="string">&quot;myjob&quot;</span>&#125;))  =&gt; &#123;&#125;  1</span><br></pre></td></tr></table></figure>
<h5 id="3-ceil"><a href="#3-ceil" class="headerlink" title="3. ceil()"></a>3. ceil()</h5><p>ceil(v instant-vector) 将 v 中所有元素的样本值向上四舍五入到最接近的整数。例如：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">node_load5&#123;instance=<span class="string">&quot;192.168.75.149:9100&quot;</span>&#125; <span class="comment"># 结果为 2.79</span></span><br><span class="line">ceil(node_load5&#123;instance=<span class="string">&quot;192.168.75.149:9100&quot;</span>&#125;) <span class="comment"># 结果为 3</span></span><br></pre></td></tr></table></figure>
<h5 id="4-changes"><a href="#4-changes" class="headerlink" title="4. changes()"></a>4. changes()</h5><p>changes(v range-vector) 输入一个区间向量， 返回这个区间向量内每个样本数据值变化的次数（瞬时向量）。例如：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 如果样本数据值没有发生变化，则返回结果为 1</span></span><br><span class="line">changes(node_load5&#123;instance=<span class="string">&quot;192.168.75.149:9100&quot;</span>&#125;[1m]) <span class="comment"># 结果为 1</span></span><br></pre></td></tr></table></figure>
<h5 id="5-clamp-max"><a href="#5-clamp-max" class="headerlink" title="5. clamp_max()"></a>5. clamp_max()</h5><p>clamp_max(v instant-vector, max scalar)函数，输入一个瞬时向量和最大值，样本数据值若大于 max，则改为 max，否则不变。例如：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">node_load5&#123;instance=<span class="string">&quot;192.168.75.149:9100&quot;</span>&#125; <span class="comment"># 结果为 2.79</span></span><br><span class="line">clamp_max(node_load5&#123;instance=<span class="string">&quot;192.168.75.149:9100&quot;</span>&#125;, 2) <span class="comment"># 结果为 2</span></span><br></pre></td></tr></table></figure>
<h5 id="6-clamp-min"><a href="#6-clamp-min" class="headerlink" title="6. clamp_min()"></a>6. clamp_min()</h5><p>clamp_min(v instant-vector, min scalar)函数，输入一个瞬时向量和最小值，样本数据值若小于 min，则改为 min，否则不变。例如：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">node_load5&#123;instance=<span class="string">&quot;192.168.75.149:9100&quot;</span>&#125; <span class="comment"># 结果为 2.79</span></span><br><span class="line">clamp_min(node_load5&#123;instance=<span class="string">&quot;192.168.75.149:9100&quot;</span>&#125;, 3) <span class="comment"># 结果为 3</span></span><br></pre></td></tr></table></figure>
<h5 id="7-day-of-month"><a href="#7-day-of-month" class="headerlink" title="7. day_of_month()"></a>7. day_of_month()</h5><p>day_of_month(v&#x3D;vector(time()) instant-vector)函数，返回被给定 UTC 时间所在月的第几天。返回值范围：1~31。</p>
<h5 id="8-day-of-week"><a href="#8-day-of-week" class="headerlink" title="8. day_of_week()"></a>8. day_of_week()</h5><p>day_of_week(v&#x3D;vector(time()) instant-vector) 函数，返回被给定 UTC 时间所在周的第几天。返回值范围：0~6，0 表示星期天。</p>
<h5 id="9-days-in-month"><a href="#9-days-in-month" class="headerlink" title="9. days_in_month()"></a>9. days_in_month()</h5><p>days_in_month(v&#x3D;vector(time()) instant-vector)函数，返回当月一共有多少天。返回值范围：28~31。</p>
<h5 id="10-delta"><a href="#10-delta" class="headerlink" title="10. delta()"></a>10. delta()</h5><p>delta(v range-vector)的参数是一个区间向量，返回一个瞬时向量。它计算一个区间向量 v 的第一个元素和最后一个元素之间的差值。由于这个值被外推到指定的整个时间范围，所以即使样本值都是整数，你仍然可能会得到一个非整数值。<br>例如，下面的例子返回过去两小时的 CPU 温度差：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">delta(cpu_temp_celsius&#123;host=<span class="string">&quot;zeus&quot;</span>&#125;[2h])</span><br></pre></td></tr></table></figure>

<p>这个函数一般只用在 Gauge 类型的时间序列上。</p>
<h5 id="11-deriv"><a href="#11-deriv" class="headerlink" title="11. deriv()"></a>11. deriv()</h5><p>deriv(v range-vector)的参数是一个区间向量,返回一个瞬时向量。它使用简单的线性回归计算区间向量 v 中各个时间序列的导数。<br>这个函数一般只用在 Gauge 类型的时间序列上。</p>
<h5 id="12-exp"><a href="#12-exp" class="headerlink" title="12. exp()"></a>12. exp()</h5><p>exp(v instant-vector) 函数，输入一个瞬时向量，返回各个样本值的 e 的指数值，即 e 的 N 次方。当 N 的值足够大时会返回 +Inf。特殊情况为：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Exp(+Inf) = +Inf</span><br><span class="line">Exp(NaN) = NaN</span><br></pre></td></tr></table></figure>

<h5 id="13-floor"><a href="#13-floor" class="headerlink" title="13. floor()"></a>13. floor()</h5><p>floor(v instant-vector)函数与 ceil() 函数相反，将 v 中所有元素的样本值向下四舍五入到最接近的整数。</p>
<h5 id="14-histogram-quantile"><a href="#14-histogram-quantile" class="headerlink" title="14. histogram_quantile()"></a>14. histogram_quantile()</h5><p>histogram_quantile(φ float, b instant-vector) 从 bucket 类型的向量 b 中计算 φ (0 ≤ φ ≤ 1) 分位数（百分位数的一般形式）的样本的最大值。（有关 φ 分位数的详细说明以及直方图指标类型的使用，请参阅直方图和摘要）。向量 b 中的样本是每个 bucket 的采样点数量。每个样本的 labels 中必须要有 le 这个 label 来表示每个 bucket 的上边界，没有 le 标签的样本会被忽略。直方图指标类型自动提供带有 _bucket 后缀和相应标签的时间序列。<br>可以使用 rate() 函数来指定分位数计算的时间窗口。<br>例如，一个直方图指标名称为 employee_age_bucket_bucket，要计算过去 10 分钟内 第 90 个百分位数，请使用以下表达式：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">histogram_quantile(0.9, rate(employee_age_bucket_bucket[10m]))</span><br></pre></td></tr></table></figure>
<p>返回：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;instance=<span class="string">&quot;10.0.86.71:8080&quot;</span>,job=<span class="string">&quot;prometheus&quot;</span>&#125; 35.714285714285715</span><br></pre></td></tr></table></figure>
<p>这表示最近 10 分钟之内 90% 的样本的最大值为 35.714285714285715。<br>这个计算结果是每组标签组合成一个时间序列。我们可能不会对所有这些维度（如 job、instance 和 method）感兴趣，并希望将其中的一些维度进行聚合，则可以使用 sum() 函数。例如，以下表达式根据 job 标签来对第 90 个百分位数进行聚合：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># histogram_quantile() 函数必须包含 le 标签</span></span><br><span class="line">histogram_quantile(0.9, <span class="built_in">sum</span>(rate(employee_age_bucket_bucket[10m])) by (job, le))</span><br></pre></td></tr></table></figure>
<p>如果要聚合所有的标签，则使用如下表达式：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">histogram_quantile(0.9,<span class="built_in">sum</span>(rate(employee_age_bucket_bucket[10m])) by (le))</span><br></pre></td></tr></table></figure>
<p>注意<br>histogram_quantile 这个函数是根据假定每个区间内的样本分布是线性分布来计算结果值的(也就是说它的结果未必准确)，最高的 bucket 必须是 le&#x3D;”+Inf”(否则就返回 NaN)。</p>
<p>如果分位数位于最高的 bucket（+Inf） 中，则返回第二个最高的 bucket 的上边界。如果该 bucket 的上边界大于 0，则假设最低的 bucket 的的下边界为 0，这种情况下在该 bucket 内使用常规的线性插值。</p>
<p>如果分位数位于最低的 bucket 中，则返回最低 bucket 的上边界。<br>如果 b 含有少于 2 个 buckets，那么会返回 NaN，如果 φ &lt; 0 会返回 -Inf，如果 φ &gt; 1 会返回 +Inf。</p>
<h5 id="15-holt-winters"><a href="#15-holt-winters" class="headerlink" title="15. holt_winters()"></a>15. holt_winters()</h5><p>holt_winters(v range-vector, sf scalar, tf scalar)函数基于区间向量 v，生成时间序列数据平滑值。平滑因子 sf 越低, 对旧数据的重视程度越高。趋势因子 tf 越高，对数据的趋势的考虑就越多。其中，0&lt; sf, tf &lt;&#x3D;1。<br>holt_winters 仅适用于 Gauge 类型的时间序列。</p>
<h5 id="16-hour"><a href="#16-hour" class="headerlink" title="16. hour()"></a>16. hour()</h5><p>hour(v&#x3D;vector(time()) instant-vector)函数返回被给定 UTC 时间的当前第几个小时，时间范围：0~23。</p>
<h5 id="17-idelta"><a href="#17-idelta" class="headerlink" title="17. idelta()"></a>17. idelta()</h5><p>idelta(v range-vector)的参数是一个区间向量, 返回一个瞬时向量。它计算最新的 2 个样本值之间的差值。<br>这个函数一般只用在 Gauge 类型的时间序列上。</p>
<h5 id="18-increase"><a href="#18-increase" class="headerlink" title="18. increase()"></a>18. increase()</h5><p>increase(v range-vector)函数获取区间向量中的第一个和最后一个样本并返回其增长量, 它会在单调性发生变化时(如由于采样目标重启引起的计数器复位)自动中断。由于这个值被外推到指定的整个时间范围，所以即使样本值都是整数，你仍然可能会得到一个非整数值。<br>例如，以下表达式返回区间向量中每个时间序列过去 5 分钟内 HTTP 请求数的增长数：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">increase(http_requests_total&#123;job=<span class="string">&quot;apiserver&quot;</span>&#125;[5m])</span><br></pre></td></tr></table></figure>
<p>increase 的返回值类型只能是计数器类型，主要作用是增加图表和数据的可读性。使用 rate 函数记录规则的使用率，以便持续跟踪数据样本值的变化。</p>
<h5 id="19-irate"><a href="#19-irate" class="headerlink" title="19. irate()"></a>19. irate()</h5><p>irate(v range-vector) 函数用于计算区间向量的增长率，但是其反应出的是瞬时增长率。irate 函数是通过区间向量中最后两个两本数据来计算区间向量的增长速率，它会在单调性发生变化时(如由于采样目标重启引起的计数器复位)自动中断。这种方式可以避免在时间窗口范围内的“长尾问题”，并且体现出更好的灵敏度，通过irate函数绘制的图标能够更好的反应样本数据的瞬时变化状态。<br>例如，以下表达式返回区间向量中每个时间序列过去 5 分钟内最后两个样本数据的 HTTP 请求数的增长率：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">irate(http_requests_total&#123;job=<span class="string">&quot;api-server&quot;</span>&#125;[5m])</span><br></pre></td></tr></table></figure>

<p>irate 只能用于绘制快速变化的计数器，在长期趋势分析或者告警中更推荐使用 rate 函数。因为使用 irate 函数时，速率的简短变化会重置 FOR 语句，形成的图形有很多波峰，难以阅读。<br>注意：<br>当将 irate() 函数与聚合运算符（例如 sum()）或随时间聚合的函数（任何以 _over_time 结尾的函数）一起使用时，必须先执行 irate 函数，然后再进行聚合操作，否则当采样目标重新启动时 irate() 无法检测到计数器是否被重置。</p>
<h5 id="20-label-join"><a href="#20-label-join" class="headerlink" title="20. label_join()"></a>20. label_join()</h5><p>label_join(v instant-vector, dst_label string, separator string, src_label_1 string, src_label_2 string, …)函数可以将时间序列 v 中多个标签 src_label 的值，通过 separator 作为连接符写入到一个新的标签 dst_label 中。可以有多个 src_label 标签。<br>例如，以下表达式返回的时间序列多了一个 foo 标签，标签值为 etcd,etcd-k8s：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">up&#123;endpoint=<span class="string">&quot;api&quot;</span>,instance=<span class="string">&quot;192.168.123.248:2379&quot;</span>,job=<span class="string">&quot;etcd&quot;</span>,namespace=<span class="string">&quot;monitoring&quot;</span>,service=<span class="string">&quot;etcd-k8s&quot;</span>&#125;</span><br><span class="line">=&gt; up&#123;endpoint=<span class="string">&quot;api&quot;</span>,instance=<span class="string">&quot;192.168.123.248:2379&quot;</span>,job=<span class="string">&quot;etcd&quot;</span>,namespace=<span class="string">&quot;monitoring&quot;</span>,service=<span class="string">&quot;etcd-k8s&quot;</span>&#125;  1</span><br><span class="line"></span><br><span class="line">label_join(up&#123;endpoint=<span class="string">&quot;api&quot;</span>,instance=<span class="string">&quot;192.168.123.248:2379&quot;</span>,job=<span class="string">&quot;etcd&quot;</span>,namespace=<span class="string">&quot;monitoring&quot;</span>,service=<span class="string">&quot;etcd-k8s&quot;</span>&#125;, <span class="string">&quot;foo&quot;</span>, <span class="string">&quot;,&quot;</span>, <span class="string">&quot;job&quot;</span>, <span class="string">&quot;service&quot;</span>)</span><br><span class="line">=&gt; up&#123;endpoint=<span class="string">&quot;api&quot;</span>,foo=<span class="string">&quot;etcd,etcd-k8s&quot;</span>,instance=<span class="string">&quot;192.168.123.248:2379&quot;</span>,job=<span class="string">&quot;etcd&quot;</span>,namespace=<span class="string">&quot;monitoring&quot;</span>,service=<span class="string">&quot;etcd-k8s&quot;</span>&#125;  1</span><br></pre></td></tr></table></figure>

<h5 id="21-label-replace"><a href="#21-label-replace" class="headerlink" title="21. label_replace()"></a>21. label_replace()</h5><p>为了能够让客户端的图标更具有可读性，可以通过 label_replace 函数为时间序列添加额外的标签。label_replace 的具体参数如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">label_replace(v instant-vector, dst_label string, replacement string, src_label string, regex string)</span><br></pre></td></tr></table></figure>
<p>该函数会依次对 v 中的每一条时间序列进行处理，通过 regex 匹配 src_label 的值，并将匹配部分 relacement 写入到 dst_label 标签中。如下所示：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">label_replace(up, <span class="string">&quot;host&quot;</span>, <span class="string">&quot;<span class="variable">$1</span>&quot;</span>, <span class="string">&quot;instance&quot;</span>,  <span class="string">&quot;(.*):.*&quot;</span>)</span><br></pre></td></tr></table></figure>
<p>函数处理后，时间序列将包含一个 host 标签，host 标签的值为 Exporter 实例的 IP 地址：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">up&#123;host=<span class="string">&quot;localhost&quot;</span>,instance=<span class="string">&quot;localhost:8080&quot;</span>,job=<span class="string">&quot;cadvisor&quot;</span>&#125;   1</span><br><span class="line">up&#123;host=<span class="string">&quot;localhost&quot;</span>,instance=<span class="string">&quot;localhost:9090&quot;</span>,job=<span class="string">&quot;prometheus&quot;</span>&#125;   1</span><br><span class="line">up&#123;host=<span class="string">&quot;localhost&quot;</span>,instance=<span class="string">&quot;localhost:9100&quot;</span>,job=<span class="string">&quot;node&quot;</span>&#125;   1</span><br></pre></td></tr></table></figure>

<h5 id="22-ln"><a href="#22-ln" class="headerlink" title="22. ln()"></a>22. ln()</h5><p>ln(v instant-vector) 计算瞬时向量 v 中所有样本数据的自然对数。特殊情况：</p>
<ul>
<li>ln(+Inf) &#x3D; +Inf</li>
<li>ln(0) &#x3D; -Inf</li>
<li>ln(x &lt; 0) &#x3D; NaN</li>
<li>ln(NaN) &#x3D; NaN</li>
</ul>
<h5 id="23-log2"><a href="#23-log2" class="headerlink" title="23. log2()"></a>23. log2()</h5><p>log2(v instant-vector)函数计算瞬时向量 v 中所有样本数据的二进制对数。特殊情况同上。</p>
<h5 id="24-log10"><a href="#24-log10" class="headerlink" title="24. log10()"></a>24. log10()</h5><p>log10(v instant-vector) 计算瞬时向量 v 中所有样本数据的十进制对数。特殊情况同上。</p>
<h5 id="25-minute"><a href="#25-minute" class="headerlink" title="25. minute()"></a>25. minute()</h5><p>minute(v&#x3D;vector(time()) instant-vector)函数返回给定 UTC 时间当前小时的第多少分钟。结果范围：0~59。</p>
<h5 id="26-month"><a href="#26-month" class="headerlink" title="26. month()"></a>26. month()</h5><p>month(v&#x3D;vector(time()) instant-vector)函数返回给定 UTC 时间当前属于第几个月，结果范围：0~12。</p>
<h5 id="27-predict-linear"><a href="#27-predict-linear" class="headerlink" title="27. predict_linear()"></a>27. predict_linear()</h5><p>predict_linear(v range-vector, t scalar)函数可以预测时间序列 v 在 t 秒后的值。它基于简单线性回归的方式，对时间窗口内的样本数据进行统计，从而可以对时间序列的变化趋势做出预测。该函数的返回结果不带有度量指标，只有标签列表。<br>例如，基于 2 小时的样本数据，来预测主机可用磁盘空间的是否在 4 个小时候被占满，可以使用如下表达式：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">predict_linear(node_filesystem_free&#123;job=<span class="string">&quot;node&quot;</span>&#125;[2h], 4 * 3600) &lt; 0</span><br></pre></td></tr></table></figure>

<p>通过下面的例子来观察返回值：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">predict_linear(http_requests_total&#123;code=<span class="string">&quot;200&quot;</span>,instance=<span class="string">&quot;120.77.65.193:9090&quot;</span>,job=<span class="string">&quot;prometheus&quot;</span>,method=<span class="string">&quot;get&quot;</span>&#125;[5m], 5)</span><br><span class="line"></span><br><span class="line">结果：</span><br><span class="line">&#123;code=<span class="string">&quot;200&quot;</span>,handler=<span class="string">&quot;query_range&quot;</span>,instance=<span class="string">&quot;120.77.65.193:9090&quot;</span>,job=<span class="string">&quot;prometheus&quot;</span>,method=<span class="string">&quot;get&quot;</span>&#125;  1</span><br><span class="line">&#123;code=<span class="string">&quot;200&quot;</span>,handler=<span class="string">&quot;prometheus&quot;</span>,instance=<span class="string">&quot;120.77.65.193:9090&quot;</span>,job=<span class="string">&quot;prometheus&quot;</span>,method=<span class="string">&quot;get&quot;</span>&#125;   4283.449995397104</span><br><span class="line">&#123;code=<span class="string">&quot;200&quot;</span>,handler=<span class="string">&quot;static&quot;</span>,instance=<span class="string">&quot;120.77.65.193:9090&quot;</span>,job=<span class="string">&quot;prometheus&quot;</span>,method=<span class="string">&quot;get&quot;</span>&#125;   22.99999999999999</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>这个函数一般只用在 Gauge 类型的时间序列上。</p>
<h5 id="28-rate"><a href="#28-rate" class="headerlink" title="28. rate()"></a>28. rate()</h5><p>rate(v range-vector) 函数可以直接计算区间向量 v 在时间窗口内平均增长速率，它会在单调性发生变化时(如由于采样目标重启引起的计数器复位)自动中断。该函数的返回结果不带有度量指标，只有标签列表。<br>例如，以下表达式返回区间向量中每个时间序列过去 5 分钟内 HTTP 请求数的每秒增长率：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">rate(http_requests_total[5m])</span><br><span class="line"></span><br><span class="line">结果：</span><br><span class="line">&#123;code=<span class="string">&quot;200&quot;</span>,handler=<span class="string">&quot;label_values&quot;</span>,instance=<span class="string">&quot;120.77.65.193:9090&quot;</span>,job=<span class="string">&quot;prometheus&quot;</span>,method=<span class="string">&quot;get&quot;</span>&#125; 0</span><br><span class="line">&#123;code=<span class="string">&quot;200&quot;</span>,handler=<span class="string">&quot;query_range&quot;</span>,instance=<span class="string">&quot;120.77.65.193:9090&quot;</span>,job=<span class="string">&quot;prometheus&quot;</span>,method=<span class="string">&quot;get&quot;</span>&#125;  0</span><br><span class="line">&#123;code=<span class="string">&quot;200&quot;</span>,handler=<span class="string">&quot;prometheus&quot;</span>,instance=<span class="string">&quot;120.77.65.193:9090&quot;</span>,job=<span class="string">&quot;prometheus&quot;</span>,method=<span class="string">&quot;get&quot;</span>&#125;   0.2</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>rate() 函数返回值类型只能用计数器，在长期趋势分析或者告警中推荐使用这个函数。<br>注意：<br>当将 rate() 函数与聚合运算符（例如 sum()）或随时间聚合的函数（任何以 _over_time 结尾的函数）一起使用时，必须先执行<br>rate 函数，然后再进行聚合操作，否则当采样目标重新启动时 rate() 无法检测到计数器是否被重置。</p>
<h5 id="29-resets"><a href="#29-resets" class="headerlink" title="29. resets()"></a>29. resets()</h5><p>resets(v range-vector)的参数是一个区间向量。对于每个时间序列，它都返回一个计数器重置的次数。两个连续样本之间的值的减少被认为是一次计数器重置。<br>这个函数一般只用在计数器类型的时间序列上。</p>
<h5 id="30-round"><a href="#30-round" class="headerlink" title="30. round()"></a>30. round()</h5><p>round(v instant-vector, to_nearest&#x3D;1 scalar) 函数与 ceil 和 floor 函数类似，返回向量中所有样本值的最接近的整数。to_nearest 参数是可选的,默认为 1,表示样本返回的是最接近 1 的整数倍的值。你也可以将该参数指定为任意值（也可以是小数），表示样本返回的是最接近它的整数倍的值。</p>
<h5 id="31-scalar"><a href="#31-scalar" class="headerlink" title="31. scalar()"></a>31. scalar()</h5><p>scalar(v instant-vector)函数的参数是一个单元素的瞬时向量,它返回其唯一的时间序列的值作为一个标量。如果度量指标的样本数量大于 1 或者等于 0, 则返回 NaN。</p>
<h5 id="32-sort"><a href="#32-sort" class="headerlink" title="32. sort()"></a>32. sort()</h5><p>sort(v instant-vector)函数对向量按元素的值进行升序排序，返回结果：key: value &#x3D; 度量指标：样本值[升序排列]。</p>
<h5 id="33-sort-desc"><a href="#33-sort-desc" class="headerlink" title="33. sort_desc()"></a>33. sort_desc()</h5><p>sort(v instant-vector) 函数对向量按元素的值进行降序排序，返回结果：key: value &#x3D; 度量指标：样本值[降序排列]。</p>
<h5 id="34-sqrt"><a href="#34-sqrt" class="headerlink" title="34. sqrt()"></a>34. sqrt()</h5><p>sqrt(v instant-vector) 函数计算向量 v 中所有元素的平方根。</p>
<h5 id="35-time"><a href="#35-time" class="headerlink" title="35. time()"></a>35. time()</h5><p>time()函数返回从 1970-01-01 到现在的秒数。注意：它不是直接返回当前时间，而是时间戳</p>
<h5 id="36-timestamp"><a href="#36-timestamp" class="headerlink" title="36. timestamp()"></a>36. timestamp()</h5><p>timestamp(v instant-vector) 函数返回向量 v 中的每个样本的时间戳（从 1970-01-01 到现在的秒数）。<br>该函数从 Prometheus 2.0 版本开始引入。</p>
<h5 id="37-vector"><a href="#37-vector" class="headerlink" title="37. vector()"></a>37. vector()</h5><p>vector(s scalar)函数将标量 s 作为没有标签的向量返回，即返回结果为：key: value&#x3D; {}, s。</p>
<h5 id="38-year"><a href="#38-year" class="headerlink" title="38. year()"></a>38. year()</h5><p>year(v&#x3D;vector(time()) instant-vector)函数返回被给定 UTC 时间的当前年份。</p>
<h5 id="39-over-time"><a href="#39-over-time" class="headerlink" title="39. _over_time()"></a>39. _over_time()</h5><p>下面的函数列表允许传入一个区间向量，它们会聚合每个时间序列的范围，并返回一个瞬时向量：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">avg_over_time(range-vector) : 区间向量内每个度量指标的平均值。</span><br><span class="line">min_over_time(range-vector) : 区间向量内每个度量指标的最小值。</span><br><span class="line">max_over_time(range-vector) : 区间向量内每个度量指标的最大值。</span><br><span class="line">sum_over_time(range-vector) : 区间向量内每个度量指标的求和。</span><br><span class="line">count_over_time(range-vector) : 区间向量内每个度量指标的样本数据个数。</span><br><span class="line">quantile_over_time(scalar, range-vector) : 区间向量内每个度量指标的样本数据值分位数，φ-quantile (0 ≤ φ ≤ 1)。</span><br><span class="line">stddev_over_time(range-vector) : 区间向量内每个度量指标的总体标准差。</span><br><span class="line">stdvar_over_time(range-vector) : 区间向量内每个度量指标的总体标准方差。</span><br></pre></td></tr></table></figure>

<p>注意：<br>即使区间向量内的值分布不均匀，它们在聚合时的权重也是相同的。</p>
<h3 id="六、-简单示例"><a href="#六、-简单示例" class="headerlink" title="六、 简单示例"></a>六、 简单示例</h3><h5 id="1-简单的时间序列选择"><a href="#1-简单的时间序列选择" class="headerlink" title="1. 简单的时间序列选择"></a>1. 简单的时间序列选择</h5><p>返回度量指标 http_requests_total 的所有时间序列样本数据：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http_requests_total</span><br></pre></td></tr></table></figure>

<p>返回度量指标名称为 http_requests_total，标签分别是 job&#x3D;“apiserver”, handler&#x3D;”&#x2F;api&#x2F;comments” 的所有时间序列样本数据：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http_requests_total&#123;job=<span class="string">&quot;apiserver&quot;</span>, handler=<span class="string">&quot;/api/comments&quot;</span>&#125;</span><br></pre></td></tr></table></figure>

<p>返回度量指标名称为 http_requests_total，标签分别是 job&#x3D;“apiserver”, handler&#x3D;”&#x2F;api&#x2F;comments”，且是 5 分钟内的所有时间序列样本数据：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http_requests_total&#123;job=<span class="string">&quot;apiserver&quot;</span>, handler=<span class="string">&quot;/api/comments&quot;</span>&#125;[5m]</span><br></pre></td></tr></table></figure>

<p>注意：</p>
<p>一个区间向量表达式不能直接展示在 Graph 图表中，但是可以展示在 Console 视图中。<br>使用正则表达式，你可以通过特定模式匹配标签为 job 的特定任务名，获取这些任务的时间序列。在下面这个例子中, 所有任务名称以 server 结尾。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http_requests_total&#123;job=~<span class="string">&quot;.*server&quot;</span>&#125;</span><br></pre></td></tr></table></figure>

<p>Prometheus中的所有正则表达式都使用 RE2 语法<br>返回度量指标名称是 http_requests_total， 且 http 返回码不以 4 开头的所有时间序列数据：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http_requests_total&#123;status!~<span class="string">&quot;4..&quot;</span>&#125;</span><br></pre></td></tr></table></figure>

<h5 id="2-使用函数，操作符等"><a href="#2-使用函数，操作符等" class="headerlink" title="2. 使用函数，操作符等"></a>2. 使用函数，操作符等</h5><p>返回度量指标 http_requests_total 过去 5 分钟内的 http 请求数的平均增长速率：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rate(http_requests_total[5m])</span><br></pre></td></tr></table></figure>

<p>返回度量指标 http_requests_total 过去 5 分钟内的 http 请求数的平均增长速率总和，维度是 job：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sum</span>(rate(http_requests_total[5m])) by (job)</span><br><span class="line">结果：</span><br><span class="line">&#123;job=<span class="string">&quot;apiserver&quot;</span>&#125;  0.16666666666666666</span><br><span class="line">&#123;job=<span class="string">&quot;kubelet&quot;</span>&#125;  0.49999876544124355</span><br></pre></td></tr></table></figure>

<p>如果两个指标具有相同维度的标签，我们可以使用二元操作符计算样本数据，返回值：key: value&#x3D;标签列表：计算样本值。例如，以下表达式返回每一个实例的空闲内存，单位是 MiB。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(instance_memory_limit_bytes - instance_memory_usage_bytes) / 1024 / 1024</span><br></pre></td></tr></table></figure>

<p>如果想知道每个应用的剩余内存，可以使用如下表达式：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sum</span>(</span><br><span class="line">  instance_memory_limit_bytes - instance_memory_usage_bytes</span><br><span class="line">) by (app, proc) / 1024 / 1024</span><br></pre></td></tr></table></figure>

<p>如果相同的集群调度群显示如下的每个实例的 CPU 使用率：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">instance_cpu_time_ns&#123;app=<span class="string">&quot;lion&quot;</span>, proc=<span class="string">&quot;web&quot;</span>, rev=<span class="string">&quot;34d0f99&quot;</span>, <span class="built_in">env</span>=<span class="string">&quot;prod&quot;</span>, job=<span class="string">&quot;cluster-manager&quot;</span>&#125;</span><br><span class="line">instance_cpu_time_ns&#123;app=<span class="string">&quot;elephant&quot;</span>, proc=<span class="string">&quot;worker&quot;</span>, rev=<span class="string">&quot;34d0f99&quot;</span>, <span class="built_in">env</span>=<span class="string">&quot;prod&quot;</span>, job=<span class="string">&quot;cluster-manager&quot;</span>&#125;</span><br><span class="line">instance_cpu_time_ns&#123;app=<span class="string">&quot;turtle&quot;</span>, proc=<span class="string">&quot;api&quot;</span>, rev=<span class="string">&quot;4d3a513&quot;</span>, <span class="built_in">env</span>=<span class="string">&quot;prod&quot;</span>, job=<span class="string">&quot;cluster-manager&quot;</span>&#125;</span><br><span class="line">instance_cpu_time_ns&#123;app=<span class="string">&quot;fox&quot;</span>, proc=<span class="string">&quot;widget&quot;</span>, rev=<span class="string">&quot;4d3a513&quot;</span>, <span class="built_in">env</span>=<span class="string">&quot;prod&quot;</span>, job=<span class="string">&quot;cluster-manager&quot;</span>&#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>我们可以按照应用和进程类型来获取 CPU 利用率最高的 3 个样本数据：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">topk(3, <span class="built_in">sum</span>(rate(instance_cpu_time_ns[5m])) by (app, proc))</span><br></pre></td></tr></table></figure>

<p>假设一个服务实例只有一个时间序列数据，那么我们可以通过下面表达式统计出每个应用的实例数量：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">count(instance_cpu_time_ns) by (app)</span><br></pre></td></tr></table></figure>

    </article>
    
    <div class="read-nums">
      <!-- id 将作为查询条件 -->
      <span id="2024/06/30/PromQL 讲解/" class="leancloud_visitors" data-flag-title="Your Article Title">
        <em class="post-meta-item-text">浏览量</em>
        <i class="leancloud-visitors-count"></i>
      </span>
    </div>
    <div class="comments-intro">
      <h2>评论区</h2>
      <p>欢迎你留下宝贵的意见，昵称输入QQ号会显示QQ头像哦~</p>
    </div>
    <div id="vcomments" class="vcomments"></div>
    
  </div>
  <div class="article-catelogue">
    <div class="article-catelogue--wrapper">
      <div class="catelogue catelogue-1">
        <h3>目录</h3>
        <ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E8%A1%A8%E8%BE%BE%E5%BC%8F%E8%AF%AD%E8%A8%80%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.</span> <span class="toc-text">一、表达式语言数据类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E3%80%81%E5%AD%97%E9%9D%A2%E9%87%8F"><span class="toc-number">2.</span> <span class="toc-text">二、字面量</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%88%E4%B8%80%EF%BC%89%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-number">2.1.</span> <span class="toc-text">（一）字符串</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%88%E4%BA%8C%EF%BC%89%E6%A0%87%E9%87%8F"><span class="toc-number">2.2.</span> <span class="toc-text">（二）标量</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%89%E3%80%81%E6%97%B6%E9%97%B4%E5%BA%8F%E5%88%97%E8%BF%87%E6%BB%A4%E5%99%A8"><span class="toc-number">3.</span> <span class="toc-text">三、时间序列过滤器</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%88%E4%B8%80%EF%BC%89%E7%9E%AC%E6%97%B6%E5%90%91%E9%87%8F%E8%BF%87%E6%BB%A4%E5%99%A8"><span class="toc-number">3.1.</span> <span class="toc-text">（一）瞬时向量过滤器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%88%E4%BA%8C%EF%BC%89%E5%8C%BA%E9%97%B4%E5%90%91%E9%87%8F%E8%BF%87%E6%BB%A4%E5%99%A8"><span class="toc-number">3.2.</span> <span class="toc-text">（二）区间向量过滤器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%88%E4%B8%89%EF%BC%89%E6%97%B6%E9%97%B4%E4%BD%8D%E7%A7%BB%E6%93%8D%E4%BD%9C"><span class="toc-number">3.3.</span> <span class="toc-text">（三）时间位移操作</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%9B%E3%80%81%E6%93%8D%E4%BD%9C%E7%AC%A6"><span class="toc-number">4.</span> <span class="toc-text">四、操作符</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%88%E4%B8%80%EF%BC%89%E4%BA%8C%E5%85%83%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">4.1.</span> <span class="toc-text">（一）二元运算符</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-%E7%AE%97%E6%9C%AF%E4%BA%8C%E5%85%83%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">4.1.1.</span> <span class="toc-text">1. 算术二元运算符</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-%E5%B8%83%E5%B0%94%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">4.1.2.</span> <span class="toc-text">2. 布尔运算符</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-%E9%9B%86%E5%90%88%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">4.1.3.</span> <span class="toc-text">3. 集合运算符</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%88%E4%BA%8C%EF%BC%89%E5%8C%B9%E9%85%8D%E6%A8%A1%E5%BC%8F"><span class="toc-number">4.2.</span> <span class="toc-text">（二）匹配模式</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-%E4%B8%80%E5%AF%B9%E4%B8%80%E5%8C%B9%E9%85%8D"><span class="toc-number">4.2.1.</span> <span class="toc-text">1. 一对一匹配</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-%E5%A4%9A%E5%AF%B9%E4%B8%80%E5%92%8C%E4%B8%80%E5%AF%B9%E5%A4%9A"><span class="toc-number">4.2.2.</span> <span class="toc-text">2. 多对一和一对多</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-%E8%81%9A%E5%90%88%E6%93%8D%E4%BD%9C"><span class="toc-number">4.2.3.</span> <span class="toc-text">3. 聚合操作</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-%E4%BA%8C%E5%85%83%E8%BF%90%E7%AE%97%E7%AC%A6%E4%BC%98%E5%85%88%E7%BA%A7"><span class="toc-number">4.2.4.</span> <span class="toc-text">4. 二元运算符优先级</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%94%E3%80%81PromQL-%E5%86%85%E7%BD%AE%E5%87%BD%E6%95%B0"><span class="toc-number">5.</span> <span class="toc-text">五、PromQL 内置函数</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-abs"><span class="toc-number">5.0.1.</span> <span class="toc-text">1. abs()</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-absent"><span class="toc-number">5.0.2.</span> <span class="toc-text">2. absent()</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-ceil"><span class="toc-number">5.0.3.</span> <span class="toc-text">3. ceil()</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-changes"><span class="toc-number">5.0.4.</span> <span class="toc-text">4. changes()</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#5-clamp-max"><span class="toc-number">5.0.5.</span> <span class="toc-text">5. clamp_max()</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#6-clamp-min"><span class="toc-number">5.0.6.</span> <span class="toc-text">6. clamp_min()</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#7-day-of-month"><span class="toc-number">5.0.7.</span> <span class="toc-text">7. day_of_month()</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#8-day-of-week"><span class="toc-number">5.0.8.</span> <span class="toc-text">8. day_of_week()</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#9-days-in-month"><span class="toc-number">5.0.9.</span> <span class="toc-text">9. days_in_month()</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#10-delta"><span class="toc-number">5.0.10.</span> <span class="toc-text">10. delta()</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#11-deriv"><span class="toc-number">5.0.11.</span> <span class="toc-text">11. deriv()</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#12-exp"><span class="toc-number">5.0.12.</span> <span class="toc-text">12. exp()</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#13-floor"><span class="toc-number">5.0.13.</span> <span class="toc-text">13. floor()</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#14-histogram-quantile"><span class="toc-number">5.0.14.</span> <span class="toc-text">14. histogram_quantile()</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#15-holt-winters"><span class="toc-number">5.0.15.</span> <span class="toc-text">15. holt_winters()</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#16-hour"><span class="toc-number">5.0.16.</span> <span class="toc-text">16. hour()</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#17-idelta"><span class="toc-number">5.0.17.</span> <span class="toc-text">17. idelta()</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#18-increase"><span class="toc-number">5.0.18.</span> <span class="toc-text">18. increase()</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#19-irate"><span class="toc-number">5.0.19.</span> <span class="toc-text">19. irate()</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#20-label-join"><span class="toc-number">5.0.20.</span> <span class="toc-text">20. label_join()</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#21-label-replace"><span class="toc-number">5.0.21.</span> <span class="toc-text">21. label_replace()</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#22-ln"><span class="toc-number">5.0.22.</span> <span class="toc-text">22. ln()</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#23-log2"><span class="toc-number">5.0.23.</span> <span class="toc-text">23. log2()</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#24-log10"><span class="toc-number">5.0.24.</span> <span class="toc-text">24. log10()</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#25-minute"><span class="toc-number">5.0.25.</span> <span class="toc-text">25. minute()</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#26-month"><span class="toc-number">5.0.26.</span> <span class="toc-text">26. month()</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#27-predict-linear"><span class="toc-number">5.0.27.</span> <span class="toc-text">27. predict_linear()</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#28-rate"><span class="toc-number">5.0.28.</span> <span class="toc-text">28. rate()</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#29-resets"><span class="toc-number">5.0.29.</span> <span class="toc-text">29. resets()</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#30-round"><span class="toc-number">5.0.30.</span> <span class="toc-text">30. round()</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#31-scalar"><span class="toc-number">5.0.31.</span> <span class="toc-text">31. scalar()</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#32-sort"><span class="toc-number">5.0.32.</span> <span class="toc-text">32. sort()</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#33-sort-desc"><span class="toc-number">5.0.33.</span> <span class="toc-text">33. sort_desc()</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#34-sqrt"><span class="toc-number">5.0.34.</span> <span class="toc-text">34. sqrt()</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#35-time"><span class="toc-number">5.0.35.</span> <span class="toc-text">35. time()</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#36-timestamp"><span class="toc-number">5.0.36.</span> <span class="toc-text">36. timestamp()</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#37-vector"><span class="toc-number">5.0.37.</span> <span class="toc-text">37. vector()</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#38-year"><span class="toc-number">5.0.38.</span> <span class="toc-text">38. year()</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#39-over-time"><span class="toc-number">5.0.39.</span> <span class="toc-text">39. _over_time()</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%AD%E3%80%81-%E7%AE%80%E5%8D%95%E7%A4%BA%E4%BE%8B"><span class="toc-number">6.</span> <span class="toc-text">六、 简单示例</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-%E7%AE%80%E5%8D%95%E7%9A%84%E6%97%B6%E9%97%B4%E5%BA%8F%E5%88%97%E9%80%89%E6%8B%A9"><span class="toc-number">6.0.1.</span> <span class="toc-text">1. 简单的时间序列选择</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-%E4%BD%BF%E7%94%A8%E5%87%BD%E6%95%B0%EF%BC%8C%E6%93%8D%E4%BD%9C%E7%AC%A6%E7%AD%89"><span class="toc-number">6.0.2.</span> <span class="toc-text">2. 使用函数，操作符等</span></a></li></ol></li></ol></li></ol>
      </div>
      
        <div class="catelogue catelogue-2">
          
            <p>
              <span>上一篇：</span>
              <a href="/2024/07/26/微服务概念/">微服务</a>
            </p>
           
          
            <p>
              <span>下一篇</span>
              <a href="/2024/06/26/自定义监控/">prometheus自定义监控</a>
            </p>
          
        </div>
      
    </div>
  </div>
</div>


<script>
  // var定义，避免pjax重新进来造成的重复声明错误
  var config = JSON.parse('{"enable":true,"appId":"Pf8zCXGEH1qsprnWfikVVujL-gzGzoHsz","appKey":"qOqoiUHhH1TGtLRUYURkLRQX","placeholder":"请留下你宝贵的意见吧~","meta":["nick"],"recordIP":true,"visitor":true,"enableQQ":true}')
  new Valine({
    el: '#vcomments',
    appId: config.appId,
    appKey: config.appKey,
    placeholder: config.placeholder,
    meta: config.meta,
    recordIP: config.recordIP,
    visitor: config.visitor,
    enableQQ: config.enableQQ,
    path: '2024/06/30/PromQL 讲解/'
  })
</script>


<script>
  $(document).on('pjax:complete', function() {
    const tocs = document.querySelector('.toc')
    const links = tocs ? tocs.querySelectorAll('a') : []
    links.forEach(link => {
      link.addEventListener('click', e => {
        const href = decodeURIComponent(e.href)
        href.search(/#(.*)/)
        const id = RegExp.$1
        const target = document.querySelector('#' + id)
        const top = target.offsetTop
        document.documentElement.scrollTo({
          top: top - 100,
          behavior: 'smooth'
        })
        e.preventDefault()
      })
    })
  })
</script> 

</div>
      <div class="main-right-wrapper"><div class="main-right">
  <div class="main-right--board">
    <div class="main-right--title">
      <h5>公告栏</h5>
      <i class="iconfont icon-gonggao"></i>
    </div>
    <div class="main-right--content">
      Hello~大噶好。唔系小曹宅，欢迎你们来到我的博客小站，希望能在这里收获到有用的东西哦！ 
    </div>
  </div>

  <div id="aplayer" class="main-right--music"></div>

  <div class="operate-items">
    <div class="operate-item backtop">
      <i class="iconfont icon-huidaodingbu"></i>
      <span>回到顶部</span>
    </div>
    
    <div class="operate-item turn-comment hidden">
      <i class="iconfont icon-pinglun"></i>
      <span>查看评论</span>
    </div>
    
  </div>

  <div class="main-right--site">
    <div class="main-right--power">
      <p>Power By <a target="_blank" rel="noopener" href="https://hexo.io/zh-cn/docs/">Hexo</a>.</p>
      <p>Theme：<a target="_blank" rel="noopener" href="https://github.com/Aizener/hexo-theme-cola">Cola.</a></p>
    </div>
    <p class="main-right--refer"><a target="_blank" rel="noopener" href="https://beian.miit.gov.cn/#/Integrated/index">2262690094</a> </p>
  </div>
</div>

<script>
  function setOperateItem () {
    const reg = /\d{4}\/\d{2}\/\d{2}\/.+/
    const path = location.pathname
    const operateDom = document.querySelector('.main-right .operate-items')
    const commentDom = document.querySelector('.turn-comment')
    const cateloguDom = document.querySelector('.article-catelogue > .article-catelogue--wrapper');

    if (commentDom) {
      if (reg.test(path) || path.match(/\/log\/.+/)) {
        commentDom.classList.remove('hidden')
        const newDom = operateDom.cloneNode(true);
        const _backtopDom = newDom.querySelector('.backtop');
        const _commentDom = newDom.querySelector('.turn-comment');
        _backtopDom.addEventListener('click', () => backTopEvent());
        _commentDom.addEventListener('click', () => commentDomEvent());
        cateloguDom.appendChild(newDom);
      } else {
        commentDom.classList.add('hidden')
      }
    }
  }

  setOperateItem()
  const musics = JSON.parse(`[{"name":"不找了","artist":"隔壁老樊","url":"music/隔壁老樊 - 不找了.mp3","cover":"https://img2.baidu.com/it/u=1260056724,1076343118&fm=253&fmt=auto&app=138&f=JPEG?w=500&h=500"},{"name":"于是天气刚好","artist":"泪桥","url":"music/于是天气刚好 - 泪桥.mp3","cover":"https://img2.baidu.com/it/u=705831265,2862720033&fm=253&fmt=auto&app=138&f=JPEG?w=500&h=500"},{"name":"安和桥","artist":"林芬宇","url":"music/林芬宇 - 安和桥.mp3","cover":"https://encrypted-tbn0.gstatic.com/images?q=tbn:ANd9GcQo0SWQx6YrNA8lElaG4OOKLkNkNzLO1PflKg&usqp=CAU"}]`)
  const ap = new APlayer({
    container: document.querySelector('#aplayer'),
    audio: musics,
  })

  $(document).on('pjax:complete', function() {
    setOperateItem()
  })

  document.querySelector('.backtop').addEventListener('click', () => {
    backTopEvent();
  })
  const dom = document.querySelector('.turn-comment')
  dom && dom.addEventListener('click', () => {
    commentDomEvent();
  })

  function backTopEvent() {
    document.documentElement.scrollTo({
      top: 0,
      behavior: 'smooth'
    })
  }

  function commentDomEvent() {
    const commentDom = document.querySelector('.comments-intro')
    if (!commentDom) return
    const top = commentDom.offsetTop, height = commentDom.offsetHeight
    document.documentElement.scrollTo({
      top: top - 2 * height,
      behavior: 'smooth'
    })
  }
</script></div>
    </section>
  </div>
  <div id="progress" class="progress"></div>
  <div id="gray" class="gray"></div>

  <script>
    function initScroll () {
      document.addEventListener('scroll', () => {
        const doc = document.documentElement
        const scrollTop = doc.scrollTop
        const pageHeight = doc.offsetHeight
        const clientHeight = doc.clientHeight
        const ratio = scrollTop / (pageHeight - clientHeight)
        const progress = document.querySelector('#progress')
        const avatarImg = document.querySelector('.main-left--avatar')
        progress.style.width = (100 * ratio) + '%'
        avatarImg.style.transform = `rotate(${360 * ratio}deg)`
      })
    }

    const rootPath = "/"

    const checkAndSetArticlePageLayout = () => {
      const path = location.pathname.replace(rootPath, '');
      if (
        /^\/?\d{4}\/\d{2}\/\d{2}\/.*/.test(path) ||
        /^log\/.+/.test(path)
      ) {
        $('.main-container, .main-right, .main-right-wrapper').addClass('is-article')
      } else {
        $('.main-container, .main-right, .main-right-wrapper').removeClass('is-article')
      }
    }

    const gray = "none"
    const setGrayStyle = () => {
      if (gray === 'none') {
        return
      } else if (gray === 'index') {
        location.pathname === '/' ? $('#gray').show() : $('#gray').hide()
      } else if (gray === 'all') {
        $('#gray').show()
      }
    }
    setGrayStyle()


    window.onload = function () {
      checkAndSetArticlePageLayout()
      setTimeout(() => {
        $('#load').slideUp()
        $('#container').slideToggle()
        setTimeout(() => {
          initScroll();
        }, 500)
      }, 500)
    }
    
    let status = 0
    // 对所有链接跳转事件绑定pjax容器container
    $(document).pjax('a[target!=_blank]', '#main-container', {
      container: '#main-container',
      fragment: '#main-container',
      timeout: 8000
    })

    $(document).on('pjax:start', function() {
    })
    $(document).on('pjax:complete', function() {
      status = 0
      $('.main-container').addClass('to-up').on('animationend', function() {
        $(this).removeClass('to-up')
      })
      setGrayStyle()
      checkAndSetArticlePageLayout()
    })
    $(document).on('pjax:popstate', function() {
      status = -1
      checkAndSetArticlePageLayout()
    });
  </script>
</body>
</html>